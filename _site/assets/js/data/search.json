[
  
  {
    "title": "[백준] 1946번 신입사원",
    "url": "/posts/algorithm-bj-1946/",
    "categories": "Algorithm",
    "tags": "Baekjoon, algorithm",
    "date": "2019-07-12 00:22:00 +0800",
    





    "snippet": "백준 알고리즘 1946번 신입사원 문제풀이문제신입 사원을 뽑는데, 다른 모든 지원자와 비교했을 때서류심사 성적과 면접시험 성적 중 적어도 하나가 다른 지원자보다 떨어지지 않는 자만 선발한다.이 조건을 만족시키면서 선발할 수 있는 최대 인원수는??풀이우선, 서류 성적을 기준으로 정렬을 하면, 어짜피 서류성적은 이미 정렬해놔서 고려할 필요가 없고 본인보다 서류 성적이 높은 사람들의 최고 면접 점수보다 본인의 면접 점수가 높으면 합격할 수 있습니다.153 2  -&amp;gt; 1 41 4      2 34 1      3 22 3      4 15 5      5 5예제를 바탕으로 위의 값(왼쪽)을 입력했다고 했을 경우,1등은 다른 지원자보다 떨어질 수가 없기에 기준점으로 잡고자 우선 오름차순 정렬(오른쪽)을 해줍니다.그 후, 면접성적이 본인보다 서류 성적이 높은 사람의 면접 성적(최대값)보다 높은 등수인지 확인합니다.(면접 성적을 위에서부터 비교하며 max값을 갱신하고 그 값과 면접 성적을 비교합니다.)아래는 풀이한 코드입니다.#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main(){    int t;    cin &amp;gt;&amp;gt; t;    while (t-- &amp;gt; 0) {        int n;        cin &amp;gt;&amp;gt; n;        int cnt = 1;        pair&amp;lt;int, int&amp;gt; p[100000];        int a_idx, b_idx;        for (int i = 0; i &amp;lt; n; i++) {            int a, b;            cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;            p[i] = make_pair(a, b);        }        sort(p, p + n);        int pivot = p[0].second;        for (int i = 1; i &amp;lt; n; i++) {            if (p[i].second &amp;lt; pivot) {                cnt++;                pivot = p[i].second;            }        }        cout &amp;lt;&amp;lt; cnt &amp;lt;&amp;lt; endl;    }    return 0;}궁금한점, 지적할점 댓글 환영합니다:)"
  },
  
  {
    "title": "[백준] 2437번 저울",
    "url": "/posts/algorithm-bj-2437/",
    "categories": "Algorithm",
    "tags": "Baekjoon, algorithm",
    "date": "2019-07-10 14:51:00 +0800",
    





    "snippet": "백준 알고리즘 2437번 저울 문제 풀이문제무게가 양의 정수인 N개의 저울 추가 주어졌을 때, 이 추들을 사용하여 측정할 수 없는 양의 정수 무게 중 최솟값 구하기.풀이Greedy 방식으로 해결할 수 있는 문제로, 각 추를 정렬 후 누적합을 구하면서 해결해 나갈 수 있습니다.우선, 추의 배열을 w, 누적합의 배열을 acc라고 정의하겠습니다.무게가 1인 추가 있을 때, acc[i-1] + 1 &amp;gt;= w[i] 일 경우 acc[i-1] ~ acc[i] 사이의 모든 수를 만들 수 있습니다. 만약 저 조건에 해당하지 않는다면 acc[i-1] + 1이 만들수 없는 수 입니다.그리고 무게가 1인 추가 없다면 당연히 답은 1이겠죠?문제에 제시된 예제를 통해 설명하도록 하겠습니다.             i      0      1      2      3      4      5      6                  추(w)      1      1      2      3      6      7      30              누적합(acc)      1      2      4      7      13      20      50      acc[5]을 보시면 w[6] - 1보다 작아, 해당 예시의 정답은 21 입니다.처음 풀이를 알게 되었을 때는 이게 어떻게 성립하는 것인지 이해가 되지 않아서 반례를 찾아보려 했는데요..부질없는 짓이었고 오히려 명확하게는 아니지만 어느정도 이해하게 되었습니다.. 위 예제에서 답이 왜 21인지는 알겠지만 19, 18 뭐 이런 숫자들이 왜 다 만들 수 있는건지는 잘 이해는 안되네요 ㅎㅎ(ps. 혹시나 원리를 설명해주실 수 있으신 분은 댓글로 설명 나눠주시면 감사하겠습니다 ^^)아래는 풀이한 코드입니다.#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main(void){    int n;    int num[1000];    cin &amp;gt;&amp;gt; n;    for (int i = 0; i &amp;lt; n; i++) cin &amp;gt;&amp;gt; num[i];    sort(num, num + n);    int result = 1;    if (num[0] == 1) {        int acc = num[0];        for (int i = 1; i &amp;lt; n &amp;amp;&amp;amp; acc &amp;gt;= num[i] - 1; i++) acc += num[i];        result = acc + 1;    }    cout &amp;lt;&amp;lt; result;    return 0;}질문이나 지적하실 부분이 있다면 댓글 남겨주세요 :)"
  }
  
]

