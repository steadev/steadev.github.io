[ { "title": "[React Native] word-break", "url": "/posts/rn-word-break-keep-all/", "categories": "React Native", "tags": "React Native, React Native Style", "date": "2022-10-13 17:10:00 +0800", "snippet": "word-break와 같은 부분이 적용이 안되는 이슈!RN에는 CSS와 조금 다르게 스타일이 적용되는 부분들이 있는데요..!그 중에서 word-break: keep-all을 적용하고 싶은데 안되는 이슈가… 왜 이것도 지원 안해주지? 하는 의문이 들었습니다.아직 RN 버전이 0.대라 부족한 부분이 많은 것 같긴 합니다. 버전 1.대까지 간다면 생기지 않을까 싶습니다..!하지만, 뭐든 방법은 있는법..!string을 띄어쓰기를 기준으로 나눈 뒤, flexWrap 속성을 활용하면 됩니다.이 속성은 나열된 요소들의 총 너비가 부모보다 크면 다음 줄에 이어서 나열하도록 합니다.이를 바탕으로 컴포넌트를 만들어봤습니다.import React from \"react\";import { StyleSheet, Text, TextStyle, View } from \"react-native\";const WordBreakKeepAllText = ({ text, textStyles,}: { text: string; textStyles?: TextStyle;}) =&gt; { return ( &lt;View style={styles.container}&gt; {text.split(\" \").map((word, index) =&gt; ( &lt;Text key={`${word}-${index}`} style={textStyles}&gt; {word}{\" \"} &lt;/Text&gt; ))} &lt;/View&gt; );};const styles = StyleSheet.create({ container: { display: \"flex\", flexDirection: \"row\", flexWrap: \"wrap\", },});export default WordBreakKeepAllText;결과 비교위는 그냥 &lt;Text&gt;blabla&lt;/Text&gt;의 결과이고아래는 위 컴포넌트 적용했을 때의 결과입니다." }, { "title": "CSS Preprocessor - SCSS", "url": "/posts/css-scss/", "categories": "CSS", "tags": "css, scss", "date": "2022-08-14 22:31:00 +0800", "snippet": "SASS vs SCSS sass 이후에 scss가 나왔고, css와 거의 같은 문법으로 sass의 기능을 지원합니다. sass 에는 ; 와 {} 가 없습니다. sass vs scss → = vs @mixin , + vs @include SASS =image($size)\twidth: $size\theight: $size.title\tfont-size: 16pt\twidth: 100%\t&amp;:first-child\t\tfont-weight: 800\timg\t\t+image(40px) SCSS @mixin image($size) { width: $size; height: $size;}.title { font-size: 16pt; width: 100%; &amp;:first-child { font-weight: 800; } img { @include image(40px); }} @at-root 중첩된 자식 부분을 최상단(root)로 끌어올림.title { font-size: 16pt; width: 100%; &amp;:first-child { font-weight: 800; } @at-root img { height: 40px; }}Complied to:.title { font-size: 16pt; width: 100%;}.title:first-child { font-weight: 800;}// if not using @at-root.title img { height: 40px;}// using @at-rootimg { height: 40px;}중첩 속성 표현font- , padding- , margin- 등과 같이 동일한 네임스페이스 가지는 속성들을 다음과 같이 사용.// cssfont-size: 16pt;font-weight: 800;margin-top: 10px;padding-bottom: 30px;// scssfont: { size: 16pt; weight: 800;}margin: { top: 10px;}padding: { bottom: 30px;}변수 $ + variable name child에서의 변수의 유효범위를 전역으로 할때. !global 값이 할당되지 않은 변수 초기값 설정. !default $font-size: 16pt;$width: 100%;.title { $font-size: 10pt !global; // overrided! Compiled to: 10pt; font-size: $font-size; $width: 50% !default; // not overrided! Compiled to: 100%; width: $width; &amp;:first-child { font-weight: 800; } img { height: 40px; }} $font-size 는 global로 설정되면서 값이 override 되었고,$width 는 이미 설정된 값이 있으니 50%는 무시되고 100% 그대로 적용됨. 문자열 보간#{} 이용해서 변수 값 넣기$path: \"background/image/img.png\";background: url(\"https://test.com/#{$path}\");연산자 산술 연산자+ - * / % 비교 연산자== != &lt; &gt; &lt;= &gt;= 논리 연산자and or notMixin 재사용할 css 그룹을 정의하는 기능@mixin font($size, $line-height, $color) { font: { size: $size; } line-height: $line-height; color: $color;}.title { @include font(20px, 24px, white);}특정 파라미터만 전달@mixin font($size, $line-height: 16px, $color: white) { font: { size: $size; } line-height: $line-height; color: $color;}.title { @include font($size: 16pt, $color: black);}가변 인수 입력할 파라미터 개수가 불확실할 경우 변수 뒤에 ... 사용.@mixin box-shadow($shadow...) { box-shadow: $shadow;}div { @include box-shadow(3px 3px red, -1em 0 0.4em olive);} 전달하는 경우에도 마찬가지@mixin font($size, $line-height: 16px, $color: white) { font: { size: $size; } line-height: $line-height; color: $color;}.title { $font-values: ( size: 16pt, line-height: 20px, color: black, ); @include font($font-values...);}@content angular의 &lt;ng-content&gt;처럼 기존 mixin에 새로운 속성, class를 추가할 수 있음.@mixin font($size, $line-height: 16px, $color: white) { font: { size: $size; } line-height: $line-height; color: $color; @content;}.title { @include font(20px, 24px, white) { font-weight: bold; }}상속 다른 class의 스타일을 상속받아 사용할 수 있습니다. 하지만 이 기능은 권장하지 않으며 mixin 사용을 권장 (https://sass-guidelin.es/ko/#extend).title { font-size: 16pt; width: 100%;}.description { @extend .title; font-weight: bold;}조건문if 3항 연산자처럼 사용$width: 500px;div { // true ? a : b; width: if($width &gt; 300px, $width, 200px);}@if@if (statement) { // ...} @else if (statement2) { // ...} @else { // ...}반복문@for@for - from - through , @for - from - to$base-color: #036;// 1 ~ 3까지 (3포함) -&gt; 3번 반복@for $i from 1 through 3 { ul:nth-child(3n + #{$i}) { background-color: lighten($base-color, $i * 5%); }}// 1 ~ 3 미만 (3 미포함) -&gt; 2번 반복@for $i from 1 to 3 { ul:nth-child(3n + #{$i}) { background-color: lighten($base-color, $i * 5%); }}@each$sizes: 40px, 50px, 80px;@each $size in $sizes { .icon-#{$size} { font-size: $size; height: $size; width: $size; }}@while@use \"sass:math\";/// Divides `$value` by `$ratio` until it's below `$base`.@function scale-below($value, $base, $ratio: 1.618) { @while $value &gt; $base { $value: math.div($value, $ratio); } @return $value;}$normal-font-size: 16px;sup { font-size: scale-below(20px, 16px);}Debug@debug 키워드 사용하면 됩니다.컴파일 단계에서 빌드 로그에 찍힘!@debug \"hello wrold!\";내장 함수색상(RGB / HSL / Opacity) 함수mix($color1, $color2) : 두 개의 색을 섞습니다.lighten($color, $amount) : 더 밝은색을 만듭니다.darken($color, $amount) : 더 어두운색을 만듭니다.saturate($color, $amount) : 색상의 채도를 올립니다.desaturate($color, $amount) : 색상의 채도를 낮춥니다.grayscale($color) : 색상을 회색으로 변환합니다.invert($color) : 색상을 반전시킵니다.rgba($color, $alpha) : 색상의 투명도를 변경합니다.opacify($color, $amount) / fade-in($color, $amount) : 색상을 더 불투명하게 만듭니다.transparentize($color, $amount) / fade-out($color, $amount) : 색상을 더 투명하게 만듭니다.문자(String) 함수unquote($string) : 문자에서 따옴표를 제거합니다.quote($string) : 문자에 따옴표를 추가합니다.str-insert($string, $insert, $index) : 문자의 index번째에 특정 문자를 삽입합니다.str-index($string, $substring) : 문자에서 특정 문자의 첫 index를 반환합니다.str-slice($string, $start-at, [$end-at]) : 문자에서 특정 문자(몇 번째 글자부터 몇 번째 글자까지)를 추출합니다.to-upper-case($string) : 문자를 대문자를 변환합니다.to-lower-case($string) : 문자를 소문자로 변환합니다.숫자(Number) 함수percentage($number) : 숫자(단위 무시)를 백분율로 변환합니다.round($number) : 정수로 반올림합니다.ceil($number) : 정수로 올림합니다.floor($number) : 정수로 내림(버림)합니다.abs($number) : 숫자의 절대 값을 반환합니다.min($numbers…) : 숫자 중 최소 값을 찾습니다.max($numbers…) : 숫자 중 최대 값을 찾습니다.random() : 0 부터 1 사이의 난수를 반환합니다.List 함수모든 List 내장 함수는 기존 List 데이터를 갱신하지 않고 새 List 데이터를 반환합니다.모든 List 내장 함수는 Map 데이터에서도 사용할 수 있습니다.length($list) : List의 개수를 반환합니다.nth($list, $n) : List에서 n번째 값을 반환합니다.set-nth($list, $n, $value) : List에서 n번째 값을 다른 값으로 변경합니다.join($list1, $list2, [$separator]) : 두 개의 List를 하나로 결합합니다.zip($lists…) : 여러 List들을 하나의 다차원 List로 결합합니다.index($list, $value) : List에서 특정 값의 index를 반환합니다.Map 함수모든 Map 내장 함수는 기존 Map 데이터를 갱신하지 않고 새 Map 데이터를 반환합니다.map-get($map, $key) : Map에서 특정 key의 value를 반환합니다.map-merge($map1, $map2) : 두 개의 Map을 병합하여 새로운 Map를 만듭니다.map-keys($map) : Map에서 모든 key를 List로 반환합니다.map-values($map) : Map에서 모든 value를 List로 반환합니다.관리(Introspection) 함수variable-exists(name) : 변수가 현재 범위에 존재하는지 여부를 반환합니다.(인수는 $없이 변수의 이름만 사용합니다.)unit($number) : 숫자의 단위를 반환합니다.unitless($number) : 숫자에 단위가 있는지 여부를 반환합니다.comparable($number1, $number2) : 두 개의 숫자가 연산 가능한지 여부를 반환합니다.ref)https://heropy.blog/2018/01/31/sass/https://sass-lang.com/documentation/at-rules" }, { "title": "Dependency Injection", "url": "/posts/js-dependency-injection/", "categories": "Javascript", "tags": "javascript, angular, DI", "date": "2022-07-27 22:33:00 +0800", "snippet": "Dependency Injection이란?Dependency Injection 말은 많이 들어보고 실제로 엄청 쓰고 있긴 한데이게 뭔 말일까?? 의존성 주입? 의존성은 뭐고 주입은 또 뭐지?일단 정의를 한번 보겠습니다. Dependency injection is a technique in which an object receives other objects that it depends on. (wiki)위키피디아에서의 정의로, 의존성 주입은 객체가 의존하는 다른 객체를 받는 기술입니다.…? 의존하는 다른 객체를 받는다는게 뭔 소리일까? Dependency injection, or DI, is a design pattern in which a class requests dependencies from external sources rather than creating them. (Angular Docs)앵귤러에서 말하는 DI는 내부에서 직접 의존성을 만들기보다는 외부에 의존성들을 요청한다는 좀더 직관적인(?) 설명을 하고 있습니다.일단 Dependency(의존)에 대해서 알아보겠습니다.Dependency말 그대로 한 객체가 다른 객체에 의존한다는 말!class A {\tprivate b = new B();}위 코드를 보면 A는 B가 있어야 기능을 수행할 수가 있습니다.이를 A 클래스가 B 클래스에 의존성을 가진다고 표현합니다.위 케이스를 더 정확히 표현하면 Object Dependency라고 합니다.그렇다면 Injection이란 뭘까?외부에서 값이나 객체를 생성해서 넣어주는 것을 의미합니다. 바로 예시를 보면 알 수 있다!class A { constructor(private n: number) {}}...const a = new A(10);그렇다면, Dependency Injection이란 의존성을 가진 객체를 주입하는 것임을 알 수 있습니다.다시 처음 DI 정의들을 보면 이해가 갑니다.그리고 추가적으로 ioc라는 개념이 있습니다.IoC(Inversion of Control)말그대로 컨트롤이 거꾸로 됐다는 것으로, 제어의 역전이라고 합니다..class A에서 직접 B를 만들어 사용하는 것은 본인이 직접 다 하는 것이지만,그와 반대로 DI는 알아서 만들어오라고 요청하는 것이기에 IoC라고 합니다.비유하자면,김장하는데 속재료들을 직접 만들어 쓰는게 아니라,속재료 내놔! 김치 먹고싶으면.이런 느낌일 것 같습니다.그런데, Angular에서 DI를 쓰는거에 의문이 하나 생깁니다.내가 외부에서 객체를 생성해서 직접 넣어주지도 않았는데 객체가 주입될까?@Injectable() 데코레이터를 통해, 혹은 providers에 등록이 되어 있다면프레임워크가 알아서 생성해서 주입 시켜준다.React는 프레임워크가 아니기에 수동으로 처리해줘야 합니다.이를 IoC Container라고 한다. 제어권을 컨테이너(framework)가 가져가는 것.프레임워크가 객체의 생성을 책임지고, 의존성을 관리해줍니다.@Injectable()의 providedIn에 ‘root’말고도 다른 옵션들이 있는데 차이점은? root\t- application-level에서 singleton 인스턴스가 주입된다. platform - 모든 application에서 공유되는 singleton 인스턴스가 주입된다. any - 모든 lazy loaded 모듈마다 새로운 인스턴스가 주입된다. 대신 앱 실행 전에 로드된 모듈들에는 하나의 인스턴스가 공유된다. null - 아무 값도 넣지 않았을 때이고, scope이 없기 때문에 직접 providers에 넣어줘야 한다.Dependency Injection이 뭔지는 알겠는데 그러면 왜 사용하는거지? 의존 관계 설정이 컴파일시가 아닌 실행시에 이루어져 모듈들간의 결합도를 낮출 수 있다. 코드 재사용을 높여서 작성된 모듈을 여러 곳에서 소스코드의 수정 없이 사용할 수 있다. 모의 객체 등을 이용한 단위 테스트의 편의성을 높여준다.라고 위키에 쓰여있습니다.그렇지만 확 와닿지는 않는…아래 케이스를 보면 어떤 점이 좋은지 파악하기 쉬울 것 같습니다.abstract class Bird {...}class Sparrow extends Bird {...}class Pigeon extends Bird {...}class DI {\tconstructor() {\t\t// case 1\t\tthis.bird = new Sparrow();\t\t// case 2\t\tthis.bird = new Pigeon();\t}}------------ toabstract class Bird {...}class Sparrow extends Bird {...}class Pigeon extends Bird {...}class DI {\tconstructor(private bird: Bird) {\t}}이렇듯 객체 생성을 직접 하지 않고 떠넘김(?)으로 결합도를 낮출 수 있고 코드의 양도 많이 줄어들게 됩니다.ref) https://medium.com/@jang.wangsu/di-dependency-injection-이란-1b12fdefec4f https://ko.wikipedia.org/wiki/의존성_주입 https://edykim.com/ko/post/understanding-angular-dependency-injection-inject-injectable-tokens-and-providers/ https://medium.com/@jang.wangsu/di-inversion-of-control-container-란-12ecd70ac7ea https://velog.io/@jojo_devstory/DIDependency-Injection에-대해-알아보자 https://www.youtube.com/watch?v=_GjfTDECWOg https://velog.io/@wlsdud2194/what-is-di" }, { "title": "유용한 html tags", "url": "/posts/html-useful-tags/", "categories": "HTML", "tags": "html", "date": "2022-07-25 22:48:00 +0800", "snippet": "유용한 html tag 모음progress progress bar 표시&lt;progress value=\"10\" min=\"0\" max=\"100\"&gt;&lt;/progress&gt;meter progress와 유사하지만, 단계별로 색을 표현할 수 있습니다.&lt;meter value=\"20\" min=\"0\" max=\"100\" low=\"20\" high=\"65\"&gt;&lt;/meter&gt; 단계별 색을 커스터마이징 할 수 있습니다.high 초과: meter::-webkit-meter-even-less-good-value (non-standard. do not use in production)low 이상 ~ high 이하: meter::-webkit-meter-optimum-valuelow 미만: meter::-webkit-meter-suboptimum-value optimum값을 지정해 줄 경우는 조금 달라집니다.optimum값이 위치한 범위(low미만 / 중간 / high초과)에 css로 지정한 색이 입혀집니다.&lt;meter value=\"20\" min=\"0\" max=\"100\" low=\"20\" high=\"65\" optimum=\"75\"&gt;&lt;/meter&gt;details foldable menu - notion의 &gt; 와 같은 역할을 하는 태그&lt;details&gt; &lt;summary&gt;Front-End&lt;/summary&gt; &lt;div&gt;Angular&lt;/div&gt; &lt;div&gt;React&lt;/div&gt; &lt;div&gt;Vew&lt;/div&gt; &lt;div&gt;Svelte&lt;/div&gt;&lt;/details&gt;picture window size별로 다른 이미지를 제공할 수 있는 태그 window size가 작은데 용량 큰 고화질 이미지를 제공할 필요가 없으니 빠른 로딩 가능 media 파라미터로 min-width or max-width 설정. 반응형 media 쿼리와 동일하게 동작&lt;picture&gt; &lt;source srcset=\"https://media.nature.com/lw800/magazine-assets/d41586-020-01430-5/d41586-020-01430-5_17977552.jpg\" media=\"(min-width:1200px)\" /&gt; &lt;source srcset=\"https://hips.hearstapps.com/hmg-prod.s3.amazonaws.com/images/dog-puppy-on-garden-royalty-free-image-1586966191.jpg?crop=0.752xw:1.00xh;0.175xw,0&amp;resize=640:*\" media=\"(min-width:900px)\" /&gt; &lt;source srcset=\"data:image/jpeg;base64,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\" media=\"(min-width:500px)\" /&gt; &lt;img src=\"https://media.nature.com/lw800/magazine-assets/d41586-020-01430-5/d41586-020-01430-5_17977552.jpg\"&gt;&lt;/picture&gt;datalist 자동완성 기능을 제공할 수 있는 태그 input 태그의 list 속성과 datalist 의 id를 매칭만 시켜주면 됩니다.&lt;input type=\"text\" list=\"input-options\" /&gt;&lt;datalist id=\"input-options\"&gt; &lt;option value=\"option1\"&gt;&lt;/option&gt; &lt;option value=\"option2\"&gt;&lt;/option&gt; &lt;option value=\"option3\"&gt;&lt;/option&gt; &lt;option value=\"option4\"&gt;&lt;/option&gt; &lt;option value=\"option5\"&gt;&lt;/option&gt; &lt;option value=\"option6\"&gt;&lt;/option&gt;&lt;/datalist&gt;위의 태그들이 모두 포함된 html 예시 코드입니다. 아래 사진과 같이 나옵니다.&lt;html&gt; &lt;head&gt; &lt;style&gt; details[open] { background-color: lightblue; } /* meter::-webkit-meter-inner-element { } meter::-webkit-meter-even-less-good-value { background-color: red; } meter::-webkit-meter-optimum-value { background-color: black; } meter::-webkit-meter-suboptimum-value { background-color: green; } meter::-webkit-meter-bar { background-color: white; } */ &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;progress value=\"10\" min=\"0\" max=\"100\"&gt;&lt;/progress&gt; &lt;/div&gt;&lt;br&gt;&lt;br&gt; &lt;div&gt; &lt;meter value=\"20\" min=\"0\" max=\"100\" low=\"20\" high=\"65\" optimum=\"75\"&gt;&lt;/meter&gt; &lt;/div&gt;&lt;br&gt;&lt;br&gt; &lt;div&gt; &lt;details&gt; &lt;summary&gt;Front-End&lt;/summary&gt; &lt;div&gt;Angular&lt;/div&gt; &lt;div&gt;React&lt;/div&gt; &lt;div&gt;Veu&lt;/div&gt; &lt;div&gt;Svelte&lt;/div&gt; &lt;/details&gt; &lt;/div&gt;&lt;br&gt;&lt;br&gt; &lt;div&gt; &lt;picture&gt; &lt;source srcset=\"https://media.nature.com/lw800/magazine-assets/d41586-020-01430-5/d41586-020-01430-5_17977552.jpg\" media=\"(min-width:1200px)\" /&gt; &lt;source srcset=\"https://hips.hearstapps.com/hmg-prod.s3.amazonaws.com/images/dog-puppy-on-garden-royalty-free-image-1586966191.jpg?crop=0.752xw:1.00xh;0.175xw,0&amp;resize=640:*\" media=\"(min-width:900px)\" /&gt; &lt;source srcset=\"data:image/jpeg;base64,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\" media=\"(min-width:500px)\" /&gt; &lt;img src=\"https://media.nature.com/lw800/magazine-assets/d41586-020-01430-5/d41586-020-01430-5_17977552.jpg\"&gt; &lt;/picture&gt; &lt;/div&gt;&lt;br&gt;&lt;br&gt; &lt;div&gt; &lt;input type=\"text\" list=\"input-options\" /&gt; &lt;datalist id=\"input-options\"&gt; &lt;option value=\"option1\"&gt;&lt;/option&gt; &lt;option value=\"option2\"&gt;&lt;/option&gt; &lt;option value=\"option3\"&gt;&lt;/option&gt; &lt;option value=\"option4\"&gt;&lt;/option&gt; &lt;option value=\"option5\"&gt;&lt;/option&gt; &lt;option value=\"option6\"&gt;&lt;/option&gt; &lt;/datalist&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;" }, { "title": "Lambda@Edge를 통한 Dynamic OG Tags, SEO", "url": "/posts/aws-lambda-edge/", "categories": "AWS", "tags": "AWS, Lambda@Edge", "date": "2022-05-27 12:19:00 +0800", "snippet": "End user에게 데이터가 가는 중간 과정 각각에 lambda@edge를 통해서 관여할 수 있습니다.Viewer Request   - End User로부터 CloudFront로 요청이 도착한 직후Origin Request  - CloudFront에서 Origin Server로 요청을 보내기 직전Origin Response  - Origin Server에서 보낸 응답이 도착한 직후Viewer Response - CloudFront에서 End User로 Response 보내기 직전주의사항 버지니아 북부(us-east-1) 리전에서만 배포 가능 로그는 CloudWatch에 쌓임. But, us-east-1에 쌓이는 것이 아니고 접속한 각 region에서 쌓입니다.(ex. 서울 region에서 접속했을 경우, 서울 region에서만 로그 확인 가능)SEO 적용 방법Basic Idea Viewer Request에서 해당 요청이 crawler bot에 의한 요청인지 확인 및 header에 해당 정보 추가 Origin Response에서 crawler bot에 의한 요청일 경우 og tag만 포함한 response 전달-&gt; 단순하게 말하자면, bot이 요청했을 경우에 response를 조작하여 보내는 것입니다.함수 작성 및 배포 과정 함수 생성 코드 작성 및 배포 파란 박스에서 코드를 바로 작성하거나 이미 작성된 코드 업로드 빨간 박스를 통해 Lambda@Edge로 배포(Add trigger or Deploy to Lambda@Edge) Distribution 및 edge 선택 후 배포(아래사진) 배포 결과 확인 **로그 확인**us-east-1.xxx 부분 함수 확인!lambda지역과 무관하게 request가 발생한 지역을 기준으로 cloudwatch에 쌓입니다!예시 코드Viewer Requestconst bot = /googlebot|bingbot|yandex|baiduspider|twitterbot|facebookexternalhit|rogerbot|linkedinbot|embedly|quora link preview|showyoubot|outbrain|pinterest|slackbot|vkShare|W3C_Validator|kakaotalk-scrap|yeti|naverbot|kakaostory-og-reader|daum/g;exports.handler = (event, context, callback) =&gt; { const request = event.Records[0].cf.request; const user_agent = request.headers['user-agent'][0]['value'].toLowerCase(); const referer = request.headers['referer']; request.headers['referer'] = [ { key: 'referer', value: Array.isArray(referer) &amp;&amp; referer[0] !== undefined ? referer[0].value : request.headers['host'][0].value } ] if (user_agent) { const found = user_agent.match(bot); request.headers['is-crawler'] = [ { key: 'is-crawler', value: `${!!found}`, }, ]; } callback(null, request);};Origin Response'use strict';// origin-responseexports.handler = async (event, context, callback) =&gt; { const { request, response } = event.Records[0].cf; const { headers, uri } = request || {}; const isCrawlerHeader = request.headers['is-crawler']; let isCrawler = false; if (Array.isArray(isCrawlerHeader) &amp;&amp; isCrawlerHeader[0].value !== undefined &amp;&amp; isCrawlerHeader[0].value !== null) { isCrawler = isCrawlerHeader[0].value; }; if (isCrawler === 'true') { // asset 가져오는 요청이라면 그대로 return; // google search console, naver search advisor html가져올 경우 그대로 return if (uri.includes('assets/') || uri.includes('.html') || uri.includes('robots.txt')) { callback(null, response); return; } const body = `&lt;html&gt;&lt;head&gt; &lt;meta property=\"og:locale\" content=\"ko_KR\" /&gt; &lt;meta property=\"og:locale:alternate\" content=\"en_US\" /&gt; &lt;meta property=\"og:url\" content=\"${uri}\" /&gt; &lt;meta property=\"og:type\" content=\"website\" /&gt; &lt;meta property=\"og:title\" content=\"${title}\" /&gt; &lt;meta property=\"og:description\" content=\"${description}️\"/&gt; &lt;meta property=\"og:image\" content=\"${image}\" /&gt; &lt;meta property=\"og:image:type\" content=\"image/jpg\" /&gt; &lt;meta name=\"twitter:card\" content=\"summary_large_image\" /&gt; &lt;meta name=\"twitter:title\" content=\"${title}\" /&gt; &lt;meta name=\"twitter:description\" content=\"${description}️\" /&gt; &lt;meta name=\"twitter:image\" content=\"${image}\" /&gt; &lt;/head&gt;&lt;/html&gt;`; response.headers = { ...response.headers, \"content-type\": [{\"key\": \"Content-Type\", \"value\": \"text/html\"}] }; response.status = '200'; response.statusDescription = 'OK'; response.body = body; callback(null, response); } else { callback(null, response); }};여기까지에서의 문제점!위 대로 따라하더라도 잘 동작하지 않을 것입니다.. header에 넣어준 is-crawler 헤더가 Origin response 에서 보이질 않습니다. is-crawler가 Origin response에서 확인이 가능하다 하더라도 bot이 아닌 일반 요청에서도 조작된 html이 보이게 됩니다.html파일이 캐싱되어 bot이 아닌데도 캐싱된 response가 가게 되는 것입니다.해결..!is-crawler 헤더 문제CloudFront &gt; 배포 &gt; 동작 편집 에서 정책 생성을 통해 필요한 헤더를 직접 세팅해줄 수 있습니다.원본 요청 정책에 해당 정책을 세팅하면 Origin Response에서 해당 header를 확인할 수 있습니다.캐싱 문제response headers를 초기화하는 부분에 cache를 disable하도록 작성해주어야 합니다!// 꼭 캐시를 사용하지 않도록 설정해야 합니다. response.headers = { ...response.headers, \"content-type\": [{\"key\": \"Content-Type\", \"value\": \"text/html\"}], \"cache-control\": [{\"key\": \"cache-control\", \"value\": \"no-cache, no-store, must-revalidate\"}] };한번 lambda함수를 바꾸면 배포시간이 꽤 걸리고오류가 발생했을 때 console.log를 확인하려면 일일이 cloud watch에 들어가서…어디 지역에서 request가 발생했는지 모르면 계속 지역 바꿔가면서…이런 저런 삽질을 많이 했는데요 :(삽질의 제일 큰 이슈가 위의 header와 캐싱 이슈였습니다;혹시나 비슷한 문제를 겪는 분들께 도움이 되기를 바랍니다 :)질문이나 부족한 부분이 있다면 댓글 부탁드립니다!" }, { "title": "React와 Angular의 DOM", "url": "/posts/js-dom-angular-react/", "categories": "Javascript", "tags": "Javascript, DOM, Angular, React", "date": "2021-12-27 10:54:00 +0800", "snippet": "DOM이란? Document Object Model HTML, XML 문서의 프로그래밍 interface(API) document BOM중의 하나document.querySelector('.woot'); DOM 구성 - Render Tree그렇다면, SPA에서 상태가 변할 때 DOM은 어떤 방식으로 변경될까?[ virtual DOM vs incremental DOM ]virtual DOM React, Vue에서는 DOM의 html 요소가 바뀔 때, 새로운 virtual DOM을 만들어 놓고 기존의 virtual DOM과 비교해서 (diffing) 필요한 부분만 바꿔준다. 컴포넌트의 렌더링 결과를 값으로 받을 수 있고, 이를 테스트나 디버깅 등에 사용할 수 있다. virtual DOM을 사용하기에, 메모리 효율성이 떨어지고 개발자의 컴포넌트 구성에 따라 성능의 차이가 크다.→ 구성에 따라 render를 더 많이해서 virtual DOM을 더 많이 생성하게 되면..!-&gt; react의 PureComponent, memo 사용으로 비용을 최소화 시켜야..! Svelte에서는 이 가상돔을 만들어서 비교하는 과정을 없애서 빠르다. compile하기 때문.React, Vue는 브라우저단에서 바로바로 처리하기 때문에 불가능.incremental DOM 모든 컴포넌트는 일련의 명령으로 컴파일 된다. 이 명령들은 데이터가 변경될 때 그 자리에서 DOM 트리를 만들고 업데이트 한다. Incremental DOM을 사용할 때, 프레임워크는 컴포넌트를 해석하지 않는다.대신, 컴포넌트는 명령들을 참조한다. 사용되지 않는 명령들은 컴파일러단에서 생략이 가능! (so called - Tree Shaking) virtual DOM은 인터프리터가 필요하고, 이는 실시간으로 동작하기 때문에 뭐가 필요한지 아닌지 알 수 없다. 때문에 모든 것을 브라우저에 보내야 한다. incremental DOM은 가상 DOM이 필요 없기에 메모리를 많이 절약할 수 있다. DOM node가 추가되거나 삭제될 때만 메모리를 할당한다.그래서 뭐가 더 좋은거지?💡 Incremental DOM은 메모리의 효율성에서 훨씬 뛰어나지만, 속도면에서는 Virtual DOM 방식이 더 빠르다.앱의 성격에 맞는 것을 선택하면 된다.구글팀에서 Incremental DOM을 선택한 이유?💡 모바일 기기에서의 메모리 최적화를 위해 선택→ 어플리케이션은 반드시 모바일 기기에서 문제 없이 작동해야 한다. 그리고 이는 어플리케이션 번들의 용량(Tree shaking)과 메모리 점유율에 대한 최적화를 의미한다.결론..리액트가 더 빠르다 메모리가 어떻다 비교하는 것은 많지만,개인적으로는 사실 체감 속도는 거의 차이 나지 않는 것 같다. 메모리도 요즘 기기 성능이 워낙 좋아야지…결국 진짜 속도나 메모리에 민감한 서비스가 아닌 이상 취향에 맞는 것을 사용하면 될 듯 싶다참고) https://m.blog.naver.com/magnking/220972680805 https://www.youtube.com/watch?v=1ojA5mLWts8 https://css-tricks.com/an-introduction-and-guide-to-the-css-object-model-cssom/ https://na27.tistory.com/228 https://blog.ninja-squad.com/2019/05/07/what-is-angular-ivy/ https://angular.kr/guide/ivy https://medium.com/@yeon22/angular-incremental-dom-56e1ee9fa3d8 https://blog.nrwl.io/understanding-angular-ivy-incremental-dom-and-virtual-dom-243be844bf36 https://blog.bitsrc.io/incremental-vs-virtual-dom-eb7157e43dca (incremental vs virtual DOM) https://heropy.blog/2019/09/29/svelte/ (svelte) https://browserperson.medium.com/from-view-engine-to-ivy-rendering-in-angular-a81d9eb8199b (view engine vs ivy) https://auth0.com/blog/face-off-virtual-dom-vs-incremental-dom-vs-glimmer/ (compare speed)BOM이란?" }, { "title": "[Android] Notification - 알림 띄우기", "url": "/posts/android-notification/", "categories": "Android", "tags": "Android, Notification", "date": "2021-07-04 15:24:00 +0800", "snippet": "https://developer.android.com/training/notify-user/build-notification?hl=ko   [알림 만들기     Android 개발자     Android Developers 알림은 사용 중이 아닌 앱의 이벤트에 관한 짧고 시기적절한 정보를 제공합니다. 이 페이지에서는 Android 4.0(API 레벨 14) 이상의 다양한 기능을 사용하여 알림을 만드는 방법을 설명합니다. Androiddeveloper.android.com](https://developer.android.com/training/notify-user/build-notification?hl=ko)위의 안드로이드 공식 문서에 알림 띄우는 부분이 잘 정리가 되어 있어서구체적인 방법에 대한 블로깅은 생략하고자 합니다.여기서는 알림을 띄울 때 삽질 했던 부분에 대해서 남기고자 합니다.제가 겪었던 문제는 2가지가 있습니다.1. 알림들이 여러개 왔을 때, 무엇을 클릭하든 제일 처음 온 알림으로만 인식하는 문제2. 상태창에만 알림이 뜨고 head up Notification이 나오지 않는 문제1. 알림들이 여러개 왔을 때, 무엇을 클릭하든 제일 처음 온 알림으로만 인식하는 문제 알림 1, 2, 3이 왔을 때 무조건 1로만 가버리는 문제가 있었는데요..ㅂㄷㅂㄷPendingIntent의 개념?에 대해 잘 이해 못해서 생긴 문제였는데, 아래 코드로 바꾸면서 해결이 되었습니다. // fromPendingIntent.getActivity(context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT)// toPendingIntent.getActivity(context, System.currentTimeMillis().toInt(), intent, PendingIntent.FLAG_UPDATE_CURRENT)getActivity는 다음과 같이 구성되어 있는데요public static PendingIntent getActivity(Context context, int requestCode, Intent intent, int flags) {\tthrow new RuntimeException(\"Stub!\");}context와 requestCode가 같으면, 같은 pendingIntent로 취급해서 flag에 영향을 받게 됩니다.flag가 FLAG_UPDATE_CURRENT라면 최신 알림으로 override 되어버립니다.flag에 여러 종류가 있는데 여기서는 스킵하도록 하겠습니다.2. 상태창에만 알림이 뜨고 head up Notification이 나오지 않는 문제Ios에서는 기본적으로 헤드업알림으로 뜨는데, Android는 아니더라구요결론부터 말씀드리자면, 알림 우선순위를 높게 설정해주면 해결되는 문제였습니다. (+ vibrate 설정해줘야 된다고 하더라구요..!)Channel과 Notification builder 두 군데의 우선순위를 변경해줘야 합니다.// channelval channel = NotificationChannel(\tcontext.getString(R.string.channel_name),\tcontext.getString(R.string.channel_name),\tNotificationManager.IMPORTANCE_HIGH // IMPORTANCE_HIGH로 세팅!!)// notification builderNotificationCompat.Builder(context, context.getString(R.string.channel_name))\t.setPriority(NotificationCompat.PRIORITY_HIGH) // PRIORITY_HIGH로 세팅!!\t.setDefaults(NotificationCompat.DEFAULT_SOUND or NotificationCompat.DEFAULT_VIBRATE)\t..." }, { "title": "[Ionic] DevOps Solution - AppFlow", "url": "/posts/ionic-appflow/", "categories": "Ionic", "tags": "Ionic, Appflow", "date": "2021-07-04 14:51:00 +0800", "snippet": "React Native에 Code Push가 있다면, Ionic에는 AppFlow가 있습니다!!만약 cordova를 사용중이라면 Code Push를 활용하면 되지만,capacitor라면 AppFlow를 활용하면 됩니다!AppFlow 유료 버전을 사용하면 Native 빌드와 배포까지 할 수 있지만, 이 글에서는 무료로 활용할 수 있는 유용한 Live Update에 대해서 설명하고자 합니다!Live Update란, 스토어에 배포하지 않고도 실시간으로 앱을 업데이트 시키는 것입니다.우선 방법을 순서대로 정리하면, https://ionic.io/appflow 계정 생성 앱 생성 Git, GitLab과 같은 저장소 연결 AppFlow관련 Plugin 설치 및 코드 작성 웹 빌드 및 배포 앱 빌드 버전 관리 참고사항우선, 1 ~ 3번은 간단하기도 하고, 하라는대로만 하면 문제 없이 하실 수 있을 것입니다!설명에 들어가기 앞서, Live Update는 Binary Compatible Changes만 가능합니다.여기서 Binary Compatible Changes란 무엇인가??간단히 말하자면, Native를 제외한 웹 앱 부분의 변경을 의미하며, 아래 부분의 변경을 뜻합니다. JavaScript / TypeScript logic SASS / CSS styling HTML layout Assets (Images, Icons, static JSON files, etc)즉, 어찌보면 당연하지만 Native 코드까지는 Live Update는 불가능하다는 것입니다.4. AppFlow관련 Plugin 설치 및 코드 작성Destinations &gt; Install Instructions를 클릭하면 Setup 명령어가 나와있습니다. (만약 없다면, 5번 웹 빌드부터 하시면 보일 것입니다..!)세가지 옵션이 있는데 그 중 원하는 것을 선택하시면 됩니다.그대로 입력하면 cordova-plugin-ionic 플러그인이 설치됩니다!update-method 옵션 동작 방식은 다음과 같습니다.[background]- 앱 실행시 Background에서 앱 동작과 상관없이 업데이트 된 코드를 다운로드 받습니다.- 앱 종료 후 다시 실행시 다운로드 된 버전으로 앱이 실행됩니다.- Appflow에서 권장하는 옵션입니다.[auto]- splashscreen 상태에서 업데이트 된 코드를 다운로드 받아서 적용시킵니다.- 때문에, 업데이트 사항이 많을 경우 초기 로딩시간이 많이 길어질 수 있습니다.[none] - 현재 프로젝트에 사용중- programmatically 커스터마이징 가능.- 위 두가지 옵션은 앱이 새로 켜질 때만 업데이트가 되는데, 해당 옵션은 원하는대로 시점을 커스터마이징 할 수 있습니다.- 현재 제가 개발중인 프로젝트에서는 앱을 background로 내렸다가 올렸을 때(pause - resume)에도 앱을 업데이트하도록 했습니다.// 새로 업데이트 된 내용 있는지 체크 const update = await Deploy.checkForUpdate(); if (update.available) { // We have an update! // download update await Deploy.downloadUpdate((progress) =&gt; { \t// download progress(percent) }); // 다운로드 내용 적용 await Deploy.extractUpdate((progress) =&gt; { }); // 다운로드 내용 적용 후, 앱 새로고침 (원하는 위치에서 가능) await Deploy.reloadApp(); }* background와 auto 옵션은 따로 코드 작성이 필요하지 않습니다.5. 웹 빌드 및 배포우선 Commits에 커밋 목록이 보이고, 빌드를 원하는 커밋 선택시 아래처럼 보이게 될 것입니다.여기서 Channel은 빌드 카테고리라고 보시면 될 것 같습니다.한 예로, 아래 코드를 통해 채널을 바꾸고 해당 채널의 최신 코드로 업데이트 할 수 있습니다.// set channelawait Deploy.configure({channel: 'Production'});// download, extract, reload...Live update 오른쪽의 toggle바를 enabled로 바꾸면 빌드가 끝남과 동시에 배포가 됩니다. 빌드만 해놓고 배포는 나중에 하고 싶다면 disabled로 하면 됩니다!6. 앱 빌드(로컬 빌드)반드시 아래 순서대로 빌드 해야 합니다.따로 package.json에 아래 빌드를 모아 두는 것을 추천드립니다.ionic build --prod // 웹 빌드ionic deploy manifest // pro-manifest.json 파일 생성npx cap sync // 앱 빌드위 순서대로 해야하는 이유를 설명드리기 전에 manifest파일에 대해 먼저 알아야 합니다.Appflow에서 빌드한 내용과 로컬에서 빌드한 내용를 비교할 수 있게 하는 것이 바로 manifest.json 파일입니다.manifest.json 파일이 있어야 기존 빌드 버전과 다른 부분만 파악해서 다운로드 할 수 있게 됩니다.만약 없다면, asset파일까지 죄다 매번 가져오기 때문에 시간이 엄청 오래걸립니다.. (저희 프로젝트에서는 3분 조금 넘게 걸렸네요..)그렇다면 위 순서대로 해야하는 이유는?!미리 manifest 생성 후, 단순히 ionic cap sync 한다면,ionic build시 www폴더에 manifest파일이 사라지게 되고,capacitor sync하면서 각 native 부분에도 manifest파일이 사라지게 됩니다.따라서 ionic build 후 manifest파일 생성해주고 마지막으로 sync 맞춰주는 방식으로 빌드해야 manifest파일이 남아있게 됩니다!!7. 버전 관리예시 상황을 먼저 한 번 보겠습니다.1.0.0 -&gt; 2.0.0 으로 앱 업데이트하면서, 강제 업데이트를 원합니다.이럴 경우 어떤 일이 발생할까요??!스토어에서 2.0.0 버전을 다운로드 받고서도 1.0.0 버전의 앱이 보이게 됩니다..! 왜 이렇게 되냐?!1.0.0 버전의 웹 빌드를 로컬에 가지고 있습니다. 그래서 앱 실행시 1.0.0 버전을 먼저 보여주고, 어? 최신 버전이 있네? 다운 받아야지!이런 상황이 펼쳐지게 됩니다..! 새로운 앱을 받고 나서도 그 앱의 빌드 내용을 무시하고 로컬 캐싱된 1.0.0 빌드를 가져오는 것입니다.이것 때문에 유료로 Appflow를 써야 해결되는 문제인지.. 딱히 정보도 잘 없는 것 같고 엄청 삽질을 했는데요..아래 사진처럼 Versioning으로 이 문제를 해결할 수 있습니다. 위 예시를 해결하자면, 1.0.0 버전의 웹 빌드의 max를 1.1.0으로 했다쳤을 때2.0.0 버전을 새로 받게 되면 어? 지금 로컬에 있는 버전은 max가 1.1.0이네? 무시해야지!그 결과 2.0.0 버전의 앱이 보이게 됩니다..!참고로 Equivalent는 앱이 해당 버전일 경우, Live Update를 안합니다.자세한 것(?)은 아래 캡처를 잘 보시면 될 것 같습니다..!8. 참고사항로컬 빌드 테스트시,웹에서 빌드한 버전이 로컬에 남아있어서아무리 새롭게 빌드한다고 해도 이전 버전의 앱이 보이게 됩니다.앱 버전을 올려놓고 테스트 하는 방법도 있겠지만,capacitor.config.json파일에 아래 코드를 추가해도 됩니다.\"cordova\": { \"preferences\": { \"DisableDeploy\": \"true\" }}하지만 주의해야할 점!!이를 까먹고 그대로 빌드하게 되면.. 라이브 업데이트가 불가능한 대참사가 발생하게되니배포시 반드시 지워줘야 합니다..!9. 한계점너무 비쌉니다..무료는 Live Updates가 10000건/mo$499/mo 정책의 경우 25000/mo 밖에 안됩니다.그런데 microsoft AppCenter의 codepush는 무료입니다..!Ż만약 native 배포까지 처리하려면 app flow를 사용해야겠지만아니라면 AppCenter를 활용하는 것이 좋아보입니다.다음에는 AppCenter를 통해 Ionic앱 codepush하는 방법에 대해 포스팅 하겠습니다.이상 Ionic의 Live Update에 대한 설명이었습니다!혹시 질문이나 부족한 부분이 있다면 댓글 부탁드립니다 :)참고)https://ionic.zendesk.com/hc/en-us/articles/360003567694-How-to-restrict-Live-Update-by-native-versionhttps://ionic.zendesk.com/hc/en-us/articles/360002243614-What-Are-Binary-Compatible-Changes-" }, { "title": "[Refactoring] Dealing with Inheritance(2)", "url": "/posts/js-operation-method/", "categories": "Javascript", "tags": "javascript", "date": "2021-06-29 00:37:00 +0800", "snippet": "[Javascript는 어떤 원리로 돌아가는 걸까?]싱글 스레드? 콜스택? 말은 많이 들어 봤지만, 막상 설명하자니 입이 안떨어졌습니다..자바스크립트는 웹 브라우저에 내장된 엔진으로 돌아가게 되는데, 엔진은 이와 같이 구성되어있습니다. Memory Heap - 변수, 함수 등의 메모리 할당이 일어나는 곳Call Stack - 호출 스택이 쌓이는 곳그리고 대표적인 자바스크립트 엔진은 구글 크롬에서 사용중인 V8!(8기통 엔진을 의미하는 명칭)[그렇다면 v8엔진에서는 무슨 일을 하는 걸까?] 자바스크립트 소스코드를 가져와 Parser에게 넘긴다. Parser는 파싱을 통해 AST(Abstract Syntax Tree)로 변환시킨다. AST를 인터프리터를 통해 byte code로 변환(Ignition)한다. bytecode를 실행함으로써 실제 작동하게 된다. 그 중 자주 사용되는 코드는 TruboFan으로 보내진다. TruboFan은 이 코드를 Optimized Machine Code로 컴파일해놓고 사용한다.ASTfunction hello (name){ return 'Hello,' + name; } --------------------------------- // 구조화 된 AST { type: 'FunctionDeclaration', name: 'hello', arguments: [{ type: 'Variable', name: 'name' }], ...}IgnitionIgnition은 자바스크립트 코드를 바이트 코드(ByteCode)로 변환하는 인터프리터이다. 원본 소스 코드보다 컴퓨터가 해석하기 쉬운 바이트 코드로 변환하여, 수시로 코드를 파싱(Parsing)하는 작업을 최소화하고 코드의 양도 줄임으로써 메모리 공간도 효율적으로 관리할 수 있게 된다.TurboFanTurboFan은 V8 v5.9 버전 이전에 사용되었던 Crankshaft 컴파일러를 완전히 대체한 최적화 담당 컴파일러이다. TurboFan은 바이트 코드로 수시로 변환하는 과정을 최소화하기 위해 사용된다.V8은 런타임 중에 Profiler라는 친구에게 함수나 변수들의 호출 빈도와 같은 데이터를 모으라고 시킨다. 이렇게 모인 데이터를 이용하여 TurboFan이 자기 기준에 맞는 코드를 가져와서 최적화를 시킨다.[엔진에서 언어 번역해서 실행시켜주는건 알겠는데, 어떻게 싱글스레드라면서 멀티스레드처럼 동작하는 거지?]web APIs 에서 비동기 요청들을 수행하고 callback에 대해서는 callback queue에 넣어준다.callback queue는 대기하다가 call stack이 비는 시점에 이벤트 루프를 돌려 해당 콜백 함수를 스택에 넣는다. 이벤트 루프의 기본 역할은 큐와 스택 두 부분을 지켜보고 있다가 스택이 비는 시점에 콜백을 실행시켜 주는 것이다.결과적으로 비동기 작업들은 따로 web API에서 처리를 해주기 때문에 멀티스레드 같이 느껴지는 것![웹은 브라우저가 있어서 그 안에서 엔진이 돌아간다지만, Nodejs는 어떻게 돌아가는 거지?] v8은 독립형으로 개발된 엔진. C++ 프로그램에 별도로 내장하여 실행시킬 수 있습니다![그러면, 웹은 Web APIs가 비동기 작업들을 처리해주는데, Nodejs는 비동기 작업을 어떻게 처리하지?] libUv가 비동기 처리를 담당하는 라이브러리. 비동기 작업에 대해서는 시스템 api(ex. os에서 제공)를 활용하고, 동기작업에 대해서는 스레드 풀을 활용. Thread Pool은 **작업 처리에 사용되는 스레드를 제한된 개수만큼 정해 놓고 작업 큐(Queue)에 들어오는 작업들을 하나씩 스레드가 맡아 처리하는 것**을 말한다. 기본은 4개인데, 직접 설정할 수 있다.[스레드 풀을 통해서 멀티스레드 작업을 하는 것 아닌가? 그런데 왜 싱글 스레드라고 하는 거지?] event loop는 한개의 thread에서만 돌아가기 때문에 싱글스레드처럼 동작하지만, 내부적으로 멀티 쓰레드를 활용할 수 있다.[스레드 개수를 정할 수 있다면, 많이 할수록 성능이 좋은 거 아닌가?] 스레드가 너무 많으면 프로그램의 성능이 심각하게 떨어진다. 첫째, 정해진 분량의 일을 여러 스레드에 분배하면 스레드 하나하나는 할 일이 별로 없게 된다. 그래서 스레드를 시작하고 종료하는 비용이 실제로 하는 일의 양을 압도하게 된다.둘째, 소프트웨어 스레드가 너무 많으면 한정된 하드웨어 자원을 공유하는데 드는 비용이 커진다.참고)https://velog.io/@namezin/javascript-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AChttps://darrengwon.tistory.com/953https://helloinyong.tistory.com/290https://m.blog.naver.com/pjt3591oo/221976414901https://heowc.dev/2018/02/08/thread-pool/" }, { "title": "[Refactoring] Dealing with Inheritance(2)", "url": "/posts/js-refactoring-12/", "categories": "Javascript", "tags": "javascript, refactoring", "date": "2021-06-15 07:42:00 +0800", "snippet": "마틴파울러의 Refactoring 2판 12과의 내용 정리(2)입니다.Extract Superclass(슈퍼클래스 추출하기)- 메서드 올리기 리팩터링과 유사.- 공통 부분을 superclass로 분리하기!// fromclass Department { get totalAnnualCost() {...} get name() {...} get headCount() {...}}class Employee { get annualCost() {...} get name() {...} get id() {...}}-----------------------------// toclass Party { get name() {...} get annualCost() {...}}class Department extends Party { get headCount() {...}}class Employee Party { get id() {...}}Collapse Hierarchy(계층 합치기)- 어떤 클래스와 그 부모가 너무 비슷해져서 더는 독립적으로 존재해야 할 이유가 사라지는 경우에 둘을 하나로 합치기!// fromclass Employee {...}class Salesperson extends Employee {...}--------------------------------------// toclass Employee {...}Replace Subclass with Delegate(서브클래스를 위임으로 바꾸기)- 상속의 단점은 한 번만 쓸 수 있는 카드라는 것이다. 무언가가 달라져야 하는 이유가 여러 개여도 상속에서는 그중 단 하나의 이유만 선택해 기준으로 삼 을 수밖에 없다. ex) 사람 객체의 동작을 ‘나이대’와 ‘소득 수준’에 따라 달리 하고 싶다면 서브클래스는 젊은이와 어르신이 되거나, 혹은 부자와 서민이 되어야 한다. 둘다는 안된다.- 또 다른 단점은 상속은 클래스들의 관계를 아주 긴밀하게 결합한다. 부모를 수정하면 자식들의 기능을 해치기가 쉽기에 조심해야 한다. 그래서 자식들이 슈퍼클래스를 어떻게 상속해 쓰는지를 이해해야 한다.- 위임은 위 두 문제를 모두 해결해준다. 다양한 클래스에 서로 다른 이유로 위임할 수 있다.- 디자인패턴 - State Pattern이나 Strategy Pattern과 유사하다.// fromclass Order { get daysToShip() { return this._warehouse.daysToShip; }}class PriorityOrder extends Order { get daysToShip() { return this._priorityPlan.daysToShip; }}---------------------------------------// toclass Order { get daysToShip() { return (this._priorityDelegate) ? this._priorityDelegate.daysToShip : this._warehouse.daysToShip; }}class PriorityOrderDelegate { get daysToShip() { return this._priorityPlan.daysToShip; }}Replace Superclass with Delegate(슈퍼클래스를 위임으로 바꾸기)- Java의 Stack class가 List를 상속하고 있는데, Stack에 필요하지 않은 연산들이 List를 상속함으로써 그대로 노출되는 문제가 있다.- 위 경우에 Stack에서 List객체를 필드에 저장해두고 필요한 기능만 위임했다면 더 멋졌을 것이다!// fromclass List {...}class Stack extends List {...}-----------------------------// toclass Stack { constructor() { this._storage = new List(); }}class List {...}" }, { "title": "[Refactoring] Dealing with Inheritance(1)", "url": "/posts/js-refactoring-11/", "categories": "Javascript", "tags": "javascript, refactoring", "date": "2021-06-15 07:40:00 +0800", "snippet": "마틴파울러의 Refactoring 2판 12과의 내용 정리(1)입니다.Pull Up Method(메서드 올리기) &lt;-&gt; Push Down Method- child class에서 중복된 함수를 사용한다면, 올리기.- 만약 전체적인 흐름은 같지만 세부적인 내용이 다르다면 Form Template Method를 고려해보자.- Form Template Method는 함수를 올리고 세부 내용만 따로 abstract function으로 빼내는 방법!// fromclass Employee {...}class Salesperson extends Employee { get name() {...}}class Engineer extends Employee { get name() {...}}----------------------------------// toclass Employee { get name() {...}}class Salesperson extends Employee {...}class Engineer extends Employee {...}Pull Up Field(필드 올리기) &lt;-&gt; Push Down Field- 데이터 중복 선언 없앨 수 있다.- 해당 필드를 사용하는 동작을 서브클래스에서 슈퍼클래스로 옮길 수 있다.// fromclass Employee {...} // typescript codeclass Salesperson extends Employee { private name;}class Engineer extends Employee { private name;}----------------------------------// toclass Employee { protected name;}class Salesperson extends Employee {...}class Engineer extends Employee {...}Pull Up Constructor Body(생성자 본문 올리기)- 중복 제거. Similar with Pull Up Method// fromclass Party {...}class Employee extends Party { constructor(name, id, monthlyCost) { super(); this._id = id; this._name = name; this._monthlyCost = monthlyCost; }}-----------------------------------// toclass Party { constructor(name) { this._name = name; }}class Employee extends Party { constructor(name, id, monthlyCost) { super(name); this._id = id; this._monthlyCost = monthlyCost; }}Push Down Method(메서드 내리기) &lt;-&gt; Pull Up Method- 특정 서브클래스 하나(혹은 소수)와만 관련된 메서드는 슈퍼클래스에서 제거하고 해당 서브클래스(들)에 추가하는 편이 깔끔하다.// fromclass Employee { get name() {...}}class Salesperson extends Employee {...}class Engineer extends Employee {...}----------------------------------// toclass Employee {...}class Salesperson extends Employee {...}class Engineer extends Employee { get name() {...}}Push Down Field(필드 내리기) &lt;-&gt; Pull Up Field- 서브 클래스 하나(혹은 소수)에서만 사용하는 필드는 해당 서브클래스(들)로 옮긴다.// fromclass Employee { // typescript code protected name;}class Salesperson extends Employee {...}class Engineer extends Employee {...}----------------------------------// toclass Employee {...}class Salesperson extends Employee {...}class Engineer extends Employee { private name;}Replace Type Code with Subclasses(타입 코드를 서브클래스로 바꾸기) &lt;-&gt; Remove Subclass- 타입 코드에 따라 동작이 달라져야 하는 함수가 여러 개일 때 특히 유용하다.- Replace Conditional with Polymorphism 참고// fromfunction createEmployee(name, type) { return new Employee(name, type); }-------------------------// tofunction createEmployee(name, type) { switch (type) { case 'engineer': return new Engineer(name); case 'salesperson': return new Salesperson(name); case 'manager': return new Manager(name); }}Remove Subclass(서브클래스 제거하기) &lt;-&gt; Replace Type Code with Subclasses- 더이상 서브클래스의 역할을 제대로 하지 못한다면 과감하게 없애고 슈퍼클래스의 필드로 대체하기// fromclass Person { get genderCode() {return 'X';} }class Male extends Person { get genderCode() {return 'M';} }class Female extends Person { get genderCode() {return 'F';} }-------------------------------// toclass Person { get genderCode() { return this._genderCode; }}" }, { "title": "[Refactoring] Refactoring APIs(2)", "url": "/posts/js-refactoring-10/", "categories": "Javascript", "tags": "javascript, refactoring", "date": "2021-06-14 08:49:00 +0800", "snippet": "마틴파울러의 Refactoring 2판 11과의 내용 정리(2)입니다.Remove Setting Method(세터 제거하기)-무조건 접근자 메스드를 통해서만 필드를 다루려 할 때(심지어 생성자 안에서도) 세터를 제거해서 값이 바뀌면 안 된다는 뜻을 분명히-생성 스크립트(creation script)를 사용해 객체를 생성할 때 설계자는 스크립트가 완료된 뒤로는 그 객체의 필드 일부(혹은 전체)는 변경되지 않으리라 기대한다. 이때 세터를 제거하여 의도를 명확히// fromclass Person { get name() {...} set name(aString) {...}}-----------------------// toclass Person { get name() {...}}Replace Constructor with Factory Function(생성자를 팩터리 함수로 바꾸기)-생성자를 팩터리 함수로 바꾸면, 이름을 바꾸거나 여러 추가적인 로직을 처리하는데 제약이 없다.// fromleadEngineer = new Employee(document.leadEngineer, 'E');// toleadEngineer = createEngineer(document.leadEngineer);Replace Function with Command(함수를 명령으로 바꾸기)-함수를 그 함수만을 위한 객체 안으로 캡슐화하면 더 유용해지는 상황이 있다.-보조 연산을 제공할 수 있으며, 수명주기를 더 정밀하게 제어하는 데 필요한 매게변수를 만들어주는 메서드도 제공할 수 있다.-하지만, 유연성은 복잡성을 키우고 얻는 대가임을 잊지 말아야 함..!! 저자가 명령을 선택할 때는 명령보다 더 간단한 방식으로는 얻을 수 없는 기능이 필요할 때 뿐이다.// fromfunction score(candidate, medicalExam, scoringGuide) { let result = 0; let healthLevel = 0; // skip code}-----------------------------------------------------// toclass Scorer { constructor(candidate, medicalExam, scoringGuide) { this._candidate = candidate; this._medicalExam = medicalExam; this._scoringGuide = scoringGuide; } execute() { this._result = 0; this._healthLevel = 0; // skip code }}Replace Command with Function(명령을 함수로 바꾸기)-로직이 크게 복잡하지 않다면 명령 객체는 장점보다 단점이 크니 평범한 함수로 바꿔주는 게 낫다.// fromclass ChargeCalculator { constructor(customer, usage) { this._customer = customer; this._usage = usage; } execute() { return this._customer.rate * this._usage; }}---------------------------------------------// tofunction charge(customer, usage) { return customer.rate * usage; }Return Modified Value(수정된 값 반환하기)-데이터가 어떻게 수정되는지를 추적하는 일은 코드에서 이해하기 가장 어려운 부분 중 하나다.-그래서 데이터가 수정된다면 그 사실을 명확히 알려주어서, 어느 함수가 무슨 일을 하는지 쉽게 알 수 있게 하는 일이 대단히 중요하다.-이 리팩터링은 값 하나를 계산한다는 분명한 목적이 있는 함수들에 가장 효과적이고, 반대로 값 여러 개를 갱신하는 함수에는 효과적이지 않다.// fromlet totalAscent = 0;calculateascent();function calculateAscent() { for (let i = 1; i&lt; points.length; i++) { const verticalChange = points[i].elevation - points[i-1].elevation; totalAscent += (verticalChange &gt; 0) ? verticalChange : 0; }}------------------------------------------------------------------// tolet totalAscent = calculateascent();function calculateAscent() { let result = 0; for (let i = 1; i&lt; points.length; i++) { const verticalChange = points[i].elevation - points[i-1].elevation; result += (verticalChange &gt; 0) ? verticalChange : 0; } return result;}Replace Error Code with Exception(오류 코드를 예외로 바꾸기)-예외를 사용하면 오류 코드를 일일이 검사하거나 오류를 식별해 콜스택 위로 던지는 일을 신경 쓰지 않아도 된다.// fromif (data) return new ShippingRules(data);else return -23;--------------------------// toif (data) return new ShippingRules(data);else throw new OrderProcessingError(-23);Replace Exception with Precheck(예외를 사전확인으로 바꾸기)-예외가 과용되면 안되고 말 그대로 예외적으로 동작할 때만 쓰여야 한다.-함수 수행 시 문제가 될 수 있는 조건을 함수 호출 전에 검사할 수 있다면, 예외를 던지는 대신 호출하는 곳에서 조건을 검사하도록 해야 한다.// fromdouble getValueForPeriod (int periodNumber) { try { return values[periodNumber]; } catch (ArrayIndexOutOfBoundsException e) { return 0; }}------------------------------------------// todouble getValueForPeriod (int periodNumber) { return (periodNumber &gt;= values.length) ? 0 : values[periodNumber];}" }, { "title": "[Refactoring] Refactoring APIs(1)", "url": "/posts/js-refactoring-9/", "categories": "Javascript", "tags": "javascript, refactoring", "date": "2021-06-04 05:59:00 +0800", "snippet": "마틴파울러의 Refactoring 2판 11과의 내용 정리(1)입니다.Separate Query from Modifier(질의 함수와 변경 함수 분리하기)-겉보기 부수효과(observable side effect)가 전혀 없이 값을 반환해주는 함수를 추구해야 한다.-이런 함수는 호출 문장의 위치를 호출하는 함수 안 어디로든 옮겨도 되며 테스트하기도 쉽다. (신경 쓸 거리가 매우 적다)-값을 반환하면서 부수효과도 있는 함수를 발견하면 무조건 분리를 시도하자!// fromfunction getTotalOutstandingAndSendBill() { const result = customer.invoices.reduce((total, each) =&gt; each.amount + total, 0); sendBill(); return result;}---------------------------------------------// tofunction totalOutstanding() { return customer.invoices.reduce((total, each) =&gt; each.amount + total, 0); }function sendBill() { emailGateway.send(formatBill(customer));}Parameterize Function(함수 매개변수화하기)-둘 이상의 함수의 로직이 아주 비슷하고 단지 리터럴 값만 다르다면, 그 다른 값만 매개변수로 받아 처리하는 함수 하나로 합쳐서 중복을 없앨 수 있다.// fromfunction tenPercentRaise(aPerson) { aPerson.salary = aPerson.salary.multiply(1.1); }function fivePercentRaise(aPerson) { aPerson.salary = aPerson.salary.multiply(1.05); }--------------------------------------------// tofunction raise(aPerson, factor) { aPerson.salary = aPerson.salary.multiply(1 + factor); }Remove Flag Argument(플래그 인수 제거하기)-플래그 인수를 사용하면, 호출할 수 이쓴 함수들이 무엇이고 어떻게 호출해야 하는지를 이해하기가 어려워진다.-함수들의 기능 차이가 잘 드러나지 않는다.-사용할 함수를 선택한 후에도 플래그 인수로 어떤 값을 넘겨야 하는지를 또 알아내야 한다.-Boolean 플래그 코드는 읽는 이에게 뜻을 온전히 전달하지 못하기 때문에 더욱 좋지 못하다. 전달한 true의 의미가 대체 뭐람?!// fromfunction setDimension(name, value) { if (name === 'height') { this._height = value; return; } if (name === 'width' { this._width = value; return; }}-----------------------------------// tofunction setHeight(value) {this._height = value;}function setWidth(value) {this._width = value;}Preserve Whole Object(객체 통째로 넘기기)-통째로 넘기면 변화에 대응하기 쉽다. 만약 그 함수가 더 다양한 데이터를 사용하도록 바뀌어도 매개변수 목록은 수정할 필요가 없다.-매개변수 목록이 짧아져서 일반적으로는 함수 사용법을 이해하기 쉬워진다.-레코드에 담긴 데이터 중 일부를 받는 함수가 여러 개라면 그 함수들끼리는 같은 데이터를 사용하는 부분들이 있을 것이고, 그 부분의 로직이 중복될 가능성이 크다.-객체로부터 값 몇 개를 얻은 후 그 값들로만 무언가를 하는 로직이 있다면 그 로직을 객체 안으로 집어넣으면 된다.-한 객체가 제공하는 기능 중 항상 똑같은 일부만을 사용하는 코드가 많다면, 그 기능만 따로 묶어서 클래스로 추출할 수 있다.// fromconst low = aRoom.daysTempRange.low;const high = aRoom.daysTempRange.high;if (aPlan.widthinRange(low, high))------------------------------// toif (aPlan.widthinRange(aRoom.daysTempRange))Replace Parameter with Query(매개변수를 질의 함수로 바꾸기) &lt;-&gt; Replace Query with Parameter-피호출 함수가 스스로 ‘쉽게’ 결정할 수 있는 값을 매개변수로 건네는 것도 일종의 중복이다.-하지만 매개변수 제거시, 피호출 함수에 원치 않는 의존성이 생긴다면 이 리팩터링을 하면 안된다.// fromavailableVacation(anEmployee, anEmployee.grade);function availableVacation(anEmployee, grade) { // 연휴 계산...----------------------------------------// toavailableVacation(anEmployee);function availableVacation(anEmployee) { const grade = anEmployee.grade; // 연휴 계산...Replace Query with Parameter(질의 함수를 매개변수로 바꾸기) &lt;-&gt; Replace Parameter with Query-함수 안에서 전역 변수를 참조한다거나 제거하길 원하는 원소를 참조하는 경우 해당 참조를 매개변수로 바꿔 해결할 수 있다.(책임을 호출자로 옮기는 것)-프로그램의 일부를 순수 함수로 바꿀 수 있으며, 결과적으로 그 부분은 테스트하거나 다루기가 쉬워진다.-하지만 매개변수로 어떤 값을 제공할지를 호출자가 알아내야 한다. 결국 책임소재를 호출자에게 두느냐 함수에 두느냐의 문제로 귀결된다. 정답은 없으며, 프로젝트를 진행하면서 균형점이 이리저리 옮겨질 수 있으니 반대 리팩터링과는 친해져야 한다.// from targetTemperature(aPlan)function targetTemperature(aPlan) { currentTemperature = thermostat.currentTemperature; // 생략-----------------------------------------// totargetTemperature(aPlan, thermostat.currentTemperature)function targetTemperature(aPlan, currentTemperature) { // 생략" }, { "title": "[Refactoring] Simplifying Conditional Logic", "url": "/posts/js-refactoring-8/", "categories": "Javascript", "tags": "javascript, refactoring", "date": "2021-05-27 05:26:00 +0800", "snippet": "마틴파울러의 Refactoring 2판 10과의 내용 정리입니다.Decompose Conditional(조건문 분해하기)-복잡한 조건부 로직은 프로그램을 복잡하게 만드는 가장 흔한 원흉에 속한다.-무슨 일이 일어나는지는 이야기해주지만 ‘왜’ 일어나는지는 제대로 말해주지 않을 때가 많은 것이 문제이다.// fromif (!aDate.isBefore(plan.summerStart) &amp;&amp; !aDate.isAfter(plan.summerEnd)) charge = quantity * plan.summerRate;else charge = quantity * plan.regularRate + plan.regularServiceCharge;--------------------------------------------------------------------// tocharge = summer() ? summerCharge() : regularCharge();Consolidate Conditional Expression(조건식 통합하기)-비교하는 조건은 다르지만 그 결과로 수행하는 동작은 똑같은 코드들은 하나로 통합하는게 낫다.-나뉜 조건들을 하나로 통합함으로써 내가 하려는 일이 더 명확해진다. 나눠서 수행해도 결과는 같지만, 읽은 사람은 독립된 검사들이 우연히 함께 나열된 것으로 오해할 수 있다.-하지만, 하나의 검사라고 생각할 수 없는, 진짜로 독립된 검사들이라고 판단되면 이 리팩터링을 해서는 안 된다// fromif (anEmployee.seniority &lt; 2) return 0;if (anEmployee.monthsDisabled &lt; 12) return 0;if (anEmployee.isPartTime) return 0;---------------------------------------// toif (isNotEligibleForDisability()) return 0;function isNotEligibleForDisability() { return ((anEmployee.seniority &lt; 2) || (anEmployee.monthsDisabled &lt; 12) || (anEmployee.isPartTime)}Replace Nested Conditional with Guard Clauses(중첩 조건문을 보호 구문으로 바꾸기)-이 리팩터링의 핵심은 의도를 부각하는 데 있다.-보호 구문은 ‘이건 이 함수의 핵심이 아니다. 이 일이 일어나면 무언가 조치를 취한 후 함수에서 빠져나온다’라고 이야기 한다.// fromfunction getPayAmount() { let result; if (isDead) result = deadAmount(); else { if (isSeparated) result = separatedAmount(); else { if (isRetired) result = retiredAmount(); else result = normalPayAmount(); } } return result;}------------------------------// tofunction getPayAmount() { if (isDead) return deadAmount(); if (isSeparated) return separatedAmount(); if (isRetired) return retiredAmount(); return normalPayAmount();}Replace Conditional with Polymorphism(조건부 로직을 다형성으로 바꾸기)-타입을 기준으로 분기하는 switch문이 포함된 함수가 여러 개 보인다면, case별로 클래스를 하나씩 만들어 공통 switch 로직의 중복을 없앨 수 있다. 다형성을 활용하여 어떻게 동작할지를 각 타입이 알아서 처리하도록 하면 된다.// fromswitch (bird.type) { case '유럽 제비': return '보통이다'; case '아프리카 제비': return (bird.numberOfCoconuts &gt; 2) ? '지쳤다' : '보통이다'; case '노르웨이 파랑 앵무': return (bird.voltage &gt; 100) ? '그을렸다' : '예쁘다'; default: return '알 수 없다';}...switch (bird.type) { case '유럽 제비': return ...; case '아프리카 제비': return ...; case '노르웨이 파랑 앵무': return ...; default: return ...;}------------------------------------------------------// toswitch (bird.type) { case '유럽 제비': return new EuropeanSwallow(bird); case '아프리카 제비': return new AfricanSwallow(bird); case '노르웨이 파랑 앵무': return new NorwegianBlueSwallow(bird); default: return new Bird(bird);}class EuropeanSwallow extends Bird { get Plumage() { return '보통이다'; } ...}class AfricanSwallow extends Bird { get Plumage() { return (bird.numberOfCoconuts &gt; 2) ? '지쳤다' : '보통이다'; } ...}class NorwegianBlueSwallow extends Bird { get Plumage() { return (bird.voltage &gt; 100) ? '그을렸다' : '예쁘다'; } ...}Introduce Special Case(특이 케이스 추가하기)-데이터 구조의 특정 값을 확인한 후 똑같은 동작을 수행하는 코드가 곳곳에 등장하는 경우, 코드 중복이 발생한다. 특정 값에 대해 똑같이 반응하는 코드가 여러 곳이라면 그 반응들을 한 데로 모으는 게 효율적이다.// fromif (aCustomer === '미확인 고객') customerName = '거주자';----------------------------------------------------// toclass UnknownCustomer { get name() { return '거주자'; }}...get customer() { return (this._customer === '미확인 고객') ? new UnknownCustomer() : this._customer; }...const customerName = aCustomer.name;Introduce Assertion(어서션 추가하기)-특정 조건이 참일 때만 제대로 동작하는 코드 영역이 있을 수 있다. 이런 가정이 코드에 항상 명시적으로 기술되어 있지는 않아서 알고리즘을 보고 연역해서 알아내야 할 때도 있다. 이럴 때 어서션 이용해서 코드 자체에 삽입해놓는 것이다.-어서션은 항상 참이라고 가정하는 조건부 문장으로, 어서션이 실패했다는 건 프로그래머가 잘못했다는 뜻이다.// fromif (this.discountRate) base = base - (this.discountRate * base);-------------------------------------------// toassert(this.discountRate &gt;= 0;if (this.discountRate) base = base - (this.discountRate * base);Replace Control Flag with Break(제어 플래그를 탈출문으로 바꾸기)// fromfor (const p of peaople) { if (!found) { if (p === '조커') { sendAlert(); fount = true; } }}----------------------------------------// tofor (const p of peaople) { if (p === '조커') { sendAlert(); break; }}" }, { "title": "[Refactoring] Organizing Data", "url": "/posts/js-refactoring-7/", "categories": "Javascript", "tags": "javascript, refactoring", "date": "2021-05-25 05:16:00 +0800", "snippet": "마틴파울러의 Refactoring 2판 9과의 내용 정리입니다.Split Variable(변수 쪼개기)-역할이 둘 이상인 변수가 있다면 쪼개야만 한다. 코드를 읽는 이에게 커다란 혼란 초래..!// fromlet temp = 2 * (height + width);console.log(temp);temp = height * width;console.log(temp);---------------------------------// toconst perimeter = 2 * (height + width);console.log(perimeter);const area = height * width;console.log(area);-함수의 매개변수의 경우!// fromfunction discount(inputValue, quantity) { if (inputValue &gt; 50) inputValue = inputValue - 2; if (quantity &gt; 100) inputValue = inputValue - 1; return inputValue;}---------------------------------------------// tofunction discount(inputValue, quantity) { let result = inputValue; if (inputValue &gt; 50) result = result - 2; if (quantity &gt; 100) result = result - 1; return result;}Rename Field(필드 이름 바꾸기)-이름은 매우 중요..!get name() { ... } -&gt; get title() { ... }Replace Derived Variable with Query(파생 변수를 질의 함수로 바꾸기)-가변 데이터는 서로 다른 두 코드를 이상한 방식으로 결합하기도 하는데, 한 쪽 코드에서 수정한 값이 연쇄 효과를 일으켜 다른 쪽 코드에 원인을 찾기 어려운 문제를 야기하기도 한다.-가변 데이터를 완전히 배제하기란 현실적으로 불가능할 때가 많지만, 가변 데이터의 유효 범위를 가능한 한 좁혀야 한다.// fromget production() { return this._production; }applyAdjustment(anAudjustment) { this._adjustments.push(anAdujustment); this._production += anAdjustment.amount; // 이 누적 값은 함수에 직접 관련도 없고, 매번 갱신하지 않고도 계산할 수 있다.}---------------------------------------------get production() { // 누적 계산을 분리 return this._adjustments .reduce((sum, a) =&gt; sum + a.amount, 0);}applyAdjustment(anAudjustment) { this._adjustments.push(anAdujustment);}Change Reference to Value(참조를 값으로 바꾸기)-값으로 바꾸면 불변이기에 자유롭게 활용하기 좋다. 서로간의 참조를 관리하지 않아도 된다.-물론, 값을 공유해야 한다면 이 리팩터링은 적용하면 안된다.// fromclass Product { applyDiscount(arg) { this._price.amount -= arg; }}----------------------------------------------------// toclass Product { applyDiscount(arg) { this._price = new Money(this._price.amount - arg, this._price.money); }}Change Value To Reference(값을 참조로 바꾸기)-참조를 값으로 바꾸기의 반대 리팩터링-하나의 데이터 구조 안에 논리적으로 똑같은 제 3의 데이터 구조를 참조하는 레코드가 여러 개 있을 수 있다. 이 때, 참조로 다루면 좋을 수 있다.// fromlet customer = new Customer(customerData);// tolet customer = customerRepository.get(customerData.id);Replace magic Literal(매직 리터럴 바꾸기)-매직 리터럴이란 소스코드에 등장하는 일반적인 리터럴 값을 말한다.// fromfunction potentialEnergy(mass, height) { return mass * 9.81 * height;}---------------------------------------// toconst STANDARD_GRAVITY = 9.81;function potentialEnergy(mass, height) { return mass * STANDARD_GRAVITY * height;}" }, { "title": "[Refactoring] Moving Features(2)", "url": "/posts/js-refactoring-6/", "categories": "Javascript", "tags": "javascript, refactoring", "date": "2021-05-24 05:10:00 +0800", "snippet": "마틴파울러의 Refactoring 2판 8과의 내용 정리(2)입니다.Replace Inline Code with Function Call(인라인 코드를 함수 호출로 바꾸기)-함수는 여러 동작을 하나로 묶어준다.-함수의 이름이 코드의 동작 방식보다는 목적을 말해주기 때문에 코드를 이해하기 쉬워진다.-함수는 중복을 없애는 데도 효과적이다. 그리고 동작을 변경할 때도 한 곳만 수정하면 된다.// fromlet appliesToMass = false;for (const s of states) { if (s === 'MA') appliesToMass = true;}------------------------------------// to let appliesToMass = states.includes('MA');Slide Statements(문장 슬라이드하기)-관련된 코드들을 가까이 뭉쳐놓기// fromconst pricingPlan = retrievePricingPlan();const order = retreiveOrder();let charge;const chargePerUnit = pricingPlan.unit;-------------------------------------// toconst pricingPlan = retrievePricingPlan();const chargePerUnit = pricingPlan.unit;const order = retreiveOrder();let charge;Split Loop(반복문 쪼개기)-반복문 하나에서 두 가지 일을 수행하는 경우, 두 가지 일 모두를 잘 이해하고 진행해야 하는 단점이 있다.-반복문을 두 번 실행해야 하는게 병목이라 밝혀지면 그때 다시 합치면 된다. 하지만, 대부분 성능에 저하는 없다.// fromlet averageAge = 0;let totalSalary = 0;for (const p of people) { averageAge += p.age; totalSalary += p.salary;}averageAge = averageAge / people.length;---------------------------------------// tolet totalSalary = 0;for (const p of people) { totalSalary += p.salary;}let averageAge = 0;for (const p of people) { averageAge += p.age;}averageAge = averageAge / people.length;Replace Loop with Pipeline(반복문을 파이프라인으로 바꾸기-컬렉션 파이프라인을 이용하면 처리 과정을 일련의 연산으로 표현할 수 있다.-대표적으로 map, filter를 활용할 수 있다.-논리를 파이프라인으로 표현하면 이해하기 훨씬 쉬워진다. 객체가 파이프라인을 따라 흐르며 어떻게 처리되었는지 읽을 수 있기 때문!// fromconst names = [];for (const i of input) { if (i.job === 'programmer') names.push(i.name);}----------------------------// toconst names = input .filter(i =&gt; i.job === 'programmer') .map(i =&gt; i.name);Remove Dead Code(죽은 코드 제거하기)-사용되지 않는 코드가 있다면 소프트웨어의 동작을 이애하는 데 커다란 걸림돌이 될 수도 있다.// fromif (false) { doSomethingThaeUsedToMatter(); }---------------------------// to" }, { "title": "[Refactoring] Moving Features(1)", "url": "/posts/js-refactoring-5/", "categories": "Javascript", "tags": "javascript, refactoring", "date": "2021-05-21 05:08:00 +0800", "snippet": "마틴파울러의 Refactoring 2판 8과의 내용 정리(1)입니다.Move Function(함수 옮기기)-어떤 함수가 자신이 속한 모듈 A의 요소들보다 다른 모듈 B의 요소들을 더 많이 참조한다면 B로 옮겨야 한다. (캡슐화up, 의존성down)-함수를 옮길지 말지를 정하기는 쉽지 않지만, 선택이 어려울수록 큰 문제가 아닌 경우가 많다.-중첩 함수를 사용하다보면 숨겨진 데이터끼리 상호 의존하기가 아주 쉬우니 중첩함수는 되도록 만들지 말자.// fromfunction trackSummary(points) { const totalTime = calculateTime(); const totalDistance = calculateDistance(); const pace = totalTime / 60 / totalDistance; return { time: totalTime, distance: totalDistance, pace: pace } function calculateDistance() { // 총 거리 계산 let result = 0; for (const i = 1; i &lt; points.length; i++) { result += distance(points[i-1], points[i]); } return result; } function distance(p1, p2) { ... } // 두 지점의 거리 계산 function radians(degrees) { ... } // 라디안 값으로 변환 function calculateTime() { ... } // 총 시간 계산}------------------------------------------------------// tofunction trackSummary(points) { ... }function totalDistance() { ... }function distance(p1, p2) { ... }function radians(degrees) { ... }function calculateTime() { ... }Move Field(필드 옮기기)-데이터 구조가 중요. 데이터 구조를 잘못 선택하면 아귀가 맞지 않는 데이터를 다루기 위한 코드로 범벅이 된다.-이를 곧바로 수정하지 않으면 훗날 작성하게 될 코드를 더욱 복잡하게 만든다..// fromclass Customer { get plan() {return this._plan;} get discountRate() {return this._discountRate;}}------------------------------------------------------// toclass Customer { get plan() {return this._plan;} get discountRate() {return this.plan._discountRate;}}Move Statements into Function(문장을 함수로 옮기기)-중복 제거. 추후 반복되는 부분에서 무언가 수정할 일이 생겼을 때 단 한 곳만 수정하면 된다.// fromfunction renderPerson(outStream, person) { const result = []; ... result.push(`&lt;p&gt;제목: ${person.photo.title}&lt;/p&gt;`); // 제목 출력(중복코드) result.push(emitPhotoData(person.photo); ...}function photoDiv(p) { return [ '&lt;div&gt;', `&lt;p&gt;제목: ${p.title}&lt;/p&gt;`, // 제목 출력(중복 코드) emitPhotoData(p), '&lt;/div&gt;' ].join('/n');}function emitPhotoData(aPhoto) { const result = []; result.push(`&lt;p&gt;위치: ${aPhoto.location}&lt;/p&gt;`); result.push(`&lt;p&gt;날짜: ${aPhoto.date.toDateString()}&lt;/p&gt;`); ... return result.join('/n');}------------------------------------------------// tofunction renderPerson(outStream, person) { const result = []; ... result.push(emitPhotoData(person.photo); ...}function photoDiv(p) { return [ '&lt;div&gt;', emitPhotoData(p), '&lt;/div&gt;' ].join('/n');}function emitPhotoData(aPhoto) { const result = []; result.push(`&lt;p&gt;제목: ${aPhoto.title}&lt;/p&gt;`); result.push(`&lt;p&gt;위치: ${aPhoto.location}&lt;/p&gt;`); result.push(`&lt;p&gt;날짜: ${aPhoto.date.toDateString()}&lt;/p&gt;`); ... return result.join('/n');}Move Statements to Caller(문장을 호출한 곳으로 옮기기)-위 문장을 함수로 옮기기의 반대 리팩터링-초기에는 응집도 높고 한 가지 일만 수행하던 함수가 어느새 둘 이상의 다른 일을 수행하게 바뀔 수 있고, 이럴 때 활용.-예컨데 여러 곳에서 사용하던 기능이 일부 호출자에게는 다르게 동작하도록 바뀌어야 한다면, 달라진 동작을 함수에서 꺼내 해당 호출자로 옮겨야 한다.// from emitPhotoData(outStream, person.photo);function emitPhotoData(outStream, photo) { outStream.write(`&lt;p&gt;제목: ${aPhoto.title}&lt;/p&gt;`); outStream.write(`&lt;p&gt;위치: ${aPhoto.location}&lt;/p&gt;`);}-------------------------------------------------// toemitPhotoData(outStream, person.photo);outStream.write(`&lt;p&gt;위치: ${aPhoto.location}&lt;/p&gt;`);function emitPhotoData(outStream, photo) { outStream.write(`&lt;p&gt;제목: ${aPhoto.title}&lt;/p&gt;`);}" }, { "title": "[Refactoring] Encapsulation(2)", "url": "/posts/js-refactoring-4/", "categories": "Javascript", "tags": "javascript, refactoring", "date": "2021-05-18 04:08:00 +0800", "snippet": "마틴파울러의 Refactoring 2판 7과의 내용 정리(2)입니다.Extract Class(클래스 추출하기)-메서드와 데이터가 너무 많은 클래스는 이해하기가 쉽지 않으니 잘 살펴보고 적절히 분리하는 것이 좋다.-특히 일부 데이터와 메서드를 따로 묶을 수 있다면 어서 분리하라는 신호!-함께 변경되는 일이 많거나 서로 의존하는 데이터들도 분리!// fromclass Person { ... get officeAreaCode() {return this._officeAreaCode;} get officeNumber() {return this._officeNumber;}}------------------------------------------------------// toclass Person { ... get officeAreaCode() {return this._telephoneNumber.areaCode;} get officeNumber() {return this._telephoneNumber.number;}}class TelephoneNumber { get areaCode() {return this._areaCode;} get number() {return this._number;}}Inline Class(클래스 인라인하기)-클래스 추출하기의 반대 리팩터링으로, 더 이상 제 역할을 못하는 분리된 클래스는 인라인해버린다.-클래스 추출하고 나니 특정 클래스에 남은 역할이 거의 없을 때 이런 현상이 자주 생김// fromclass Person { ... get officeAreaCode() {return this._telephoneNumber.areaCode;} get officeNumber() {return this._telephoneNumber.number;}}class TelephoneNumber { get areaCode() {return this._areaCode;} get number() {return this._number;}}------------------------------------------------------// toclass Person { ... get officeAreaCode() {return this._officeAreaCode;} get officeNumber() {return this._officeNumber;}}Hide Delegate(위임 숨기기)-서버 객체의 필드가 가리키는 객체(위임 객체)의 메서드를 호출하려면 클라이언트는 이 위임 객체를 알아야 한다. 이럴 경우 위임 객체의 인터페이스가 바뀌면 이 인터페이스를 사용하는 모든 클라이언트가 코드를 수정해야 한다.-따라서, 서버 자체에 위임 메서드를 만들어서 위임 객체의 존재를 숨기면 된다!// frommanager = aPerson.department.manager;------------------------------------manager = aPerson.manager;class Person { get manager() {return this.department.manager;} }Remove Middle Man(중재자 제거하기)-위임 숨기기의 반대 리팩터링-클라이언트가 위임 객체의 또 다른 기능을 사용하고 싶을 때마다 서버에 위임 메서드를 추가해야 하는데, 이러다보면 단순히 전달만 하는 위임 메서드들이 점점 많아진다.- 이렇게 되면, 서버 클래스는 그저 중개자 역할로 전락하여 차라리 클라이언트가 위임 객체를 직접 호출하는게 나을 수 있다.manager = aPerson.manager;class Person { get manager() {return this.department.manager;} }------------------------------------manager = aPerson.department.manager;Substitute Algorithm(알고리즘 교체하기)-더 간명한 방법을 찾아낸다면, 교체하기-거대하고 복잡한 알고리즘의 경우 교체하기란 상당히 어려우니, 알고리즘을 간소화하는 작업부터 해야 작업이 쉬워진다.// fromfunction foundPerson(people) { for (let i = 0; i &lt; people.length; i++) { if (people[i] === 'Don') { return 'Don'; } if (people[i] === 'John') { return 'John'; } if (people[i] === 'Kent') { return 'Kent'; } } return '';}----------------------------------------// tofunction foundPerson(people) { const candidates = ['Don', 'John', 'Kent']; return people.find(p =&gt; candidates.includes(p)) || '';}" }, { "title": "[Refactoring] Encapsulation(1)", "url": "/posts/js-refactoring-3/", "categories": "Javascript", "tags": "javascript, refactoring", "date": "2021-05-17 04:38:00 +0800", "snippet": "마틴파울러의 Refactoring 2판 7과의 내용 정리(1)입니다.Encapsulate Record(레코드 캡슐화하기)-레코드의 단점은 계산해서 얻을 수 있는 값과 그렇지 않은 값을 명확히 구분해 저장해야 하는 점이다.-때문에 가변 데이터를 저장하는 용도는 객체가 더 나을 수 있다. 값과 계산과정을 숨기고 메소드로 제공할 수 있다.// fromorganization = {name: \"애크미 구스베리\", country: \"GB\"}--------------------------------------------------------// toclass Organization { constructor(data) { this._name = data.name; this._country = data.country; } get name() {return this._name;} set name(arg) {this._name = arg;} get country() {return this._country;} set country(arg) {this._country = arg;}}Encapsulate Collection(컬렉션 캡슐화하기)-게터가 컬렉션 자체를 반환하도록 한다면, 그 컬렉션을 감싼 클래스가 눈치채지 못하는 상태에서 컬렉션의 원소들이 바뀌어버릴 수 있다.-add(), remove()와 같은 컬렉션 변경자 메서드를 만들어 해결할 수 있다.-게터를 제공하되 내부 컬렉션의 복제본을 반환하여 예상치 못하게 바뀌는 문제를 해결할 수 있다.// fromclass Person { get courses() {return this._courses;} set courses(aList) {this._courses = aList;}}---------------------------------------------// toclass Person { get courses() {return this._courses.slice();} addCourse(aCourse) { ... } removeCourse(aCourse) { ... }}Replace Primitive with Object(기본형을 객체로 바꾸기)-처음에는 숫자, 문자열 같은 간단한 데이터 항목으로 표현할 때가 많지만, 이후에 이 정보들이 더 이상 간단하지 않게 변할 수 있다.-ex) 전화번호를 문자열로 표현 -&gt; 포매팅이나 지역 코드 추출 같은 특별한 동작 추가// fromorders.filter(o =&gt; 'high' === o.priority || 'rush' === o.priority);-------------------------------------------// toorders.filter(o =&gt; o.priority.higherThan(new Priority('normal')));Replace Temp with Query(임시 변수를 질의 함수로 바꾸기)-비슷한 계산을 수행하는 다른 함수에서도 사용할 수 있어 코드 중복이 줄어들 수 있다.-이번 리팩터링은 추출할 메서드들에 공유 컨텍스트를 제공하기에, 클래스 안에서 적용할 때가 효과가 가장 크다.// fromconst basePrice = this._quantity * this._itemPrice;return (basePrice &gt; 1000) ? basePrice * 0.95 : basePrice * 0.98;----------------------------------------------------------------// toget basePrice() {this._quantity * this._itemPrice;}...return (this.basePrice &gt; 1000) ? this.basePrice * 0.95 : this.basePrice * 0.98;" }, { "title": "[Refactoring] A First Set Of Refactorings(2)", "url": "/posts/js-refactoring-2/", "categories": "Javascript", "tags": "javascript, refactoring", "date": "2021-05-11 05:59:00 +0800", "snippet": "마틴파울러의 Refactoring 2판 6과의 내용 정리(2)입니다.Rename Variable(변수 이름 바꾸기)-명확한 프로그래밍의 핵심은 이름짓기..!let a = height * width; --&gt; let area = height * width;Introduce Parameter Object(매개변수 객체 만들기)-데이터 뭉치를 데이터 구조로 묶으면 데이터 사이의 관계가 명확해진다-매개변수 수가 줄어든다-같은 데이터 구조를 사용하는 모든 함수가 원소를 참조할 때 항상 같은 이름 쓰기에 일관성도 높여준다-나중에 동작까지 함께 묶기 좋도록 class로 만드는것 추천// fromfunction readingOutsideRange(station, min, max) { return station.readings .filter(r =&gt; r.temp &lt; min || r.temp.max)}alerts = readingOutsideRange(station, operationgPlan.temperatureFloor, operationPlan.temperatureCeiling);--------------------------------------------------// toclass NumberRange { constructor(min, max) { this._data = {min: min, max: max}; } get min() {return this._data.min;} get max() {return this._data.max;} contains(arg) {return (arg &gt;= this.min &amp;&amp; arg &lt;= this.max);}}function readingOutsideRange(station, range) { return station.readings .filter(r =&gt; !range.contains(r.temp))}const range = new NumberRange(operationgPlan.temperatureFloor, operationPlan.temperatureCeiling);alerts = readingOutsideRange(station, range);Combine Functions into Class(여러 함수를 클래스로 묶기)-함수들이 공유하는 공통 환경을 더 명확하게 표현할 수 있다.-각 함수에 전달되는 인수를 줄여서 객체 안에서의 함수 호출을 간결하게 만들수 있다.-객체를 시스템의 다른 부분에 전달하기 위한 참조를 제공할 수 있다.// fromfunction base(aReading) {...}function taxableCharge(aReading) {...}function calculateBaseCharge(aReading) {...}-----------------------------------------------// toclass Reading { base() {...} taxableCharge() {...} calculateBaseCharge() {...} }Combine Functions into Transform(여러 함수를 변환 함수로 묶기)-Combine Functions into Class 방법과는 유사할 수 있지만, 원본데이터가 코드 안에서 갱신될 경우는 클래스로 묶는 편이 훨씬 낫다. 변환 함수로 묶으면 가공한 데이터를 새로운 레코드에 저장하므로, 원본 데이터가 수정되면 일관성이 깨질 수 있기 때문.-여러 함수를 묶는 이유는 도출 로직이 중복되는 것을 피하기 위해서다.-원본데이터를 바꾸는 함수들을 한군데 묶어 변경된 원본데이터를 반환해준다.// fromfunction base(aReading) {...}function taxableCharge(aReaging) {...}-----------------------------------------------// tofunction enrichReading(argReading) { const aReading = _.cloneDeep(argReading); aReading.baseCharge = base(aReading); aReading.taxableCharge = taxableCharge(aReaging); return aReading;}Split Phase(단계 쪼개기)-서로 다른 두 대상을 한꺼번에 다루는 코드는 분리! 하나에만 집중!// fromconst orderData = orderString.split(/\\s+/);const productPrice = priceList(orderData[0].split(\"-\")[1]];const orderPrice = parseInt(orderData[1]) * productPrice;---------------------------------------------------// toconst orderRecord = parseOrder(order);const orderPrice = price(orderRecord, priceList);function parseOrder(aString) { const values = aString.split(/\\s+/); return ({ productID: values[0].split(\"-\")[1], quantity: parseInt(values[1]) })}function price(order, priceList) { return order.quantity * priceList[order.productID]; }’// fromfunction priceOrder(product, quantity, shippingMethod) { const basePrice = product.basePrice * quantity; const discount = Math.max(quantity - product.discountThreshold, 0) * product.basePrice * product.discountRate; const shippingPerCase = (basePrice &gt; shippingMethod.discountThreshold) ? shippingMethod.discountedFee : shippingMethod.feePerCase; const shippingCost = quantity * shippingPerCase; const price = basePrice - discount + shippingCost; return price;}--------------------------------------------------// tofunction priceOrder(product, quantity, shippingMethod) { const priceData = calculatePricingData(product, quantity); return applyShipping(priceData, shippingMethod);}function calculatePricingData(product, quantity) { const basePrice = product.basePrice * quantity; const discount = Math.max(quantity - product.discountThreshold, 0) * product.basePrice * product.discountRate; return {basePrice: basePrice, quantity: quantity, discount: discount};}function applyShipping(priceData, shippingMethod) { const shippingPerCase = (priceData.basePrice &gt; shippingMethod.discountThreshold) ? shippingMethod.discountedFee : shippingMethod.feePerCase; const shippingCost = priceData.quantity * shippingPerCase; return priceData.basePrice - priceData.discount + shippingCost;}" }, { "title": "[Refactoring] A First Set Of Refactorings(1)", "url": "/posts/js-refactoring-1/", "categories": "Javascript", "tags": "javascript, refactoring", "date": "2021-05-06 06:14:00 +0800", "snippet": "마틴파울러의 Refactoring 2판 6과의 내용 정리입니다.Extract Function (함수 추출하기)-목적과 구현을 분리-코드가 5~6줄을 넘어가면 추출할 냄새가 나기 시작..!-성능 느려질 걱정은 ㄴㄴ 요즘은 그럴일 거의 없다// fromfunction printOwing(invoice) { printBanner(); let outstanding = calculateOutstanding(); // 세부 사항 출력 console.log(`고객명: ${invoice.customer}`); console.log(`채무액: ${outstanding}`);} --------------------------------------------// tofunction printOwing(invoice) { printBanner(); let outstanding = calculateOutstanding(); printDetails(outstanding); function printDetails(outstanding) { console.log(`고객명: ${invoice.customer}`); console.log(`채무액: ${outstanding}`); }}Inline Function(함수 인라인하기)-함수 추출하기의 반대 리팩터링-함수 본문이 함수명만큼이나 명확할 경우 굳이 함수를 나누기 보다는 합치기// fromfunction getRating(driver) { return moreThanFiveLateDeliveries(driver) ? 2 : 1;}function moreThanFiveLateDeliveries(driver) { return driver.numberOfLateDeliveries &gt; 5;}---------------------------------------------// tofunction getRating(driver) { return (driver.numberOfLateDeliveries &gt; 5) ? 2 : 1;}Extract Variable(변수 추출하기)-표현식이 너무 복잡할 경우 단계마다 이름 붙이기(직관적으로 보이도록)-중단점 지정하거나 상태 출력(console.log)을 하며 디버깅 할때도 좋다// fromreturn order.quantity * order.itemPrice - Math.max(0, order.quantity - 500) * order.itemPrice * 0.05 + Math.min(order.quantity * order.itemPrice * 0.1, 100);-----------------------------------------------// toconst basePrice = order.quantity * order.itemPrice;const quantityDiscount = Math.max(0, order.quantity - 500) * order.itemPrice * 0.05;const shipping = Math.min(basePrice * 0.1, 100);return basePrice - quantityDiscount + shipping;Inline Variable(변수 인라인하기)-변수명이 표현식이랑 다를 바 없을 때는 그냥 inline 하는게 좋다.// fromconst basePrice = anOrder.basePrice;return (basePrice &gt; 1000);-------------------------------------------------// toreturn anOrder.basePrice &gt; 1000;Change Function Declaration(함수 선언 바꾸기)-함수명 변경 - 함수명만 보고도 유추되도록 변경! 축약어 멈춰!function circum(radius) {...} -&gt; function circumeference(radius) {...}-매개변수 객체를 속성으로 바꾸기.-객체가 넘어가야 할 경우도 있지만, 의존성이 높아지기 때문에..! 필요하지 않다면 속성값만 넘기기// fromfunction inNewEngland(aCustomer) { return ['MA', 'CT', 'ME', 'VT', 'NH', 'RI'].includes(aCustomer.address.state); }const newEnglanders = someCustomers.filter(c =&gt; inNewEngland(c));-------------------------------------------------// tofunction inNewEngland(stateCode) { return ['MA', 'CT', 'ME', 'VT', 'NH', 'RI'].includes(stateCode); }const newEnglanders = someCustomers.filter(c =&gt; inNewEngland(aCustomer.address.state));Encapsulate Variable(변수 캡슐화하기)-데이터로의 접근을 독점하는 함수를 만듦으로써, 데이터 재구성이라는 어려운 작업을 함수 재구성이라는 더 단순한 작업으로 변환시킨다.-데이터를 변경하고 사용하는 코드를 감시할 수 있는 확실한 통로가 될 수 있다.-데이터 변경 전 검증이나 변경 후 추가 로직을 쉽게 끼워 넣을 수 있다.-따라서, 데이터의 유효범위가 넓을수록 캡슐화 해야 한다. 그래야 자주 사용하는 데이터에 대한 결합도가 낮아진다.-객체 데이터를 private하게 유지할 수 있다. (마음대로 변경 방지)// fromconst defaultOwner = { firstName: 'Martin', lastName: 'Fowler'};-------------------------------------------------// toconst defaultOwnerData = { firstName: 'Martin', lastName: 'Fowler'};export function defaultOwner() { return defaultOwnerData; }export function setDefaultOwner(arg) { defaultOwner = arg; }// if you wanna prevent object from being changedexport function defaultOwner() { return Object.assign({}, defaultOwnerData); }" }, { "title": "Javascript module 타입의 cors 문제", "url": "/posts/js-cors/", "categories": "Javascript", "tags": "javascript, cors", "date": "2021-03-11 22:59:00 +0800", "snippet": "&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"module\" src=\"js/main.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;이렇게 module타입으로 js import를 하게되면, cors에러가 뜨게 됩니다.file:///~~ 요런 url이 cors에 의해 block 되었다는 것인데요..ㅠnpm으로 매우 간단하게 해결할 수 있습니다.http-server를 활용하는 것입니다. npm install http-server -g index.html이 있는 경로에서 npx http-server 실행 http://127.0.0.1:8080 에 접속! (포트 바꾸고 싶다면 npx http-server -p 포트번호) 끝!조금 더 편하게 하고자 한다면 package.json에 script를 등록하면 됩니다.\"scripts\": { ..., \"start\": \"npx http-server -p 8000\"}," }, { "title": "Rxjs duplicated assign issue", "url": "/posts/js-rxjs-duplicated-assign/", "categories": "Javascript", "tags": "javascript, rxjs", "date": "2021-02-17 17:51:00 +0800", "snippet": "Observable을 구독하는 Subscription 변수에 한번 더 assign 한다면 어떤 일이 발생할까요?아래 코드를 보고 상황을 살펴보겠습니다.class RxjsAssignment { constructor() { this.subscribeWindowScroll(); this.subscribeWindowScroll(); this.unsubscribeWindowScroll(); } private windowScrollSubscription: Subscription; subscribeWindowScroll(): void { this.windowScrollSubscription = fromEvent(window, 'scroll').subscribe((event) =&gt; { this.onScroll(event); }); } unsubscribeWindowScroll(): void { if (this.windowScrollSubscription !== undefined) { this.windowScrollSubscription.unsubscribe(); } } onScroll(): void { console.log('onScroll'); }}위 코드를 수행 후 스크롤을 하면 onScroll 함수의 콘솔이 찍힐까요?언뜻보면 Subscription 변수에 새로 assign 했고, unsubscribe도 해줬기에 아무 문제 없어보입니다.하지만..! 여전히 콘솔이 계속 찍히게 됩니다. 사실 제가 별 생각없이 비슷한 로직으로 개발했다가 삽질을…흑..여튼 fromEvent Observable을 첫번째는 1번, 두번째는 2번으로 부르겠습니다.1번을 assign한 후, 2번을 assign하게 되면 1번은 이미 공간이 할당되었으므로 unsubscribe되지 않고 추적이 불가능한채로 남아있게 되고,2번을 아무리 unsubscribe해줘도 1번은 계속 메모리를 차지하게 됩니다.쉽게(?) 말하면, windowScrollSubscription 변수는 1번의 공간을 가리켰다가 2번을 가리키는 것일 뿐이지 1번을 없애고 2번을 가지는 것이 아닌 것입니다.따라서.. 저렇게 두번 assign하는 일이 일어나지 않게 조심해야하는 것은 물론이고, 혹시나 어쩔 수 없이 두번 하게 된다면..! 항상 unsubscribe를 해주고 assign 하자.....subscribeWindowScroll(): void { this.unsubscribeWindowScroll(); this.windowScrollSubscription = fromEvent(window, 'scroll').subscribe((event) =&gt; { this.onScroll(event); }); }..." }, { "title": "Chrome DevTools 활용법 (개발자 도구)", "url": "/posts/chrome-developer-tools/", "categories": "Chrome", "tags": "Chrome, developer tools", "date": "2020-12-20 18:37:00 +0800", "snippet": "많이들 기본적으로 사용하는 기능에 대해서는 언급하지 않고 알아두면 유용한 부분들 위주로 추려봤습니다.[Elements]Node에 쉽게 접근 (without querySelector)$0~ $4 까지 최근 클릭한 5개의 Node가 저장됩니다. 가장 최근이 $0, 가장 마지막이 $4 입니다.아래 사진을 보면, 이 클릭된 상태에서 $0을 했더니 input element가 잡히는 것을 확인할 수 있습니다.Element Breakpointsources탭에서 javascript breakpoint를 할 수 있지만, dom의 변화에 breakpoint를 설정할 수도 있습니다. 아래 그림에서 보면, (하위 Nodes 변경 / 현재 Node 변경 / Node 삭제) 케이스에 대해 breakpoint를 지정할 수 있습니다.이 외에도 force state 탭에서 element의 상태를 focus, hover 등으로 강제시킬 수 있습니다.[Consoles]Live Expression매번 console을 찍어가며 확인하던 부분을 저 눈처럼 생긴 버튼을 클릭하여 expression을 적어 실시간으로 확인해볼 수 있습니다.해당 부분의 값이 무엇인지, element의 사이즈나 스타일 등 여러가지를 굳이 콘솔을 찍어보지 않더라도 이를 통해 간단히 확인해 볼 수 있습니다.Live Expression 버튼을 여러번 눌러 expression을 여러개 추가할 수 있습니다.[Sources]Snippets간단한 script를 작성해 놓고 활용할 수 있습니다. 아래의 예시를 보면, add 함수 snippet을 작성해 두었고, 아래 콘솔에서 정의한 함수를 사용해서 결과를 내는 것을 보실 수 있습니다. 주의하실 점은 중간 빨간 박스의 시작 버튼을 눌러야 한다는 점입니다. 자주 쓰이는 테스트용 함수들을 정의해 놓으면 유용할 것입니다 ㅎㅎ " }, { "title": "[Javascript] ios Momentum Scrolling Issue(탄력스크롤)", "url": "/posts/js-momentum-scroll/", "categories": "Javascript", "tags": "javascript, momentum scroll", "date": "2020-12-19 22:39:00 +0800", "snippet": "ios는 탄력스크롤이라는게 있죠?스크롤에 관성도 있고 끝에 도달하면 바운스도 됩니다. 아래 css를 통해 이를 적용하는데요..-webkit-overflow-scrolling: touch;하지만 문제가 있습니다.스크롤 중일 때에는 scrollTop이 업데이트 되지 않는다는 것입니다..!제가 진행중인 프로젝트에서 element들이 추가됨에 따라 스크롤 높이를 계산해서 스크롤 위치를 재설정해줘야 하는 경우가 있었는데, scrollElement.scrollTop = 0;이렇게만 쓴다면, 스크롤 관성은 그대로 유지되고 element는 추가되서 뚝뚝 끊기는 현상이 발생할 수 있습니다.(주로 역방향 스크롤시…)위에 언급한 프로젝트에서 역방향 스크롤시, dom이 추가되고 추가된만큼 계산해서 스크롤 위치를 다시 잡아줘야 했습니다. 그런데, dom이 추가될때마다 스크롤이 끊기고 이리갔다 저리갔다 제멋대로였습니다.처음에는 scrollTop이 업데이트 안된다는 생각을 못하고, 그저 이미지가 포함된 dom이 추가되면서 고정되지 않은 이미지 사이즈 때문에 스크롤이 난리법석인줄 알았..습니다 ㅠㅠ쨋든 원인을 알았으니 해결책을 강구하던 중 설마 될까 하고 시도했던 방법이 성공을 했습니다…!해결방법scrollElement.style.overflowY = 'hidden';scrollElement.scrollTop = somewhere;scrollElement.style.overflowY = 'scroll';이 방법이 정답일지는 모르겠지만 끊김없이 스무스하게 스크롤 되는 모습을 확인할 수 있었습니다 :)간단히, hidden으로 스크롤 아닌 것처럼 하고 scrollTop을 업데이트 시켜준 후에 다시 스크롤옵션을 주는 방법입니다.hidden 옵션을 주면 그순간 관성이 뚝 끊길줄 알았지만 관성은 그대로 남아있고 아무일 없었다는 듯이 스크롤 되더군요..!혹시나 같은 문제를 겪으신 분들은 이 방법을 써보셔도 좋을 것 같습니다 :)" }, { "title": "[Javascript] ios 한글 조합 문제", "url": "/posts/js-ios-korean/", "categories": "Javascript", "tags": "javascript, ios korean", "date": "2020-12-19 19:42:00 +0800", "snippet": "ios 13이상에서는 받침이 완료되지 않은 문자에 대해서 buffer에 저장되버립니다.받침까지 완료가 되어야만 제대로 출력이 되고, 아닌경우는 받침이 필요없지 않는한 이상한 현상을 겪게 됩니다.ex) ‘아아’ 라는 문자 전송 후, input = ‘‘으로 입력값을 초기화 해줘도 다음에 ‘ㅇ’을 입력하면 ‘앙’이 출력됩니다.이런 ~그지같은~ 현상 때문에 여러 방법을 시도해봤는데요..!한가지 방법은 input의 focus를 없앴다가 다시 focus 시켜주는 방법입니다. 입력이 완료되면 blur 후 다시 focus 해주는 방식인데,해결이야 되지만 키보드가 내려갔다 다시 올라오는 불편한 상황이 연출됩니다..ㅜㅠ그러다 아래 참고로 적어둔 포스트에서 답을 얻었습니다. (감사합니다..!)간단히 해결책만 말하자면,숨겨진 input을 하나 두고 focus를 먼저 줘버리면 해당 buffer가 숨겨진 input으로 가버리고다시 원래 input을 focus하면 쓸데없는 버퍼가 사라지게 됩니다. 아래처럼..!!// 숨겨진 input focus 직후 원래 input focushiddenInputElem.focus();inputElem.focus();이렇게되면 키보드도 그대로 유지되면서 자연스럽게 해결이 가능합니다참고) https://kidk.kr/2019-12-07-clear-input-buffer-in-ios/" }, { "title": "Clipboard copy on Safari using Javascript", "url": "/posts/js-clipboard/", "categories": "Javascript", "tags": "javascript, clipboard", "date": "2020-11-19 11:17:00 +0800", "snippet": "웹개발을 할때, 링크를 복사한다든지 그 외의 다른 텍스트를 클립보드에 복사시키려면 크롬의 경우는 매우 간단합니다.하지만… 그놈의 애플..이 항상 문제죠;; 후아래 코드는 safari건 chrome이건 다 동작합니다. 임의의 textarea를 생성하고 값을 세팅하고 textarea영역을 선택(복사할 글자 선택).보통 여기까지하면 textarea의 모든 범위의 값이 선택됩니다. 이후 범위 설정하면 설정한 범위까지의 text가 선택됩니다.마무리로 execCommand(‘copy’) 해준다면 완료!……iosCopyToClipboard(textToCopy): boolean { const tmpTextarea = document.createElement('textarea'); tmpTextarea.value = textToCopy; // tmpTextarea.contentEditable = true; // tmpTextarea.readOnly = false; document.body.appendChild(tmpTextarea); tmpTextarea.select(); tmpTextarea.setSelectionRange(0, 9999); // 셀렉트 범위 설정 const result = document.execCommand('copy'); document.body.removeChild(tmpTextarea); return result; }… 라면 좋겠지만! ios에는 한가지 함정이 있습니다.safari에서는 무조건!! user action에 의해 trigger 된 것만 복사를 허용해줍니다.이를 몰라서 문제 없는 코드만 수정하며 삽질을 많이 했는데요,,, user action에 의해 trigger 되는 것이란, 말 그대로 유저가 버튼 누르거나 직접 꾹 눌러서 복사 하는 것입니다. 그래서 safari console에서 직접 복사 커맨드 입력해봤자 false만 return 해줄 뿐입니다.저같은 경우는, 클릭했을때 수행하는 함수에서 api call을 하나 수행한 후에 copy로직을 수행했었습니다.유저가 직접 클릭한 함수이긴 했으나 그 안에서 서버로부터 값을 가져오는 작업을 수행하는 바람에 ‘이건 유저에 의한 이벤트가 아니구나!’ 라고 지멋대로 판단하는 것 같습니다..실제로, 해당 api call 작업 바로 직전에 copy하면 잘 동작을 하지만, 작업 후로 로직을 옮기면 실패하게 됩니다.safari가 개발자 친화적이 되길 기원합니다…!!" }, { "title": "[Angular] Pipe", "url": "/posts/angular-pipe/", "categories": "Angular", "tags": "angular, Template reference variables", "date": "2020-10-07 23:16:00 +0800", "snippet": "view에 맞게 데이터를 변경할 때,단순한? 방법은 component ts에서 view용 변수를 하나 선언하고원하는대로 데이터를 변형해서 초기화하는 방법일 것입니다. 하지만 앵귤러에서의 Pipe를 이용하면 굳이 컴포넌트를 거치지 않고바로 뷰에서 원하는대로 데이터를 변형시킬 수 있습니다. 아래 예시를 보면,위에는 component에서 template용 변수를 생성한 경우고아래는 pipe를 이용한 코드입니다. 엄청 간단해지는!!import { Component } from '@angular/core';@Component({ selector: 'app-uppercase', template: `&lt;p&gt;angular's uppercase is &lt;/p&gt;`})export class HeroBirthdayComponent { angular = 'angular'; angularUpper = angular.toUpperCase();}import { Component } from '@angular/core';@Component({ selector: 'app-uppercase', template: `&lt;p&gt;angular's uppercase is &lt;/p&gt;`})export class HeroBirthdayComponent { angular = 'angular';}하지만 주의해야할 점이 있습니다. 아래 코드의 경우는 (from. angular 공식문서) object array를 필터링 해주는 pipe입니다. 이때 문제는, heroes 내용이 바뀌어도 pipe가 그 변화를 감지하지 못한다는 것입니다.object의 참조가 바뀌지 않는 이상, 그 안의 값이 바뀐다 해도 화면엔 이전 상태로만 보이게 됩니다.이는 pipe가 pure change만 감지하기 때문입니다. string, number, boolean, symbol 같은 기본 자료형의 값이 변경되거나 객체의 참조가 변경되는 것만 감지하는 것입니다. // Pipeimport { Pipe, PipeTransform } from '@angular/core';import { Flyer } from './heroes';@Pipe({ name: 'flyingHeroes' })export class FlyingHeroesPipe implements PipeTransform { transform(allHeroes: Flyer[]) { return allHeroes.filter(hero =&gt; hero.canFly); }}// Template&lt;div *ngFor=\"let hero of (heroes | flyingHeroes)\"&gt; &lt;/div&gt;그래서 이때는 아래와 같이 pure: false 옵션을 주어 해결할 수 있습니다. // Pipeimport { Pipe, PipeTransform } from '@angular/core';import { Flyer } from './heroes';@Pipe({ name: 'flyingHeroes', pure: false })export class FlyingHeroesPipe implements PipeTransform { transform(allHeroes: Flyer[]) { return allHeroes.filter(hero =&gt; hero.canFly); }}// Template&lt;div *ngFor=\"let hero of (heroes | flyingHeroes)\"&gt; &lt;/div&gt;하지만, 이는 객체의 모든 변화에 반응하며 filter를 수행하기 때문에, 만약 pipe에서 복잡하고 오래걸리는 로직이 수행되는 경우라면 성능에 지대한 영향을 끼칠 수 있으므로 주의해야 합니다.이하는 angular에서 기본적으로 제공하는 자주 사용되는 pipe 입니다. DatePipe UpperCasePipe LowerCasePipe CurrencyPipe DecimalPipe PercentPipe여기에 추가로 매우 유용한 async pipe가 있지만이는 observable과 뗄수 없는 사이이므로 여기서는 다루지 않겠습니다." }, { "title": "[Angular] User Input - 사용자 입력", "url": "/posts/angular-user-input/", "categories": "Angular", "tags": "angular, Template reference variables", "date": "2020-10-06 17:35:00 +0800", "snippet": "앵귤러의 사용자 입력에서 불필요한 코드를 제거하고 디펜던시를 제거할 수 있는 부분을 살펴보는 글입니다.아래 코드들과 정보는 앵귤러 공식 문서를 참조했습니다.angular에서 사용자 입력(input, click 등)을 받을 때 아래 코드처럼 $event를 통째로 넘기고 그 이벤트에 맞게 타입을 정의해서 사용할 수 있습니다.아래는 keyup이라는 이벤트가 발생했기에 onKey() 함수에서의 파라미터 타입을 KeyboardEvent로 명시하여 사용합니다. @Component({ selector: 'app-keyup', template: ` &lt;input (keyup)=\"onKey($event)\"&gt; &lt;p&gt;&lt;/p&gt; `})export class KeyUpComponent_v1 { values = ''; onKey(event: KeyboardEvent) { // with type info this.values += (event.target as HTMLInputElement).value + ' | '; }}하지만!! 이는 너무 많은 정보를 컴포넌트로 넘기는 것은 물론, html에서 어떤 이벤트가 발생했는지를 알아야만 넘어온 이벤트 데이터를 활용할 수 있다는 치명적인 단점이 있습니다. 즉, html과 component가 분리되지 않고 의존성을 가지게 되는 문제가 있는 것입니다.그래서 angular 공식 문서에서는 아래의 방식을 추천합니다. @Component({ selector: 'app-loop-back', template: ` &lt;input #box (keyup)=\"0\"&gt; &lt;p&gt;&lt;/p&gt; `})export class LoopbackComponent { }Template reference variables(#box)를 통해 component에는 필요한 정보를 주는 방식입니다.아래는 value 정보만 컴포넌트로 넘겨 활용하는 예시 코드입니다.@Component({ selector: 'app-key-up2', template: ` &lt;input #box (keyup)=\"onKey(box.value)\"&gt; &lt;p&gt;&lt;/p&gt; `})export class KeyUpComponent_v2 { values = ''; onKey(value: string) { this.values += value + ' | '; }}또한, form을 submit할때에도 비슷하게 활용할 수 있습니다.&lt;form #itemForm=\"ngForm\" (ngSubmit)=\"onSubmit(itemForm)\"&gt; &lt;label for=\"name\" &gt;Name &lt;input class=\"form-control\" name=\"name\" ngModel required /&gt; &lt;/label&gt; &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;div [hidden]=\"!itemForm.form.valid\"&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;컴포넌트간의 dependency에 집중해왔었는데 html은 별로 고려하지 않았었다는 생각이 많이 드네요..!" }, { "title": "[Angular] Unsubscribe http request", "url": "/posts/angular-http-unsubscribe/", "categories": "Angular", "tags": "angular, unsubscribe", "date": "2020-09-26 21:30:00 +0800", "snippet": "Observable을 unsubscribe 하는 것은 메모리 관리에 있어서 매우 중요한 이슈입니다.그래서 저는 보통 rxjs 함수들로 자동으로 구독 해제하거나 (ex. take, takeUntil … )async pipe를 사용해서 필요한 경우가 아니라면 따로 unsubscribe를 해주지 않습니다.하지만 이외에도 굳이 unsubscribe 해주지 않아도 되는 것이 있었는데..!단발성 데이터에 대해서는 필요가 없는 것입니다.http request의 경우에도 서버에서 한번 받아오면 끝나는 작업이기에 바로 complete가 호출되버립니다.코드로 한번 비교해보도록 하겠습니다.const test = this.testService.getData().subscribe( data =&gt; console.log('data', data), err =&gt; console.log('error', err), () =&gt; { console.log('Complete!') console.log(test); setTimeout(()=&gt;{ console.log(test); }) } )&gt;&gt; 결과간단한 데이터를 angular의 HttpClient를 통해서 요청했고 그 결과 입니다.결과를 받아오자마자 complete가 호출되는 것을 볼 수 있고complete 호출되자마자 unsubscribe되는 것은 아니지만 call stack이 비워지고 setTimeout안의 콘솔이 실행되면위 캡쳐처럼 close: true, subscriptions: null 인것을 확인할 수 있습니다.이 뿐만 아니라 of({ a: 1, b: 2}).subscribe() 이런식으로 단순한 데이터를 Observable로 만들어 subscribe 했을 때도 마찬가지로 바로 complete로 가는 것을 확인할 수 있습니다.반대로, 당연하겠지만 아래의 subscribe에서는 바로 complete가 호출되지 않습니다.이 경우는 예시처럼 take를 사용한다던지, 직접 해제해줘야겠죠?interval(1000) .pipe(take(10)) .subscribe( data =&gt; console.log('data', data), err =&gt; console.log('error', err), () =&gt; console.log('Complete!') )결론…http response에 대해서는 굳이 unsubscribe를 해줄 필요는 없다! 하지만 해준다고 나쁠것도 없다..!" }, { "title": "[Angular] 상태관리 with Mobx", "url": "/posts/angular-mobx/", "categories": "Angular", "tags": "angular, mobx", "date": "2020-08-23 21:09:00 +0800", "snippet": "Angular 개발을 하면서, 상태관리를 어떻게 하는게 제일 코드 양도 줄이고 효율적일까 고민을 많이 했습니다. 기존에는 service와 rxjs를 활용해서 관리를 했고, Angular하면 대표적인 ngrx를 사용해보았습니다. 하지만 boiler plate가 너무 많아지고 service + rxjs와 비교했을 때, 큰 장점을 느끼지 못했습니다. 그러던 중에, boiler plate가 싹 빠진 redux 라고 불리는(?) mobx를 접하게 되었습니다..!이하는 mobx 적용 후기입니다.정리- mobx npm 버전 관리 문제 - service와 차이점이 없습니다. 그저 store를 따로 둬서 ajax 통신을 service에서, action은 store에서 할뿐  @decoration만 붙어있는 service랑 똑같습니다. 그렇게 따지면 오히려 bolier plate가 늘어나서 굳이 angular에서는  쓸 필요가 없지 않을까 싶습니다." }, { "title": "[Javascript] RxJS - Subject", "url": "/posts/js-rxjs-subject/", "categories": "Javascript", "tags": "javascript, rxjs, subject", "date": "2020-07-12 16:55:00 +0800", "snippet": "https://rxjs.dev/guide/subject 번역오역 부분이나 조언(?)은 알려주시면 감사하겠습니다.SubjectSubject란? RxJS Subject는 Observable의 스페셜 타입입니다. 이는 많은 관찰자들에게 값들이 멀티캐스트 될 수 있도록 합니다. 보통의 Observable은 유니캐스트지만(구독한 각각의 관찰자들은 독립적인 Observable의 실행을 갖습니다), Subjects는 멀티캐스트입니다. Subject는 Observable 같지만, 많은 관찰자들에게 멀티캐스트 할 수 있습니다. Subjects는 EventEmitters와 같습니다 : 많은 청자들의 레지스트리를 유지합니다.Every Subject is an Observable. Given a Subject, you can subscribe to it, providing an Observer, which will start receiving values normally. From the perspective of the Observer, it cannot tell whether the Observable execution is coming from a plain unicast Observable or a Subject.Internally to the Subject, subscribe does not invoke a new execution that delivers values. It simply registers the given Observer in a list of Observers, similarly to how addListener usually works in other libraries and languages.Every Subject is an Observer. It is an object with the methods next(v), error(e), and complete(). To feed a new value to the Subject, just call next(theValue), and it will be multicasted to the Observers registered to listen to the Subject.In the example below, we have two Observers attached to a Subject, and we feed some values to the Subject:import { Subject } from 'rxjs';const subject = new Subject&lt;number&gt;();subject.subscribe({ next: (v) =&gt; console.log(`observerA: ${v}`)});subject.subscribe({ next: (v) =&gt; console.log(`observerB: ${v}`)});subject.next(1);subject.next(2);// Logs:// observerA: 1// observerB: 1// observerA: 2// observerB: 2Since a Subject is an Observer, this also means you may provide a Subject as the argument to the subscribe of any Observable, like the example below shows:import { Subject, from } from 'rxjs';const subject = new Subject&lt;number&gt;();subject.subscribe({ next: (v) =&gt; console.log(`observerA: ${v}`)});subject.subscribe({ next: (v) =&gt; console.log(`observerB: ${v}`)});const observable = from([1, 2, 3]);observable.subscribe(subject); // You can subscribe providing a Subject// Logs:// observerA: 1// observerB: 1// observerA: 2// observerB: 2// observerA: 3// observerB: 3With the approach above, we essentially just converted a unicast Observable execution to multicast, through the Subject. This demonstrates how Subjects are the only way of making any Observable execution be shared to multiple Observers.There are also a few specializations of the Subject type: BehaviorSubject, ReplaySubject, and AsyncSubject.Multicasted ObservablesA “multicasted Observable” passes notifications through a Subject which may have many subscribers, whereas a plain “unicast Observable” only sends notifications to a single Observer. A multicasted Observable uses a Subject under the hood to make multiple Observers see the same Observable execution.Under the hood, this is how the multicast operator works: Observers subscribe to an underlying Subject, and the Subject subscribes to the source Observable. The following example is similar to the previous example which used observable.subscribe(subject):import { from, Subject } from 'rxjs';import { multicast } from 'rxjs/operators';const source = from([1, 2, 3]);const subject = new Subject();const multicasted = source.pipe(multicast(subject));// These are, under the hood, `subject.subscribe({...})`:multicasted.subscribe({ next: (v) =&gt; console.log(`observerA: ${v}`)});multicasted.subscribe({ next: (v) =&gt; console.log(`observerB: ${v}`)});// This is, under the hood, `source.subscribe(subject)`:multicasted.connect();multicast returns an Observable that looks like a normal Observable, but works like a Subject when it comes to subscribing. multicast returns a ConnectableObservable, which is simply an Observable with the connect() method.The connect() method is important to determine exactly when the shared Observable execution will start. Because connect() does source.subscribe(subject) under the hood, connect() returns a Subscription, which you can unsubscribe from in order to cancel the shared Observable execution.Reference countingCalling connect() manually and handling the Subscription is often cumbersome. Usually, we want to automatically connect when the first Observer arrives, and automatically cancel the shared execution when the last Observer unsubscribes.Consider the following example where subscriptions occur as outlined by this list: First Observer subscribes to the multicasted Observable The multicasted Observable is connected The next value 0 is delivered to the first Observer Second Observer subscribes to the multicasted Observable The next value 1 is delivered to the first Observer The next value 1 is delivered to the second Observer First Observer unsubscribes from the multicasted Observable The next value 2 is delivered to the second Observer Second Observer unsubscribes from the multicasted Observable The connection to the multicasted Observable is unsubscribedTo achieve that with explicit calls to connect(), we write the following code:import { interval, Subject } from 'rxjs';import { multicast } from 'rxjs/operators';const source = interval(500);const subject = new Subject();const multicasted = source.pipe(multicast(subject));let subscription1, subscription2, subscriptionConnect;subscription1 = multicasted.subscribe({ next: (v) =&gt; console.log(`observerA: ${v}`)});// We should call `connect()` here, because the first// subscriber to `multicasted` is interested in consuming valuessubscriptionConnect = multicasted.connect();setTimeout(() =&gt; { subscription2 = multicasted.subscribe({ next: (v) =&gt; console.log(`observerB: ${v}`) });}, 600);setTimeout(() =&gt; { subscription1.unsubscribe();}, 1200);// We should unsubscribe the shared Observable execution here,// because `multicasted` would have no more subscribers after thissetTimeout(() =&gt; { subscription2.unsubscribe(); subscriptionConnect.unsubscribe(); // for the shared Observable execution}, 2000);If we wish to avoid explicit calls to connect(), we can use ConnectableObservable’s refCount() method (reference counting), which returns an Observable that keeps track of how many subscribers it has. When the number of subscribers increases from 0 to 1, it will call connect() for us, which starts the shared execution. Only when the number of subscribers decreases from 1 to 0 will it be fully unsubscribed, stopping further execution. refCount makes the multicasted Observable automatically start executing when the first subscriber arrives, and stop executing when the last subscriber leaves.Below is an example:import { interval, Subject } from 'rxjs';import { multicast, refCount } from 'rxjs/operators';const source = interval(500);const subject = new Subject();const refCounted = source.pipe(multicast(subject), refCount());let subscription1, subscription2;// This calls `connect()`, because// it is the first subscriber to `refCounted`console.log('observerA subscribed');subscription1 = refCounted.subscribe({ next: (v) =&gt; console.log(`observerA: ${v}`)});setTimeout(() =&gt; { console.log('observerB subscribed'); subscription2 = refCounted.subscribe({ next: (v) =&gt; console.log(`observerB: ${v}`) });}, 600);setTimeout(() =&gt; { console.log('observerA unsubscribed'); subscription1.unsubscribe();}, 1200);// This is when the shared Observable execution will stop, because// `refCounted` would have no more subscribers after thissetTimeout(() =&gt; { console.log('observerB unsubscribed'); subscription2.unsubscribe();}, 2000);// Logs// observerA subscribed// observerA: 0// observerB subscribed// observerA: 1// observerB: 1// observerA unsubscribed// observerB: 2// observerB unsubscribedThe refCount() method only exists on ConnectableObservable, and it returns an Observable, not another ConnectableObservable.BehaviorSubjectOne of the variants of Subjects is the BehaviorSubject, which has a notion of “the current value”. It stores the latest value emitted to its consumers, and whenever a new Observer subscribes, it will immediately receive the “current value” from the BehaviorSubject. BehaviorSubjects are useful for representing “values over time”. For instance, an event stream of birthdays is a Subject, but the stream of a person’s age would be a BehaviorSubject.In the following example, the BehaviorSubject is initialized with the value 0 which the first Observer receives when it subscribes. The second Observer receives the value 2 even though it subscribed after the value 2 was sent.import { BehaviorSubject } from 'rxjs';const subject = new BehaviorSubject(0); // 0 is the initial valuesubject.subscribe({ next: (v) =&gt; console.log(`observerA: ${v}`)});subject.next(1);subject.next(2);subject.subscribe({ next: (v) =&gt; console.log(`observerB: ${v}`)});subject.next(3);// Logs// observerA: 0// observerA: 1// observerA: 2// observerB: 2// observerA: 3// observerB: 3ReplaySubjectA ReplaySubject is similar to a BehaviorSubject in that it can send old values to new subscribers, but it can also record a part of the Observable execution. A ReplaySubject records multiple values from the Observable execution and replays them to new subscribers.When creating a ReplaySubject, you can specify how many values to replay:import { ReplaySubject } from 'rxjs';const subject = new ReplaySubject(3); // buffer 3 values for new subscriberssubject.subscribe({ next: (v) =&gt; console.log(`observerA: ${v}`)});subject.next(1);subject.next(2);subject.next(3);subject.next(4);subject.subscribe({ next: (v) =&gt; console.log(`observerB: ${v}`)});subject.next(5);// Logs:// observerA: 1// observerA: 2// observerA: 3// observerA: 4// observerB: 2// observerB: 3// observerB: 4// observerA: 5// observerB: 5You can also specify a window time in milliseconds, besides of the buffer size, to determine how old the recorded values can be. In the following example we use a large buffer size of 100, but a window time parameter of just 500 milliseconds.import { ReplaySubject } from 'rxjs';const subject = new ReplaySubject(100, 500 /* windowTime */);subject.subscribe({ next: (v) =&gt; console.log(`observerA: ${v}`)});let i = 1;setInterval(() =&gt; subject.next(i++), 200);setTimeout(() =&gt; { subject.subscribe({ next: (v) =&gt; console.log(`observerB: ${v}`) });}, 1000);// Logs// observerA: 1// observerA: 2// observerA: 3// observerA: 4// observerA: 5// observerB: 3// observerB: 4// observerB: 5// observerA: 6// observerB: 6// ...AsyncSubjectThe AsyncSubject is a variant where only the last value of the Observable execution is sent to its observers, and only when the execution completes.import { AsyncSubject } from 'rxjs';const subject = new AsyncSubject();subject.subscribe({ next: (v) =&gt; console.log(`observerA: ${v}`)});subject.next(1);subject.next(2);subject.next(3);subject.next(4);subject.subscribe({ next: (v) =&gt; console.log(`observerB: ${v}`)});subject.next(5);subject.complete();// Logs:// observerA: 5// observerB: 5The AsyncSubject is similar to the last() operator, in that it waits for the complete notification in order to deliver a single value." }, { "title": "[Javascript] RxJS - Subscription", "url": "/posts/js-rxjs-subscription/", "categories": "Javascript", "tags": "javascript, rxjs, subscription", "date": "2020-07-09 14:12:00 +0800", "snippet": "https://rxjs.dev/guide/subscription 번역오역 부분이나 조언(?)은 알려주시면 감사하겠습니다.Subscription구독이란? 구독은 일회용 자원, 일반적으로 Observable의 실행을 나타내는 객체입니다. 구독은 unsubscribe라는 중요한 메소드를 가지고 있습니다. 이는 인자를 갖지 않고, 구독이 잡고있던 자원을 처리합니다. RxJS 이전버전에서는, 구독이 “일회용”으로 불렸습니다.import { interval } from 'rxjs';const observable = interval(1000);const subscription = observable.subscribe(x =&gt; console.log(x));// Later:// This cancels the ongoing Observable execution which// was started by calling subscribe with an Observer.subscription.unsubscribe(); 구독은 자원 할당을 해제하거나 Observable 실행을 취소시기기 위해 필수적으로 unsubscribe() 함수를 가지고 있습니다. 구독들은 같이 둘 수 있습니다. 그래서 한번의 unsubscribe() 함수 호출로 여러개의 구독들을 구독 해제할 수 있습니다. 한 구독에 다른 구독을 더함으로서 할 수 있습니다:import { interval } from 'rxjs';const observable1 = interval(400);const observable2 = interval(300);const subscription = observable1.subscribe(x =&gt; console.log('first: ' + x));const childSubscription = observable2.subscribe(x =&gt; console.log('second: ' + x));subscription.add(childSubscription);setTimeout(() =&gt; { // Unsubscribes BOTH subscription and childSubscription subscription.unsubscribe();}, 1000);실행하면 아래와 같은 결과를 볼 수 있습니다:second: 0first: 0second: 1first: 1second: 2또한, 추가했던 구독을 제거하기 위해서 remove(다른 구독) 메소드도 있습니다." }, { "title": "[Javascript] RxJS - Operators", "url": "/posts/js-rxjs-operators/", "categories": "Javascript", "tags": "javascript, rxjs, observer", "date": "2020-07-07 12:57:00 +0800", "snippet": "https://rxjs.dev/guide/operators 번역오역 부분이나 조언(?)은 알려주시면 감사하겠습니다.RxJS는 Observable이 기본이지만, 대부분 연산자에 유용합니다. 연산자는 복잡한 비동기코드를 선언적 방식으로 구성하는데 필수적인 부분입니다.연산자란?연산자는 함수입니다. 2종류의 연산자가 있습니다 :파이프형 연산자들은 observableInstance.pipe(operator()) 구문을 사용해 Observable로 파이프 될 수 있습니다. 이는 filter(…)와 mergeMap(…)을 포함합니다. 호출되면 Observable 객체를 변경하지는 않습니다. 대신, 새로운 Observable을 반환합니다. 구독 로직은 첫번째 Observable에 기반합니다. 파이프형 연산자는 Observable을 input처럼 취해서 다른 Observable을 반환하는 함수입니다. 이는 순수 연산입니다 : 이전 Observable은 수정되지 않습니다.파이프형 연산자는 필수적으로 순수함수입니다. Observable을 받아 다른 Observable을 생산합니다. 반환된 Observable을 구독하는 것은 input Observable 또한 구독하는 것입니다.생성 연산자들은 다른 종류의 연산자입니다. 이는 새로운 Observable을 생성하기 위해 단독 함수로써 호출될 수 있습니다. 예를 들어, of(1, 2, 3) 은 1, 2, 3을 하나씩 차례로 내보내는 Observable을 생성합니다. 생성 연산자들은 이후의 섹션에서 더 상세하게 다루겠습니다.예를들어, map 이라는 연산자는 같은 이름의 배열 메소드와 유사합니다. [1, 2, 3].map(x =&gt; x * x) 의 결과는 [1, 4, 9] 인 것처럼, Observable은 아래와 같이 생성됩니다:import { of } from 'rxjs';import { map } from 'rxjs/operators';map(x =&gt; x * x)(of(1, 2, 3)).subscribe((v) =&gt; console.log(`value: ${v}`));// Logs:// value: 1 // value: 4// value: 91, 4, 9의 결과가 나옵니다. 다른 유용한 연산자는 first 입니다:import { of } from 'rxjs';import { first } from 'rxjs/operators';first()(of(1, 2, 3)).subscribe((v) =&gt; console.log(`value: ${v}`));// Logs:// value: 1map은 논리적으로 즉석에서 구성되어야 합니다. 매핑 기능을 제공해야 하기 때문입니다. 대조적으로, first는 변함없는 값일 수 있습니다. 하지만 그럼에도 불구하고 즉석에서 구성되어야 합니다. 일반적으로 모든 연산자는 인수가 필요한지 여부에 관계없이 구성됩니다.Piping파이프형 연산자들은 함수입니다. 그래서 보통의 함수처럼 사용될 수 있습니다. op()(obs) ㅡ 하지만 실제로는, 많은 연산자들이 함께 모이는 경향이 있습니다. 그리고 읽을수 없게 되어버립니다: op4()(op3()(op2()(op1()(obs)))). 이런 이유로, Observable은 .pipe()라는 메소드가 있습니다. 이는 똑같은 일이지만 훨신 가독성이 좋게 해줍니다: obs.pipe( op1(), op2(), op3(), op3(),)op()(obs) 는 절대 쓰이지 않습니다. 심지어 하나의 연산자만 있더라도 obs.pipe(op()) 가 보편적으로 선호됩니다.Creation Operators생성 연산자란? 파이프형 연산자와는 구분되게, 생성 연산자들은 흔한 사전 정의된 행동이나 다른 Observable들을 조합함으로써 Observable을 생성하는데 사용되는 함수입니다.생성 연산자의 전형적인 예제는 interval 함수입니다. 이는 숫자를 인자로 받아 Observable을 생성해 반환합니다:import { interval } from 'rxjs';const observable = interval(1000 /* number of milliseconds */);모든 정적 생성 연산자 리스트 입니다.Higher-order Observables (고차 Observables)Observable은 가장 보편적으로 string, number 같은 보통의 값들을 내보냅니다. 하지만 놀랍게도 종종, Observable의 Observable을 다뤄야 할 필요가 있습니다. 소위 고차 Observable이라 합니다. 예를 들어, 파일의 URL인 string들을 내보내는 Observable이 있다고 상상해봅시다. 코드는 아래와 같을 것입니다:const fileObservable = urlObservable.pipe( map(url =&gt; http.get(url)),);http.get()은 각각의 URL에 대해 (string 혹은 string 배열의) Observable을 반환합니다. 이제 Observable의 Observable(고차 Observable)이 생겼습니다.하지만 고차 Observable로 어떻게 작업을 해야할까요? 일반적으로, 평탄화해서 사용합니다: 어떤 방법을 이용해서 고차 Observable을 하나의 보통의 Observable로 바꿔줍니다. 예시:const fileObservable = urlObservable.pipe( map(url =&gt; http.get(url)), concatAll(),);concatAll() 연산자는 바깥의 Observable에서 나온 안쪽 각각의 Observable들을 구독하고, 한 Observable이 끝날때까지 도출된 값들을 복사합니다. 그리고 다음으로 넘어갑니다. 모든 값들은 그런식으로 연결됩니다. 다른 유용한 평탄화 연산자(소위 join 연산자)들은  mergeAll() — 도착하는대로 안쪽의 Observable을 구독하고 값을 도출합니다. switchAll() — 첫번째 안쪽 Observable을 도착하는대로 구독하고, 값을 도출합니다. 하지만 다음 안쪽 Observable이 도착하면, 이전의 것은 구독 해제하고 새로운 것을 구독합니다. exhaust() — 첫번째 안쪽 Observable을 도착하는대로 구독하고 값을 도출합니다. 첫번째가 끝나기 전까지는 다른 새로운 Observable들은 무시합니다. 끝나면 다음 Observable을 기다립니다.많은 배열 라이브러리가 map()과 flat() (혹은 flatten())을 flatMap() 하나로 합친것 처럼, 이에 상응하는 RxJS 평탄화 연산자들이 있습니다. concatMap(), mergeMap(), switchMap(), and exhaustMap().Marble diagrams(구슬 다이어그램)연산자들의 동작을 설명하기에 종종 문자로는 충분치 않습니다. 많은 연산자들은 시간과 연관되있습니다. 예를들어, 연산자들은 여러가지 방법으로 값 배출을 지연, 샘플링, 조절, 또는 디바운스 할 수 있습니다. 다이어그램은 종종 이것에 더 나은 방법입니다. 구슬 다이어그램은 어떻게 연산자들이 동작하는지 시각적으로 보여주고, input Observable, 연산자와 파라미터, output Observable을 포함하고 있습니다. 구슬 다이어그램에서, 시간 흐름은 왼-&gt;오 입니다. 이 다이어그램은 Observable 실행에서 어떻게 값들(구슬)이 배출되는지를 묘사합니다.아래에서 구슬 다이어그램을 설명하고 있습니다.이 문서 사이트 전체에서 구슬 다이어그램을 광범위하게 사용하여 연산자의 작동 방식을 설명합니다. 화이트 보드 나 단위 테스트 (ASCII 다이어그램)와 같은 다른 상황에서도 유용 할 수 있습니다.Categories of operators다른 목적의 연산자들이 있습니다. 그리고 이는 생성, 변환, 필터링, 결합, 멀티 캐스팅, 오류 처리, 유틸리티 등으로 분류 될 수 있습니다. 다음의 리스트에서는 모든 연산자가 카테고리별로 구성되어 있습니다. 전체 개요는 참조 페이지를 참조하십시오Creation Operators ajax bindCallback bindNodeCallback defer empty from fromEvent fromEventPattern generate interval of range throwError timer iifJoin Creation OperatorsThese are Observable creation operators that also have join functionality – emitting values of multiple source Observables. combineLatest concat forkJoin merge partition race zipTransformation Operators buffer bufferCount bufferTime bufferToggle bufferWhen concatMap concatMapTo exhaust exhaustMap expand groupBy map mapTo mergeMap mergeMapTo mergeScan pairwise partition pluck scan switchMap switchMapTo window windowCount windowTime windowToggle windowWhenFiltering Operators audit auditTime debounce debounceTime distinct distinctKey distinctUntilChanged distinctUntilKeyChanged elementAt filter first ignoreElements last sample sampleTime single skip skipLast skipUntil skipWhile take takeLast takeUntil takeWhile throttle throttleTimeJoin OperatorsAlso see the Join Creation Operators section above. combineAll concatAll exhaust mergeAll startWith withLatestFromMulticasting Operators multicast publish publishBehavior publishLast publishReplay shareError Handling Operators catchError retry retryWhenUtility Operators tap delay delayWhen dematerialize materialize observeOn subscribeOn timeInterval timestamp timeout timeoutWith toArrayConditional and Boolean Operators defaultIfEmpty every find findIndex isEmptyMathematical and Aggregate Operators count max min reduce커스텀 연산자 만들기pipe() 함수로 새로운 연산자 만들기만약 흔히 사용되는 연산자들의 시퀀스가 있다면, pipe() 함수를 이용해서 그 시퀀스를 하나의 연산자로 추출할 수 있습니다. 만약 시퀀스가 흔하지 않더라도, 하나의 연산자로 바꾸는 것은 가독성을 개선시킬 수 있습니다.예를들어, 아래와 같이 홀수를 버리고 짝수를 2배하는 함수를 만들 수 있습니다:import { pipe } from 'rxjs';import { filter, map } from 'rxjs/operators';function discardOddDoubleEven() { return pipe( filter(v =&gt; ! (v % 2)), map(v =&gt; v + v), );}(pipe() 함수는 Observable의 .pipe() 메소드와 유사하지만 같지는 않습니다.)scratch로 새로운 연산자 만들기더 복잡하지만, 기존 연산자의 조합으로 만들 수없는 연산자를 작성해야하는 경우(드물게 발생하지만…) 아래와 같이 Observable 생성자를 사용하여 처음부터 연산자를 작성할 수 있습니다:import { Observable } from 'rxjs';function delay(delayInMillis) { return (observable) =&gt; new Observable(observer =&gt; { // this function will called each time this // Observable is subscribed to. const allTimerIDs = new Set(); const subscription = observable.subscribe({ next(value) { const timerID = setTimeout(() =&gt; { observer.next(value); allTimerIDs.delete(timerID); }, delayInMillis); allTimerIDs.add(timerID); }, error(err) { observer.error(err); }, complete() { observer.complete(); } }); // the return value is the teardown function, // which will be invoked when the new // Observable is unsubscribed from. return () =&gt; { subscription.unsubscribe(); allTimerIDs.forEach(timerID =&gt; { clearTimeout(timerID); }); } });}Note that you must 입력 Observable을 구독할 때, 세 가지 관찰자 함수 next(), error(), complete()를 모두 구현해야 합니다. Observable이 끝났을 때 정리하는(이 경우에는 구독 취소하고 timeout 초기화) “해체(teardown)” 함수를 구현해야 합니다. Observable 생성자에 전달된 함수에서 해체함수(teardown function)를 반환합니다.물론, 이는 한 예시일 뿐입니다. delay() 연산자는 이미 있습니다." }, { "title": "[Javascript] RxJS - Observer", "url": "/posts/js-rxjs-observer/", "categories": "Javascript", "tags": "javascript, rxjs, observer", "date": "2020-07-06 10:51:00 +0800", "snippet": "https://rxjs.dev/guide/observer 번역오역 부분이나 조언(?)은 알려주시면 감사하겠습니다.Observer관찰자(Observer)란 무엇인가? 관찰자는 Observable에서 전달된 값들의 소비자입니다. 관찰자들은 간단히 Observer에서 전달하는 각각의 알림 유형들(next, error, complete)의 콜백들의 모음입니다. 아래는 전형적인 Observer 객체입니다 :const observer = { next: x =&gt; console.log('Observer got a next value: ' + x), error: err =&gt; console.error('Observer got an error: ' + err), complete: () =&gt; console.log('Observer got a complete notification'),};관찰자(Observer)를 사용하기 위해서는, Observable 구독시에 인자로 제공해야 합니다.observable.subscribe(observer); 관찰자는 그저 Observer에서 전달하는 각각의 알림 유형들(next, error, complete) 3개의 콜백들을 가진 객체입니다.RxJS에서의 관찰자는 부분적일수도 있습니다. 만약 저 콜백중 하나를 제공하지 않는다면, Observable의 실행은 일반적일 것입니다. 콜백 중 하나를 제공하지 않으면 Observable의 실행은 여전히 ​​정상적으로 발생하지만 일부 유형의 알림은 관찰자(Observer)에 해당 콜백이 없기 때문에 무시됩니다.아래의 예제는 complete 콜백이 없는 관찰자입니다 :const observer = { next: x =&gt; console.log('Observer got a next value: ' + x), error: err =&gt; console.error('Observer got an error: ' + err),};Observable을 구독할 때, 콜백들을 관찰자 객체에 붙어있지 않은 상태로 인자로 넘길수도 있습니다. 예를 들면 아래와 같습니다 :observable.subscribe(x =&gt; console.log('Observer got a next value: ' + x));내부적으로 observable.subscribe에서 첫 번째 콜백 인수를 다음 핸들러로 사용하여 Observer 객체를 만듭니다. 세 가지 유형의 콜백이 모두 인수로 제공 될 수 있습니다 :observable.subscribe( x =&gt; console.log('Observer got a next value: ' + x), err =&gt; console.error('Observer got an error: ' + err), () =&gt; console.log('Observer got a complete notification'));" }, { "title": "[Javascript] RxJS - Observable", "url": "/posts/js-rxjs-observable/", "categories": "Javascript", "tags": "javascript, rxjs, observable", "date": "2020-07-04 21:03:00 +0800", "snippet": "https://rxjs.dev/guide/observable 번역오역 부분이나 조언(?)은 알려주시면 감사하겠습니다.ObservableObservable은 여러 값의 지연푸시 모음입니다. 그들은 다음 표에서 누락된 자리를 채웁니다.   SINGLE MULTIPLE   Pull Function Iterator   Push Promise Observable 예제. 아래 예제는 구독(subscribe)됐을 때, 동기적으로 값 1,2,3을 즉시 넣고, 1초 뒤에 4를 넣고 끝내는 Observable입니다.import { Observable } from 'rxjs';const observable = new Observable(subscriber =&gt; { subscriber.next(1); subscriber.next(2); subscriber.next(3); setTimeout(() =&gt; { subscriber.next(4); subscriber.complete(); }, 1000);});Observable을 호출하고 값들을 보기위해서는 구독(subscribe) 해야합니다.import { Observable } from 'rxjs';const observable = new Observable(subscriber =&gt; { subscriber.next(1); subscriber.next(2); subscriber.next(3); setTimeout(() =&gt; { subscriber.next(4); subscriber.complete(); }, 1000);});console.log('just before subscribe');observable.subscribe({ next(x) { console.log('got value ' + x); }, error(err) { console.error('something wrong occurred: ' + err); }, complete() { console.log('done'); }});console.log('just after subscribe');위 실행 결과는 다음과 같습니다.just before subscribegot value 1got value 2got value 3just after subscribegot value 4donePull versus PushPull과 Push는 두개의 다른 프로토콜입니다. 이는 데이터 생산자가 데이터 소비자와 어떻게 소통하는지를 나타냅니다.Pull이란? Pull 시스템에서는, 소비자가 생산자로부터 데이터를 언제 받을지 결정합니다. 생산자는 언제 소비자한테 전달될지 모릅니다.모든 JavaScript 함수는 Pull 시스템입니다. 함수는 데이터 생산자이고, 그 함수를 부르는 코드는 함수의 리턴값을 pull 해서 소비합니다.ES2015는 다른 Pull 시스템인, generator functions and iterators (function*) 를 소개했습니다. iterator.next()를 호출하는 코드가 소비자입니다. iterator(생산자)로부터 여러 값들을 가져옵니다(pulling).   PRODUCER **CONSUMER** Pull Passive: 요청이 있을때 데이터 생성 Active: 언제 데이터를 요청할지 정함 Push Active: 자신의 페이스대로 데이터 생성 Passive: 받은 데이터에 반응 Push란? Push 시스템에서는, 생산자가 소비자에게 언제 데이터를 보낼지 결정합니다. 소비자는 언제 데이터를 받게 될지 모릅니다.오늘날 JavaScript에서, Promise들은 가장 평범한 타입의 Push 시스템입니다. Promise(생산자)는 resolve된 값을 등록된 콜백들(소비자)로 전달합니다. 하지만 함수들과 다르게, 해당 값이 콜백에 “밀어 질 때”를 정확하게 결정합니다.RxJS는 JavaScript를 위한 새로운 Push 시스템인 Observables를 소개합니다. Observable은 여러 값들의 생산자입니다. Observers(소비자들)에게 그 값들을 보냅니다(Pushing). Function은 호출시에 동기적으로 한개의 값을 리턴하는 지연 계산(lazily evaluated computation)입니다. generator는 iteration시에 동기적으로 0개부터 무한대까지의 값들을 리턴하는 지연 계산입니다. Promise는 단일 값을 반환하거나 반환하지 않을 수 있는 계산입니다. Observable은 호출된 이후로부터 동기적이거나 비동기적으로 0개부터 무한대가지의 값들을 리턴하는 지연계산입니다.Observables as generalizations of functions대중적인 주장과 달리, Obervable들은 EventEmitter와 같지 않으며 여러 값에 대한 Promise들과도 같지 않습니다. Observable들은 몇몇 경우에 EventEmitter처럼 동작할 수 있습니다(RxJS Subjects를 이용해서 멀티캐스트 된 경우). 하지만, 보통은 EventEmitter 처럼 동작하지 않습니다.  Observable들은 인자가 없는 함수와 같습니다. 하지만 여러 값을 허용하도록 일반화 합니다.다음을 고려해보겠습니다:function foo() { console.log('Hello'); return 42;}const x = foo.call(); // same as foo()console.log(x);const y = foo.call(); // same as foo()console.log(y);아래와 같은 결과를 예상할 수 있습니다.\"Hello\"42\"Hello\"42같은 동작을 Observable을 이용해보겠습니다.import { Observable } from 'rxjs';const foo = new Observable(subscriber =&gt; { console.log('Hello'); subscriber.next(42);});foo.subscribe(x =&gt; { console.log(x);});foo.subscribe(y =&gt; { console.log(y);});그리고 결과도 같습니다.\"Hello\"42\"Hello\"42이렇게 되는 이유는 Function과 Observable이 둘다 지연계산이기 때문입니다. 만약 함수를 호출하지 않는다면, console.log(‘Hello’)는 실행되지 않을 겁니다. Observable도 똑같이 호출하지 않으면 console.log(‘Hello’)는 실행되지 않습니다. 게다가, ‘calling’ 또는 ‘subscribing’은 독립된 작업입니다: 2개의 함수 호출이 두개의 별도의 부작용를 일으킵니다. 그리고 2개의 Observable 구독은 두개의 별도의 부작용을 일으킵니다. 부작용들을 공유하고 구독의 존재와 상관없이 실행하는 EventEmitter들과 달리, Observable들은 실행을 공유하지 않고 게으릅니다.Observable을 구독하는 것은 함수호출과 유사합니다.몇몇 사람들은 Observable들이 비동기적이라고 주장합니다. 하지만 그것은 사실이 아닙니다. 만약 아래와 같이 함수 호출을 log들로 감쌌을 경우:console.log('before');console.log(foo.call());console.log('after');아래와 같은 결과를 볼 수 있습니다. \"before\"\"Hello\"42\"after\"그리고 이것은 Observable로도 똑같이 동작합니다.console.log('before');foo.subscribe(x =&gt; { console.log(x);});console.log('after');결과:\"before\"\"Hello\"42\"after\"이것은 foo의 subscription이 함수처럼 완전히 동기적이라는 것을 증명합니다.Obervable들은 동기적으로나 비동기적으로 값들을 전달할 수 있습니다. 그러면 Observable과 함수와의 차이점은 무엇일까? Observable은 시간이 지남에 따라 여러 값들을 리턴할 수 있습니다. 이는 함수에서는 불가능합니다. 아래처럼 할 수 없습니다:function foo() { console.log('Hello'); return 42; return 100; // dead code. will never happen}함수는 한 값만 리턴할 수 있습니다. 하지만 Observable은 이렇게 할 수 있습니다:import { Observable } from 'rxjs';const foo = new Observable(subscriber =&gt; { console.log('Hello'); subscriber.next(42); subscriber.next(100); // \"return\" another value subscriber.next(200); // \"return\" yet another});console.log('before');foo.subscribe(x =&gt; { console.log(x);});console.log('after');동기적 결과:\"before\"\"Hello\"42100200\"after\"비동기적으로도 리턴할 수 있습니다:import { Observable } from 'rxjs';const foo = new Observable(subscriber =&gt; { console.log('Hello'); subscriber.next(42); subscriber.next(100); subscriber.next(200); setTimeout(() =&gt; { subscriber.next(300); // happens asynchronously }, 1000);});console.log('before');foo.subscribe(x =&gt; { console.log(x);});console.log('after');결과:\"before\"\"Hello\"42100200\"after\"300결론: func.call()은 “동기적으로 한개의 값을 줘”를 의미합니다. observable.subscribe()는 “동기적으로든, 비동기적으로든, 값이 몇개가 됐든 줘”를 의미합니다.Anatomy of an Observable (Observable 해부)Observable들은 new Observable이나 생성자를 통해 생성됩니다. Observer에 의해 구독됩니다. Observer에게 next / error/ complete 알림들을 전달하는 작업을 수행합니다. 그리고 그들의 수행은 처분될 수 있습니다. 이 4가지 양상은 모두 Observable 인스턴스로 인코딩 됩니다. 하지만 몇 가지 양상은 다른 타입들(Observer, Subscription)과 연관되있습니다.Observable의 핵심 관심사: 생성(Creating) Observables 구독(Subscribing) to Observables 수행(Executing) the Observable 처분(Disposing) ObservablesCreating ObservablesObservable 생성자는 한개의 인자(구독 함수)를 받습니다.아래의 예제는 관찰자(Observer)에게 매초마다 ‘hi’를 보내는 Observable을 생성합니다.import { Observable } from 'rxjs';const observable = new Observable(function subscribe(subscriber) { const id = setInterval(() =&gt; { subscriber.next('hi') }, 1000);}); Observable들은 new Observable 로 생성할 수 있습니다. 가장 흔하게, Observable들은 생성함수(of, from, interval 등)를 통해 생성됩니다.위 예제에서, 구독 함수는 Observable을 설명하는 가장 중요한 부분입니다. 구독하는 것이 무엇을 의미하는지 보도록 하겠습니다.Subscribing to Observables예제 속의 observable은 아래와 같이 구독될 수 있습니다.observable.subscribe(x =&gt; console.log(x));observable.subscribe와 new Observable(function subscribe(subscriber){…}의 subscribe가 같은 이름을 가지고 있는 것은 우연의 일치가 아닙니다. 둘은 다르지만, 실용적인 목적에서 개념적으로 동일하게 볼 수 있습니다.이는 같은 Observable의 여러 Observer들 사이에서 어떻게 구독 호출이 공유되지 않는지 보여줍니다. Observer에서 observable.subscribe를 호출할 때, new Observable(function subscribe(subscriber){…} 속의 subscribe 함수가 주어진 관찰자를 위해 실행됩니다. obervable.subscribe 각각의 호출은 해당 관찰자에 대해 독립적인 셋업을 발생시킵니다. Observable을 구독하는 것은 함수를 호출하는 것과 같습니다. 데이터가 전달되는 콜백을 제공합니다.Executing Observablesnew Observable(function subscribe(subscriber) {…}) 속의 코드는 “Observable 실행”(각 관찰자들이 구독할때만 일어나는 지연 계산)을 나타냅니다. 실행은 동기적이거나 비동기적으로 여러 값을 생성합니다.Observable 실행에 세 가지 유형의 값이 있습니다 : “Next” notification: 숫자, 문자열, 객체 등과 같은 값을 보냅니다. “Error” notification: Javascript 에러나 예외를 보냅니다. “Complete” notification: 값을 보내지 않습니다.“Next” notifications는 가장 중요하고 가장 일반적인 타입입니다. 이는 관찰자에게 전달되는 실제 데이터를 나타냅니다. “Error”와 “Complete” notifications는 Observable 실행동안 한번만 일어날 수 있습니다. 그리고 둘 중 하나만 수행될 수 있습니다.이런 제약들은 정규식으로 표현된, 이른바 Observable 문법이나 규칙에 제일 잘 표현되어있습니다 : next*(error|complete)? Observable 실행에서, 0 ~ 무한대의 Next notification이 전달될 수 있습니다. 만약 Error나 Complete notification이 전달된다면, 이후에는 아무것도 전달되지 않습니다.아래는 3개의 Next notification을 전달하고 complete 하는 예제입니다 : import { Observable } from 'rxjs';const observable = new Observable(function subscribe(subscriber) { subscriber.next(1); subscriber.next(2); subscriber.next(3); subscriber.complete();});Observables는 엄격하게 Observable 규칙을 엄격히 지킵니다. 그렇기에 아래의 코드는 ‘4’를 전달하지 않습니다 :import { Observable } from 'rxjs';const observable = new Observable(function subscribe(subscriber) { subscriber.next(1); subscriber.next(2); subscriber.next(3); subscriber.complete(); subscriber.next(4); // Is not delivered because it would violate the contract});subscribe안의 코드들을 try/catch문으로 감싸는 것은 좋은 생각입니다. 이는 에러 발생시, Error notification을 전달할 수  것입니다 :import { Observable } from 'rxjs';const observable = new Observable(function subscribe(subscriber) { try { subscriber.next(1); subscriber.next(2); subscriber.next(3); subscriber.complete(); } catch (err) { subscriber.error(err); // delivers an error if it caught one }});Disposing Observable ExecutionsObservable의 수행은 무한하고 관찰자가 유한한 시간내에 실행을 중단하려 하는 것이 일반적이기 때문에, 실행을 취소할 수 있는 API가 필요합니다. 각 실행은 하나의 관찰자에게만 독점되므로, 계산능력을 낭비하거나 메모리 낭비를 피하기 위해 관찰자가 값을 다 받으면 실행을 중지할 방법이 있어야 합니다.observable.subscribe가 호출될 때, 관찰자는 새로 생성 된 Observable 실행에 연결됩니다. 이 호출은 또한 Subscription 객체를 리턴합니다 :const subscription = observable.subscribe(x =&gt; console.log(x));이 Subscription은 진행중인 실행을 나타냅니다. 그리고 실행을 취소할 수 있는 최소한의 API를 가집니다. 자세한 것은 여기에서 Subscription Type에 대해 읽어보세요. subscription.unsubscribe()로 실행을 중단할 수 있습니다 :import { from } from 'rxjs';const observable = from([10, 20, 30]);const subscription = observable.subscribe(x =&gt; console.log(x));// Later:subscription.unsubscribe(); 구독 했을 때, Subscription을 돌려받을 수 있습니다. 이는 진행중인 실행을 나타냅니다. unsubscribe()만 호출하면 실행을 중단할 수 있습니다.각 Observable은 create()를 사용하여 Observable을 만들 때 해당 실행 리소스를 처리하는 방법을 무조건 정의해야합니다. subscribe() 함수 내에서 사용자 지정 구독 취소 함수를 반환할 수도 있습니다.예를 들어, 이것은 setInterval을 clear 하는 방법입니다 :const observable = new Observable(function subscribe(subscriber) { // Keep track of the interval resource const intervalId = setInterval(() =&gt; { subscriber.next('hi'); }, 1000); // Provide a way of canceling and disposing the interval resource return function unsubscribe() { clearInterval(intervalId); };});observable.subscribe가 new Observable(function subscribe() {…})와 닮은 것처럼, subscribe에서 리턴한 unsubscribe는 개념적으로 subscribe.unsubscribe와 동일합니다. 실제로 이러한 개념을 둘러싼 ReactiveX 유형을 제거하면 다소 간단한 JavaScript가 남아 있습니다.function subscribe(subscriber) { const intervalId = setInterval(() =&gt; { subscriber.next('hi'); }, 1000); return function unsubscribe() { clearInterval(intervalId); };}const unsubscribe = subscribe({next: (x) =&gt; console.log(x)});// Later:unsubscribe(); // dispose the resourcesObservable, Observer, Subscription 과 같은 Rx 타입들을 사용하는 이유는 안전(Observable 규칙 같은)과 연산들의 조합 때문입니다." }, { "title": "[Javascript] RxJS - Overview 번역", "url": "/posts/js-rxjs-overview/", "categories": "Javascript", "tags": "javascript, rxjs", "date": "2020-07-01 19:47:00 +0800", "snippet": "Observable 객체를 다루는데 필수(?)적인 RxJS!!rxjs 공식사이트 번역을 해봤습니다. ( https://rxjs.dev/guide/overview )기분탓인지 모르겠지만 다른 개발문서들보다 어렵게(?) 쓰여있는거 같아서 의역도 좀 포함되어있습니다.그렇지만.. 영어 실력이 부족해 오역이 있을 수 있습니다. (발견시, 알려주시면 감사하겠습니다.)소개RxJS는 Observable 시퀀스를 사용하여 비동기 및 이벤트 기반 프로그램을 작성하기위한 라이브러리입니다. Observable, 위성 타입(Observer, Scheduler, Subjects), 그리고 Array#extras (map, filter, reduce, every 등)의 연산자, 이 셋 중 하나의 핵심 유형을 제공하여 비동기 이벤트를 콜렉션으로 처리 할 수 ​​있도록 해줍니다. RxJS를 이벤트의 Lodash 정도로 생각하시면 됩니다.ReactiveX는 Observer 패턴과 Iterator 패턴, 그리고 일련의 이벤트를 관리하는 이상적인 방법에 대한 요구를 충족시키기 위해 컬렉션을 갖춘 함수형 프로그래밍을 결합했습니다.비동기 이벤트 관리를 해결하는 RxJS의 필수 개념은 다음과 같습니다: Observable: 호출할 수 있는 컬렉션(미래의 값이나 events)의 idea를 나타냅니다. Observer: Observable이 전달한 값을 듣는 방법을 알고있는 콜백 모음입니다. Subscription: Observable의 실행을 나타내며 주로 실행 취소에 유용합니다. Operators: 함수형 프로그래밍 스타일을 가능하게하는 순수 함수들입니다. map, filter, concat, reduce 등과 같은 함수들을 다룹니다. Subject: EventEmitter와 동일하며 value나 event를 여러 Observer에게 멀티 캐스팅하는 유일한 방법입니다. Schedulers: 동시성을 제어하기위한 중앙 집중식 디스패처로, setTimeout, requestAnimationFrame 등의 계산이 수행되는 시점을 조정할 수 있습니다.첫 예제이벤트 리스너를 등록합니다.document.addEventListener('click', () =&gt; console.log('Clicked!'));RxJS를 이용해서 observable 객체를 생성합니다.import { fromEvent } from 'rxjs';fromEvent(document, 'click').subscribe(() =&gt; console.log('Clicked!'));PurityRxJS를 강력하게 만드는 것은 순수 함수를 사용하여 value를 창출하는 능력입니다. 즉, 코드의 오류가 적습니다.다른 부분의 코드가 state를 망칠 수 있는 비순수함수를 만듭니다.let count = 0;document.addEventListener('click', () =&gt; console.log(`Clicked ${++count} times`));RxJS를 이용하여 state를 떨어뜨립니다.import { fromEvent } from 'rxjs';import { scan } from 'rxjs/operators';fromEvent(document, 'click') .pipe(scan(count =&gt; count + 1, 0)) .subscribe(count =&gt; console.log(`Clicked ${count} times`));scan 함수는 array의 reduce 함수같은 역할을 합니다. 이는 콜백으로 넘어온 값으로 연산하고, 리턴 값은 다음 콜백의 값으로 전달됩니다.FlowRxJS는 이벤트의 흐름이 observable을 통과하는 방식을 컨트롤할 수 있게 도와주는 모든 범위의 연산자들을 가지고있습니다.아래는 초당 최대 한번의 클릭을 허용하는 코드입니다. (순수 Javascript)let count = 0;let rate = 1000;let lastClick = Date.now() - rate;document.addEventListener('click', () =&gt; { if (Date.now() - lastClick &gt;= rate) { console.log(`Clicked ${++count} times`); lastClick = Date.now(); }});RxJS:import { fromEvent } from 'rxjs';import { throttleTime, scan } from 'rxjs/operators';fromEvent(document, 'click') .pipe( throttleTime(1000), scan(count =&gt; count + 1, 0) ) .subscribe(count =&gt; console.log(`Clicked ${count} times`));다른 흐름제어 연산자들은  filter, delay, debounceTime, take, takeUntil, distinct, distinctUntilChanged 등이 있습니다.Valuesobservable을 통과해서 값을 바꿀 수 있습니다. 아래는 매 클릭마다 현재 마우스의 x위치를 더하는 코드입니다. (순수 Javascript)let count = 0;const rate = 1000;let lastClick = Date.now() - rate;document.addEventListener('click', event =&gt; { if (Date.now() - lastClick &gt;= rate) { count += event.clientX; console.log(count); lastClick = Date.now(); }});RxJS:import { fromEvent } from 'rxjs';import { throttleTime, map, scan } from 'rxjs/operators';fromEvent(document, 'click') .pipe( throttleTime(1000), map(event =&gt; event.clientX), scan((count, clientX) =&gt; count + clientX, 0) ) .subscribe(count =&gt; console.log(count));값을 생성하는 다른 연산자는 pluck, pairwise, sample 등이 있습니다.- RxJS - Observable- RxJS - Observer- RxJS - Operators- RxJS - Subscription- RxJS - Subjects ( …ing)- RxJS - Scheduler ( …ing)- RxJS - Testing ( …ing)" }, { "title": "script 속성 async / defer", "url": "/posts/js-async-defer/", "categories": "Javascript", "tags": "javascript, html, async, defer", "date": "2020-06-30 20:29:00 +0800", "snippet": "javascript를 불러올때, DOM이 구성되는 것을 기다리기 위해  태그 제일 아래에서 script를 가져오기도 합니다.하지만 async, defer 속성을 줘서 간편하게 이를 해결할 수 있습니다. 만약 DOM과 크게 상관이 없다거나 다른 script와의 연관성이 없다면,그리고 js파일이 작아서 DOM이 화면에 보이는 시간이 얼마 안걸린다면 굳이 저 두 속성을 넣을 필요는 없어보입니다. 이게 무슨말인지는 아래 수행 순서를 먼저 보고 오도록 하겠습니다.  방향  -----&gt; #### **\\[head안 속성X\\]**#### **\\[body맨 아래 속성X\\]**#### **\\[async\\]**#### **\\[defer\\]**정리하자면, 1\\. 속성 없을때 script를 만나면 불러오고 실행까지 시킨 후에 나머지 작업을 합니다. 위에 보이는 것처럼 head 안에 있다면 HTML 파싱이 끝나기 전에 실행해버리고, 만약 script 파일이 크다면 그만큼 로딩이 오래걸립니다.(요즘은 워낙 사양이 좋아서 크게 상관은 없어보입니다만 미세한 차이라도...)2\\. async는 HTML파싱과 병렬적으로 동작하나, script를 다 가져왔다면 HTML 파싱을 멈추고 즉시 수행합니다.즉시 수행하는 만큼, 만약 script가 여러 개이고, feching 속도가 다르다면, 수행 순서가 뒤죽박죽이 될 수 있습니다. 그렇기에 이를 고려해서 사용해야 합니다.3\\. defer는 async처럼 병렬로 동작하나, 파싱 후에 작업을 수행합니다. 파싱이 다 끝난뒤 실행되기에, 수행 순서가 중요하다면 특히나 defer를 활용해야겠습니다. 그리고 module 타입의 경우는 기본적으로 지연 로딩이 적용되서 굳이 defer 속성은 넣을 필요가 없습니다.script의 DOM과의 연관성, 타 script와의 종속성, 화면 Load 시간등 여러 요소를 고려해서 적절히 옵션을 써주면 되지만기본적으로 head에서 defer 옵션을 쓰면 되지 않을까 싶습니다." }, { "title": "Safari에서 유튜브 재생 문제 (저작권 ...)", "url": "/posts/youtube-copyright/", "categories": "ISSUE", "tags": "issue, youtube, copyright, ios", "date": "2020-06-29 18:59:00 +0800", "snippet": "ios 개발에서 웹뷰로 유튜브를 재생할 때, 그리고 로컬에서 safari에서 테스트 할때‘동영상을 재생할수 없음’ 이런 비슷한 멘트가 뜨면서 안될 때가 있습니다..어떤 영상은 잘 되는데 어떤 영상은 안됩니다.바로..! 저작권 때문인데요..아무데서나 저작권있는 영상을 재생하려 할까봐(??) 이해는 잘 안되지만 그런 문제라고 합니다.(그치만 안드로이드에서는 너무나 잘되는…)뭐 쨋든! 이를 해결할 수 있는 방법이 있습니다.여러 방법이 있을 수 있고, 이게 정답이라고는 할 수 없지만 한가지 해결책은 될 수 있을 것 같습니다.일단 문제의 원인은 localhost에 있습니다. localhost에서는 재생이 안되지만, 도메인에서 접근하면 재생이 됩니다.그래서 제가 사용한 방법은 한 다리를 거쳐 유튜브를 재생시키는 것입니다.localhost -&gt; youtube (x)localhost -&gt; domain 가진 웹페이지 -&gt; youtube (ㅇ)iframe으로 웹페이지를 틀고 그 웹페이지에서 유튭을 재생시키면 아무 문제없이 재생되는 것을 보실 수 있습니다!iframe의 부모와 자식간의 통신 부분만 잘 처리해주면 바로 유튭 재생하는것과 똑같이 동작시킬 수 있습니다만,문제는 아무래도 한단계 거치다보니 로딩시간이 조큼더 걸리겠죠..?다른 더 좋은 방법이 있다면 댓글 남겨주시면 감사하겠습니다 :)" }, { "title": "[CSS] position (static, absolute, relative, sticky, fixed)", "url": "/posts/css-position/", "categories": "CSS", "tags": "css, position", "date": "2020-06-26 22:07:00 +0800", "snippet": "static absolute relative fixed 이렇게 네가지의 position이 존재합니다. 저도 어설프게는 알고 있었지만 정확히 어떻게 활용해야 하는지 매번 헷갈려서 정리해봤습니다. [static]태그들의 default 값입니다. 빈공간에 차례대로 들어가게 됩니다. 위-&gt;아래 / 왼-&gt;오 기본적으로 div 태그는 display: block이라 위-&gt;아래 입니다. 그래서 inline-block으로 일렬로~ See the Pen position-static by steadev (@steadev) on CodePen.[absolute]static이 아닌 부모를 기준으로 위치 조절이 가능합니다. 전부다 static이라면 body가 기준이 됩니다.예제에서, 두번째 박스만 absolute로 했고, 그의 부모인 container기준으로 top, left가 적용되는 것을 보실 수 있습니다. See the Pen position-absolute by steadev (@steadev) on CodePen.[relative]현재 위치를 기준으로 위치 조절이 가능해집니다. absolute와의 차이점은, absolute는 다른 태그들이 absolute인 태그의 자리를 메꿔버리지만,relative는 relative인 태그의 자리가 채워진 상태로 위치가 조절됩니다. See the Pen position-relative by steadev (@steadev) on CodePen.[fixed]화면의 절대적 위치에 고정되며, 스크롤을 해도 화면에 고정되어 있습니다.따로 top, left 등의 위치를 지정해주지 않으면 본래 위치에 고정되며, 그 자리를 주변 element가 차지합니다. See the Pen position-fixed by steadev (@steadev) on CodePen.[sticky]스크롤을 해도 화면에 고정되는 것은 fixed와 똑같지만, 지정한 높이가 올때까지는 일반 흐름에 따릅니다.그렇기 때문에 스크롤 방향에 맞게 top, bottom, right, left 중 하나는 꼭 지정해줘야 합니다. 아래 예시를 스크롤해보면 이해가 확 될 겁니다~! See the Pen position-sticky by steadev (@steadev) on CodePen." }, { "title": "[Javascript] requestAnimationFrame", "url": "/posts/js-RAF/", "categories": "Javascript", "tags": "requestAnimationFrame", "date": "2020-06-24 21:33:00 +0800", "snippet": "requestAnimationFrame은(이하 raf) 브라우저에게 수행하기를 원하는 애니메이션을 알리고 다음 리페인트가 진행되기 전에 해당 애니메이션을 업데이트하는 함수를 호출하게 합니다.이전에는 setInterval을 사용했지만, 프레임 유실이 있을 수 있고 모바일에서 배터리 절약이 안되는 문제가 있다고 합니다.raf는 초당 60번을 수행하지만, 컴퓨터 상황 등에 따라 유동적이라고 합니다. 그만큼 최적화해서 애니메이션을 부드럽게 해줄 수 있는 기술이라 애니메이션에서 매우 자주쓰이고 canvas에 많이 활용된다고 합니다.[사용방법]우선, 아래 코드처럼 재귀형식으로 활용하면 됩니다.pageYOffset은 스크롤된 값을 의미하는데, 스크롤 값만큼 left를 움직여주는 코드입니다.하지만 아래 gif처럼 스크롤 정도에 따라 조금 딱딱한 느낌이 있고무한대로 함수가 반복하게 되서 그만큼 부하가 걸릴수밖에 없습니다.function loop(){ circle.style.left = `${pageYOffset}px`; rafId = requestAnimationFrame(loop);}loop();[부드러운 액션]여기에서는 딱딱한 느낌을 없애고 스크롤이 완료되면 loop를 중지시켜보겠습니다.우선 acc는 누적치인데 이 수치 조절에 따라 부드러운 정도의 차이를 조절할 수 있습니다.delayedYOffset은 한번에 갈 스크롤위치(pageYOffset)까지 지연시켜 가는 위치를 나타냅니다.위 2개는 아래에서 다시 설명하도록 하겠습니다.rafId는 requestAnimationFrame의 id로, console을 찍어보면 숫자가 찍힙니다. 그를 바탕으로 raf를 중지시킬 수 있습니다.rafState는 중단된 상태인지 아닌지를 나타내고, false이면 중단된 것입니다.해당 부분은 아래 코드의 주석을 통해 확인 가능합니다.delay 부분을 보면, 이전 yOffset부터 현재 yOffset 까지를 1/10씩 계속 쪼개나가는 것입니다. 그러다보면 결국 현재 yOffset까지 도달하게되는 일종의 수학에서의 극한(?) 개념이라고 보면 됩니다.delayedYOffset = 0, pageYOffset = 100 이라고 했을 때, 최초의 경우부터 보도록 하겠습니다.delayedYOffset = 0 + (100 - 0) * 0.1 = 10=&gt; 10+ (100 - 10) * 0.1 = 19=&gt; 19+ (100 - 19) * 0.1 = 27.1….=&gt; 이렇게 하면 최종적으로 100까지는 아니더라도 그 근사값까지는 가겠죠??그렇기 때문에 아래 코드에서 종료 조건이 == 0 이 아니고 &lt; 1로 설정되어 있는 것입니다.let acc = 0.1;let delayedYOffset = 0;let rafId;let rafState;window.addEventListener('scroll', ()=&gt;{ // scroll 할때, raf가 중지상태이면 raf 시작 if(!rafState){ rafId = requestAnimationFrame(loop); rafState = true; }});function loop(){ // 부드러운 액션 delayedYOffset = delayedYOffset + (pageYOffset - delayedYOffset) * acc; circle.style.left = `${delayedYOffset}px`; rafId = requestAnimationFrame(loop); // delayed가 yOffset과 같아질 때 raf 중지 if(Math.abs(pageYOffset - delayedYOffset) &lt; 1){ cancelAnimationFrame(rafId); rafState = false; }}loop();아래는 전체 예시 코드 입니다. (아래 링크의 유튜브 영상에서 설명을 너무 잘해주셨습니다 감사합니다 :)&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body{ height:500vh; } .circle { position: fixed; margin-top:30vh; background: orange; width:50px; height:50px; left:0px; right:0; border-radius: 50%; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"circle\"&gt;&lt;/div&gt; &lt;script&gt; const circle = document.querySelector('.circle'); let acc = 0.1; let delayedYOffset = 0; let rafId; let rafState; window.addEventListener('scroll', ()=&gt;{ if(!rafState){ rafId = requestAnimationFrame(loop); rafState = true; } }); function loop(){ // 부드러운 액션 delayedYOffset = delayedYOffset + (pageYOffset - delayedYOffset) * acc; circle.style.left = `${delayedYOffset}px`; // 딱딱한(?) 액션 // circle.style.left = `${pageYOffset}px`; rafId = requestAnimationFrame(loop); console.log('loop'); if(Math.abs(pageYOffset - delayedYOffset) &lt; 1){ console.log('done') cancelAnimationFrame(rafId); rafState = false; } } loop(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;ref) mozilla DOC1분코딩 requestAnimationFrame 사용법" }, { "title": "[Angular] Lazy-loading", "url": "/posts/angular-lazy-loading/", "categories": "Angular", "tags": "angular, lazy loading", "date": "2020-06-20 11:33:00 +0800", "snippet": "SPA의 대표적인 단점이 초기 구동시간이 오래걸린다는 점입니다. 이를 보완하기 위한 방법이 Lazy Loading입니다.기능모듈들을 초기에 로드하지 않고 요청이 있을 때 로드하는 방법입니다. 아래는 앵귤러 공식 사이트에서의 예제를 작성한 코드입니다.https://github.com/steadev/angular-lazyloading-testing-appLazy loading을 하는 방법은 라우팅 객체의 loadChildren 안에서 모듈을 import 합니다. app routing module에서 아래와 같이 customers, orders의 라우팅 설정을 해놓고 customer 버튼을 눌렀을 시, localhost:4200/customers로 라우팅이 되면서 customer 모듈을 import 하는 방식입니다.import { NgModule } from '@angular/core';import { Routes, RouterModule } from '@angular/router';const routes: Routes = [ { path: 'customers', loadChildren: () =&gt; import('./customers/customers.module').then((m) =&gt; m.CustomersModule), }, { path: 'orders', loadChildren: () =&gt; import('./orders/orders.module').then((m) =&gt; m.OrdersModule), }, { path: '', redirectTo: '', pathMatch: 'full', },];@NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule],})export class AppRoutingModule {}우선 첫 구동시의 네트워크 상태 입니다. 차례대로 차이점을 봐보도록 하겠습니다.1. 기능모듈( Customers, Orders )을 전부 초기 구동때 로드2. 기능모듈 요청시에 로드 1번의 경우는 모듈이 이미 전부 로드된 상태이기 때문에 customers 버튼을 눌러도 네트워크에 아무 반응이 없습니다. 새로 로드할 필요가 없기 때문이죠.2번의 경우는 처음 버튼을 눌렀을 경우에 Customers 모듈을 가져오고 그 이후에는 이미 가져왔기에 눌러도 네트워크에는 반응이 없습니다. ref) https://angular.io/guide/lazy-loading-ngmodules" }, { "title": "[CSS] 단위 (rem/em, vh/vw, vmin/vmax)", "url": "/posts/css-unit/", "categories": "CSS", "tags": "css, array", "date": "2020-06-19 17:28:00 +0800", "snippet": "제목에서의 단위 말고도 많은 것들이 있지만, 반응형을 생각했을때 가장 많이 쓰이고 중요하다 생각되는 것만 담아봤습니다. 아래 베이스 코드로 진행하도록 하겠습니다./* --- HTML --- */&lt;body&gt; &lt;div class=\"item\"&gt;&lt;/div&gt;&lt;/body&gt;/* --- CSS --- */html { font-size: 16px;}.item { background-color: lightcoral;}[ rem과 em ]1rem - 최상위 태그의 font-size (r = root)1em  - 현재 태그의 font-size최상위의 font-size: 16px 이라고 가정하고 예를 들어보겠습니다. .item { font-size: 2rem; height: 5em; width: 10em;}font-size –&gt; 16 * 2 = 32     (root의 font-size * 2)width     –&gt; 32 * 10 = 320  (현재 태그의 font-size * 10)height    –&gt; 32 * 5 = 160    (현재 태그의 font-size * 5)[ vh와 vw ]viewport width, viewport height로, 화면의 너비와 높이의 전체 길이를 기준으로 100등분 한 단위입니다.만약 화면의 너비가 1000px, 높이가 900px 이라면,1vw = 10px,    5vw = 50px9vh = 81px,    15vh = 135px이런식으로 계산됩니다.[ vmin / vmax]뷰포트의 너비와 높이의 최대, 최소값을 의미합니다. 너비가 1000px, 높이가 900px이라면, 1vmin = 9px1vmax = 10px이렇게 계산됩니다. 너비와 높이 상관없이 둘중 최소값, 최대값을 구하는 것입니다. 이것은 예를들면, 화면 사이즈에 따라 크기가 변화하는 정사각형을 만들때 유용합니다..item { height: 50vmin; width: 50vmin;}" }, { "title": "[Javascript] 배열 다루기(map, filter, find, every, some, reduce, forEach)", "url": "/posts/js-array/", "categories": "Javascript", "tags": "javascript, array", "date": "2020-06-17 19:18:00 +0800", "snippet": "Javascript에서 참 유용하게 사용할 수 있는 배열 함수들 입니다. 처음 접했을 때는 뭔가 사용법도 어려워 보이고 복잡해보였지만… 알고나면 이렇게 편할수가 없는..!![map]map은 말 그대로 매핑 시켜준다고 생각하면 편합니다. 배열의 원소들을 입맛에 맞게 바꿔줄 수 있습니다. 배열을 loop 돌면서 바꿔줍니다.간단한 예로 1~10까지의 배열이 있고 1을 더해주는 코드 입니다.하지만 저렇게 한다고 arr 변수가 바뀌는 것은 아니므로 주의해야 합니다.let arr = [1,2,3,4,5,6,7,8,9,10];arr.map(item =&gt; item + 1);&gt; 결과조금 더 복잡한 경우를 본다면 각 원소와 함께 인덱스도 가져올 수 있습니다. 그리고 단순 연산이 아닌, 다른 형태로도 바꿀 수 있습니다. 아래에서는 json 형태로 바꿔보았습니다.arr.map((item,index)=&gt;{ return { \"number\":item, \"idx\":index }});&gt; 결과[filter]말 그대로 필터링 해주는 함수 입니다. 결과가 true라면 해당 원소는 살아남습니다.arr.filter(item =&gt; item&gt;5);&gt; 결과조금 더 복잡(?)하게 해서 3으로 나눠지는 수만 찾는다 했을때, inline으로도 되지만 if문을 사용해 보겠습니다. arr.filter(item=&gt;{ if(item % 3 === 0) return true;});&gt; 결과[find]찾고자 하는 값이 해당 배열에 있을 경우 그 값이 있는 원소를, 없을 경우는 undefined를 리턴합니다.그렇기 때문에 주로 배열에 값이 있는지 없는지만 확인하는 용도로 많이 활용됩니다.arr.find(item =&gt; item == 1);arr.find(item =&gt; item == 0);&gt; 결과[every]배열의 모든 원소가 해당 조건에 맞는지를 확인합니다. 맞으면 true, 아니면 false 리턴.arr.every(item =&gt; item &gt; 1);arr.every(item =&gt; item &gt; 0);&gt; 결과[some]배열의 일부 원소가 해당 조건에 맞는지를 확인합니다. 맞으면 true, 아니면 false 리턴.arr.some(item =&gt; item &lt; 1);arr.some(item =&gt; item &lt; 2);&gt; 결과[reduce]배열을 하나의 값으로 변환 시켜줍니다.첫번째 인자(acc)는 누적 값(앞 원소들로 부터 return된 값),두번째 인자(item)는 각 원소들 입니다. 여기에서 주의해야 할 점은, 첫 루프에는 acc = 0번째, item = 1번째 원소가 오고, 그다음부터는 말 그대로 acc에는 누적값만 오게 됩니다. 그래서 2번째 예제를 보면 3의 배수(3, 6, 9)를 더해서 18이 나올 것 같지만첫 acc는 0번째 원소인 1이기에 1 + 3 + 6 + 9  = 19가 나오게 됩니다.arr.reduce((acc, item) =&gt; {\treturn acc + item;});arr.reduce((acc, item) =&gt; {\tif(item % 3 === 0) \tacc += item; return acc;});[forEach]for문과 매우 유사합니다. 원소들을 순차적으로 접근합니다. 하지만 for문과 다른 점은 forEach 안에서 원소 값을 수정해도 forEach가 끝나면 수정된 것이 적용되지 않습니다.arr.forEach(item =&gt; {\titem += 3;});arr;" }, { "title": "[CSS] Grid", "url": "/posts/css-grid/", "categories": "CSS", "tags": "css, grid", "date": "2020-06-17 18:09:00 +0800", "snippet": "2차 배열 형태의 레이아웃 설정을 도와주는 속성입니다. bootstrap이나 프레임워크에서 제공하는 것을 주로 활용했었는데,css만으로도 충분히 그에 뒤지지 않게 해낼 수 있습니다.&lt;div class=\"item-layout\"&gt; &lt;div class=\"item\"&gt;1&lt;/div&gt; &lt;div class=\"item\"&gt;2&lt;/div&gt; &lt;div class=\"item\"&gt;3&lt;/div&gt; &lt;div class=\"item\"&gt;4&lt;/div&gt; &lt;div class=\"item\"&gt;5&lt;/div&gt; &lt;div class=\"item\"&gt;6&lt;/div&gt; &lt;div class=\"item\"&gt;7&lt;/div&gt;&lt;/div&gt;위 html을 바탕으로 테스트 했고, 아래 속성들은 item-layout에 적용했습니다.[display]display: grid;display가 grid로 되어있어야 이하 grid 관련 속성들을 이용할 수 있습니다.[grid-gap, grid-column-gap, grid-row-gap]각 column과 row 사이의 간격을 정의합니다. grid-gap은 둘 다의 간격이고 나머지는 각각 column, row의 간격입니다.[grid-template-rows, grid-template-columns]말 그대로 템플릿의 row와 col을 지정해 주는 부분입니다. 1) column, row마다 너비를 지정해 주기grid-template-columns: 100px 100px 100px 100px;grid-template-rows: 100px 150px2) 비율로 분할하기fr(fraction) 단위를 사용합니다.columns는 전체 너비를 기준으로 균등하게 배분합니다. rows는 각 item들의 높이가 1fr입니다. 아래 그림처럼 2fr을 하면 다른 아이템보다 2배의 공간을 차지합니다.grid-template-rows: 1fr 2fr;grid-template-columns: 1fr 2fr 1fr;3) 반복(repeat) 활용하기1fr 1fr 1fr 1fr 이렇게 4번 작성하는 것 말고 repeat을 활용하면 repeat(4, 1fr)로 표현이 가능합니다.grid-template-columns:repeat(2, 1fr);grid-template-rows: 1fr 1.5fr;4) minmax, auto-fit, auto-fill 반응형으로 만들 수 있는 옵션입니다.minmax는 앞은 최소값, 뒤는 최대값입니다.auto-fill은 아이템들이 전체 너비에비해 모자라면 알아서 빈공간을 그대로 남겨둡니다.(min으로 지정한 너비를 넘어서지 않습니다.)auto-fit은 모자라면 알아서 빈공간을 채웁니다.(아래 예시에서는 max(1fr)만큼 커집니다.)&gt; auto-fill&gt; auto-fit아래는 해당 코드를 적용하고 화면을 줄였을 때의 모습입니다.grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));아래는 각 item의 속성입니다.[grid-column]아래 예시처럼 repeat(4, 1fr) 일때, (1) item (2) item (3) item (4) item (5)이렇게 번호가 매겨집니다. 이 번호는 바로 아래 예제에서처럼 활용할 수 있는데, 2/4 면 2번부터 4번까지를 차지하겠다는 말입니다. 그래서 두번째 아이템이 아래 그림처럼 공간을 차지하게 됩니다.다른 방법으로는 span을 활용하면 되고 직관적입니다.그렇지만 2/4처럼 직접적으로 명시해주면 좋은점이 있습니다. row를 1로 설정해주면 column들을 겹치게 할 수도 있습니다. 이것은 2번째 예시에서 보도록 하겠습니다..item-layout{ grid-template-columns:repeat(4, 1fr); grid-template-rows:1fr 1fr;}.item:nth-child(1){ grid-row: span 2;}.item:nth-child(2){ grid-column:2/4;}.item:nth-child(5){ grid-column: span 4;}&gt; 블럭 겹치기.item:nth-child(1){ grid-column:1/3; grid-row:1;}.item:nth-child(2){ grid-column:2/4; grid-row:1;}이외에도 여러 속성들이 있지만 이정도만 활용해줘도 충분하고 나머지는 필요시 찾아가며 할 수 있다고 생각합니다.css grid doc : https://developer.mozilla.org/ko/docs/Web/CSS/CSS_Grid_Layout참조) https://heropy.blog/2019/08/17/css-grid/" }, { "title": "Git 명령어 모음", "url": "/posts/git-cli/", "categories": "Git", "tags": "Git", "date": "2020-06-16 20:29:00 +0800", "snippet": "git init.git 이라는 하위 디렉토리를 만든다. .git 디렉토리에는 저장소에 필요한 뼈대 파일(Skeleton)이 들어 있음.git config –listgit 설정 리스트git ls-files –others –exclude-standarduntracked 파일 목록 조회. (stage 전 단계의 파일들)git add . (recommend git add -p)모든 untracked 파일들을 stage 상태로 전환p 옵션을 붙이면 하나씩 차례대로 변경부분을 보여주며, staging 할건지 물어봄하지만 새로운 파일에는 적용이 안됨. 고로, 새로 프로젝트 생성했을 때는 사용못함. (staging에 대해 물어볼 때, 여러 옵션이 있지만, y/n/q 정도만 알아도 될듯 -&gt; yes/no/quit)* git add시에 아래와 같은 에러가 발생할 수 있습니다.  warning: LF will be replaced by CRLF in some/file.file. The file will have its original line endings in your working directory.whitespace에러로, 한 줄의 끝이 유닉스 시스템은 LF(Line Feed), 윈도우는 CRLF(CR(Carriage Return), LF)로 이루어지기에 이 부분이 혼동되어 발생하는 에러입니다. 해결방법은 core.autocrlf 기능을 키면 됩니다. window : git config –global core.autocrlf truelinux     : git config –global core.autocrlf true input자세한 사항은 아래 블로그에서 확인하실수 있습니다.ref) https://blog.jaeyoon.io/2018/01/git-crlf.htmlgit commit -m ‘commit name’stage 상태의 파일들을 commit 하기git remote add origin git_url원격 저장소 연결하기git push origin branch_name해당 브랜치를 연결된 원격 저장소에 올리기git pull origin branch_name해당 브랜치 가져와서 merge하기git clone git_url해당 url의 repository를 복제한다.git branch branch_name브랜치 생성하기git checkout branch_name해당 브랜치로 바꾸기git checkout -b branch_name브랜치 생성 후 생성된 브랜치로 이동git config –global user.name “GilDong Hong”git config –global user.email “google@gmail.com”사용자 정보 설정하기git stash커밋하기엔 작업이 안끝났고, 다른 브랜치로는 넘어가야겠을 때 사용!" }, { "title": "[CSS] stroke-dasharray, stroke-dashoffset 활용하여 animation 만들기", "url": "/posts/css-stroke-dash/", "categories": "CSS", "tags": "css, stroke-dasharray, stroke-dashoffset", "date": "2020-06-12 15:48:00 +0800", "snippet": "stroke-dasharray와 stroke-dashoffset은 svg를 가지고 animation을 만드는데 활용되곤 합니다.여기서 다뤄볼 것은 css로만 하는 방법과 javascript로 하는 방법입니다.먼저, stroke-dasharray와 stroke-dashoffset에 대한 개념부터 확인하고 가겠습니다.- stroke-dasharray는 점선을 만들어주는 놈이고- stroke-dashoffset은 어디부터 시작할 것인지 정해주는 놈입니다.  위 circle을 예로 봐보겠습니다.원의 전체 길이(둘레)는 1359.7597… 입니다. 그리고 시작점은 시계방향 90도 지점부터 입니다.그리고 이 원은 stroke-dasharray: 100 입니다.그러므로 dasharray 값은 점선을 만드는 간격을 의미하고 그 간격대로 점선을 만들어주는 것입니다. 사이 간격을 따로 설정할 수도 있는데, 위 원은 stroke-dasharray: 100 20 으로 설정되었습니다. 뒤의 숫자(20)가 점선의 간격을 의미합니다.이 원은 stroke-dasharray: 100, stroke-dashoffset: 100 입니다.offset이 시작점을 정해주는 것이므로, 100만큼 띄운 이후에 100씩 간격을 두고 점선을 만듭니다.그래서 두번째 원과 비교해보면 흰 부분과 파란부분이 뒤바뀌어 있는 것을 볼 수 있습니다.그래서, 이것을 가지고 어떻게 animation을 만드는지 봐보겠습니다.1. css로 animation 만들기dasharray를 원 둘레로 설정해놓고 animation 속성을 적용하면 끝입니다.샘플 코드에서는 offset을 둘레의 2배로 설정해두어 animation이 끊기지 않도록 했습니다.아래는 관련 코드입니다.&lt;head&gt; &lt;style&gt; .moving-outline circle { stroke-dasharray: 1360; animation: dash 2s linear infinite; } @keyframes dash { to { stroke-dashoffset: 2720; } } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;svg class=\"moving-outline\" width=\"453\" height=\"453\" viewBox=\"0 0 453 453\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" &gt; &lt;circle cx=\"226.5\" cy=\"226.5\" r=\"216.5\" stroke=\"#018EBA\" stroke-width=\"20\" /&gt; &lt;/svg&gt;&lt;/body&gt;2. js로 animation 만들기원리는 간단합니다. dasharray를 원 전체의 둘레로 해놓고 offset을 전체부터 시작해서 조금씩 줄여가는 것입니다. dasharray를 설정해놓지 않으면 offset이 먹히지 않습니다. 1) 원 둘레 구하기2) dasharray를 원 둘레로 설정3) 시간 흐름에 따라 dashoffset 값 늘리기(코드에서는 10ms 마다)아래는 관련 코드입니다. &lt;body&gt; &lt;svg class=\"moving-outline\" width=\"453\" height=\"453\" viewBox=\"0 0 453 453\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"&gt; &lt;circle cx=\"226.5\" cy=\"226.5\" r=\"216.5\" stroke=\"#018EBA\" stroke-width=\"20\"/&gt; &lt;/svg&gt; &lt;script&gt; const outline = document.querySelector(\".moving-outline circle\"); const outlineLength = outline.getTotalLength(); outline.style.strokeDasharray = outlineLength; outline.style.strokeDashoffset = 0; let duration = 60; let elapsed = 0; animate(elapsed); function animate(offset) { setTimeout(() =&gt; { elapsed++; if (elapsed &gt; duration * 2) elapsed = 0; animate((elapsed / duration) * outlineLength); }, 10); outline.style.strokeDashoffset = offset; } &lt;/script&gt;&lt;/body&gt;" }, { "title": "Github readme.md에 이미지 업로드 하기", "url": "/posts/github-image/", "categories": "Git", "tags": "Github", "date": "2020-06-12 15:42:00 +0800", "snippet": "직접적으로 readme 파일에 사진을 넣지는 못합니다. 그래서 우회(?) 하는 방법을 사용하는데, Issues로 가서, New issue를 눌러줍니다. 텍스트 편집부분에 사진을 복붙하거나 드래그 하면 github 서버에 자동으로 이미지 생성이 됩니다. 저걸 그대로 복붙해서 readme 파일에 넣어도 되고, 저 https://~ 링크 주소를 활용해서 html 형태로 작성해도 됩니다. 끝!" }, { "title": "[카카오 코딩 테스트] 좌물쇠와 열쇠", "url": "/posts/kakao-2020-first-3/", "categories": "Algorithm", "tags": "Kakao, algorithm", "date": "2020-05-08 17:53:00 +0800", "snippet": "좌물쇠와 열쇠 문제 보기3번 자물쇠와 열쇠 문제입니다.은근 머리가 복잡해지는 문제였습니다. 단순히 생각하면 다 해보면 되는 문제지만.. 2D array를 90도 회전시키고 옆으로 아래로 이동시키는 부분들이 한군데만 오류가 있어도 찾기가 힘들어서 실제 시험이었다면 저는 시간상 패스했을 것 같습니다.풀이 과정은 아래 두가지만 하면 됩니다.1) 총 4번 반복(90도씩 회전)2) Lock의 3배가 되는 배열을 생성하고 Lock을 센터에 위치. key를 한칸씩 옮기면서 맞는지 체크 (key가 Lock을 벗어나도 되기 때문에 이를 고려하기 위해 3배 배열 생성)하지만 2번이 은근.. 생각보다 힘들었네요 ㅠㅠ아래는 풀이한 코드입니다.#include &lt;iostream&gt;#include &lt;vector&gt; using namespace std; void rotate(vector&lt;vector&lt;int&gt;&gt; &amp;key) { int n = key.size(); vector&lt;vector&lt;int&gt;&gt; tmp(n,vector&lt;int&gt;(n)); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { tmp[i][j] = key[n - 1 - j][i]; } } for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { key[i][j] = tmp[i][j]; } }} bool solution(vector&lt;vector&lt;int&gt;&gt; key, vector&lt;vector&lt;int&gt;&gt; lock) { bool answer = false; int m = key.size(); int n = lock.size(); for (int i = 0; i &lt; 4; i++) { int zero_cnt = 0; // 3배의 배열을 만들고 lock을 가운데 세팅 vector&lt;vector&lt;int&gt;&gt; tmp(3 * n, vector&lt;int&gt;(3 * n)); for (int j = n; j &lt; n + n; j++) { for (int z = n; z &lt; n + n; z++) { tmp[j][z] = lock[j-n][z-n]; if (lock[j-n][z-n] == 0) zero_cnt++; } } // 이동시킬 key의 복제 vector&lt;vector&lt;int&gt;&gt; tmp_key(m, vector&lt;int&gt;(m)); for (int j = 0; j &lt; m; j++) { for (int z = 0; z &lt; m; z++) { tmp_key[j][z] = key[j][z]; } } // 한칸씩 오른쪽, 아래로 옮기며 모든 경우 테스트 for (int x = 0; x &lt; 2 * n; x++) { for (int y = 0; y &lt; 2 * n; y++) { int correct_cnt = 0; bool incorrect = false; // 맞는지 확인 for (int j = 0; j &lt; m; j++) { for (int z = 0; z &lt; m; z++) { if (tmp_key[j][z] == 1 &amp;&amp; tmp[j + x][z + y] == 0) { // key는 돌기, lock은 홈 부분, // 그리고 그 좌표가 lock에 해당할때 맞는 개수 + 1 if ((j + x &gt;= n) &amp;&amp; (j + x &lt; 2 * n) &amp;&amp; (z + y &gt;= n) &amp;&amp; (z + y &lt; 2 * n)) correct_cnt++; } // 둘다 돌기일때는 무조건 false! else if (tmp_key[j][z] == 1 &amp;&amp; tmp[j + x][z + y] == 1) { incorrect = true; break; } } if (incorrect) break; } // 맞는 개수와 lock의 전체 홈 부분의 수가 같으면 true if (zero_cnt == correct_cnt &amp;&amp; !incorrect) { return true; } } } // 회전 rotate(key); } return answer;}int main() { vector&lt;vector&lt;int&gt;&gt; key = { { 0, 0, 0 }, { 1, 0, 0 }, { 0, 1, 1 } }; vector&lt;vector&lt;int&gt;&gt; lock = { { 1, 1, 1 }, { 1, 1, 0 },{ 1, 0, 1 } }; cout &lt;&lt; solution(key, lock); return 0;}질문이나 지적사항은 댓글 부탁드립니다 :)" }, { "title": "[카카오 코딩 테스트] 괄호 변환", "url": "/posts/kakao-2020-first-2/", "categories": "Algorithm", "tags": "Kakao, algorithm", "date": "2020-05-07 17:27:00 +0800", "snippet": "괄호 변환 문제 보기2번 괄호 변환 문제입니다.문제 그대로 따라하기만 하면 되는 문제이지만, 생각보다 정답률은 낮은 문제네요.재귀에 대해 이해만 하고 있다면 문제에서 말하는 순서대로 따라만 하면 쉽게 풀리는 문제였습니다.아래는 해당 코드이고 각 단계별로 주석 달아두었습니다.#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;stack&gt; using namespace std; bool isCorrect(string p) { stack&lt;char&gt; s; for (int i = 0; i &lt; p.length(); i++) { if (p[i] == '(') s.push('('); else { if (s.empty()) return false; else s.pop(); } } return s.empty();} string divide(string p) { // 1번 if (p.length() == 0) return \"\"; // 2번 string u, v; int left = 0, right = 0; for (int i = 0; i &lt; p.length(); i++) { if (p[i] == '(') left++; else right++; if (left == right) break; } u = p.substr(0, left + right); v = p.substr(left + right, p.length()); // 3번 if (isCorrect(u)) { // 3-1번 return u += divide(v); } // 4번 else { // 4-1번 string tmp = \"(\"; // 4-2번 tmp += divide(v); // 4-3번 tmp += \")\"; // 4-4번 u = u.substr(1, u.length() - 2); for (int i = 0; i &lt; u.length(); i++) { if (u[i] == '(') tmp += \")\"; else tmp += \"(\"; } // 4-5번 return tmp; }} string solution(string p) { string answer = divide(p); return answer;}int main() { string p = \"()))((()\"; cout &lt;&lt; solution(p); return 0;}질문이나 지적사항은 댓글 부탁드립니다 :)" }, { "title": "[카카오 코딩 테스트] 문자열 압축", "url": "/posts/kakao-2020-first-1/", "categories": "Algorithm", "tags": "Kakao, algorithm", "date": "2020-05-07 16:54:00 +0800", "snippet": "문자열 압축 문제 보기1번 문자열 압축 문제입니다.2020 신입 1차 코딩 테스트는 정답률이 1번부터 20%대 이고, 뒤로 갈수록 0%대의 문제까지..타 회사들 및 이전 테스트들에 비해 난이도가 극악인 시험이었던 것 같습니다.1번문제는 어렵다기보다는 문제를 잘못이해할 여지가 있어서 까다로웠던 문제 같습니다.문제를 명확히 했으면 정답률이 조금 더 올라가지 않았을까 싶습니다…그냥 1개씩 나누고, 2개씩 나누고, … n/2개씩 나눠서 길이만 재면 되는 문제이긴 하지만,저는 너무 복잡하게 생각해서 헤메게 되었습니다..예를 들면, aabab의 경우 2개씩 나누면 aa / ba / b 이렇게 되서 아무것도 겹치지 않기에 2일 경우의 길이는 5입니다.하지만, 저는.. 문제를 잘못 이해하여…a / ab / ab 의 경우는 ab가 겹쳐질 수 있으므로 a2ab = 4로 굳이 복잡하게 코딩을 했던 것입니다!코드 줄도 길어지고.. 제출하니 문제에서 제시된 예시에서도 틀리기에 뭔가 했더니제시된 5번째 예시를 보면, 고정적으로 n개씩 나누면 된다는 문제의 의도를 알 수 있습니다…ㅠㅠ아래는 풀이한 코드입니다.#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std; int getLength(string s, int k) { int from = 0; string result = \"\"; string tmp = s.substr(from, k); from += k; int dup_cnt = 1; while (from + k &lt;= s.length()) { if (tmp == s.substr(from, k)) { dup_cnt++; } else { // 중복의 경우 중복 수만큼 숫자 붙이기 if (dup_cnt &gt; 1) result.append(to_string(dup_cnt)); result.append(tmp); dup_cnt = 1; // 부분문자열 초기화 tmp = s.substr(from, k); } from += k; } // 뒤에 남은 문자열 처리 if (dup_cnt &gt; 1) result.append(to_string(dup_cnt)); result.append(tmp); result.append(s.substr(from, s.length())); return result.length();} int solution(string s) { int answer = s.length(); for (int i = 1; i &lt;= s.length() / 2; i++) { answer = min(answer, getLength(s, i)); } return answer;}int main() { string s = \"abcabcabcabcdededededede\"; cout &lt;&lt; solution(s); return 0;}질문이나 지적사항은 댓글 부탁드립니다 :)" }, { "title": "[카카오 코딩 테스트] 호텔 방 배정", "url": "/posts/kakao-2019-winter-intern-4/", "categories": "Algorithm", "tags": "Kakao, algorithm", "date": "2020-05-07 14:12:00 +0800", "snippet": "호텔 방 배정 문제 보기4번 호텔 방 배정 문제입니다.구체적인 원리 및 풀이 과정은 위 링크의 해설에 그림과 함께 자세하게 설명이 되어 있습니다.간단하게 요약하자면,붙어있는 방 끼리 한 그룹이 되고 그 그룹들은 모두 다음의 빈방을 가리키고 있으면 다음에는 그 그룹이 가리키는 빈방을 바로 배정하면 되는 것입니다.이는 결국 Union-Find 문제입니다. 어렵게 생각하면 코드가 엄청 길어질 수 있지만, 이 알고리즘을 활용하면 아래와 같이 알고리즘 부분이 20줄도 채 안될만큼 간단한 문제입니다.아래는 구현한 코드입니다.#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std; map&lt;long long, long long&gt; room; long long getEmpty(long long num) { if (room[num] == 0) return num; return room[num] = getEmpty(room[num]);} vector&lt;long long&gt; solution(long long k, vector&lt;long long&gt; room_number) { vector&lt;long long&gt; answer; for (auto num : room_number) { long long empty = getEmpty(num); answer.push_back(empty); room[empty] = empty + 1; } return answer;}int main() { long long k = 10; vector&lt;long long&gt; room_number = { 1,3,4,1,3,1 }; vector&lt;long long&gt; result = solution(k, room_number); for (auto x : result) { cout &lt;&lt; x &lt;&lt; ' '; } return 0;}질문이나 지적사항은 댓글 부탁드립니다 :)" }, { "title": "[카카오 코딩 테스트] 징검다리 건너기", "url": "/posts/kakao-2019-winter-intern-3/", "categories": "Algorithm", "tags": "Kakao, algorithm", "date": "2020-05-06 18:42:00 +0800", "snippet": "징검다리 건너기5번 징검다리 건너기 문제입니다.이 문제는 그냥 다 해보면 되지만, 효율성 점수까지 있기 때문에 잘 생각해서 풀어야 합니다. 풀이 방법부터 말하자면, 이 문제는 전형적인 binary search 문제입니다. 몇명이 건너는지 미리 중간값으로 정해놓고 조건에 만족하는지 체크 후, 값을 올리든 내리든 하면 끝입니다.무슨 알고리즘을 써야하는지 알면 순식간에 풀 수 있는 문제지만, 문제를 보고 바이너리 서치를 떠올리기엔 생각보다 쉽지 않았습니다.. 역시 많은 문제를 풀어봐야 감이 올듯 싶은 부분이네요!코드 작성 후 처음에는 제 컴퓨터에선 잘 되지만, 프로그래머스에서는 메모리 에러가 났습니다.재귀 방식으로 구현했었는데, 함수 스택이 계속 쌓이면서 stones 변수가 차지하는 공간이 늘어나고 해당 에러가 난 것 같습니다. 아래처럼 그냥 반복문으로 하면 별 문제없이 클리어!아래는 구현한 코드입니다.#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define MAX 200000000using namespace std;int solution(vector&lt;int&gt; stones, int k) { int answer = 0; int from = 1; int to = MAX; while (from &lt;= to) { int mid = from + ((to - from) / 2); int seq = 0; bool flag = true; for (int i = 0; i &lt; stones.size(); i++) { if ((stones[i] - mid) &lt; 0) seq++; else seq = 0; if (seq == k) { flag = false; break; } } if (flag) { answer = max(answer, mid); from = mid + 1; } else { to = mid - 1; } } return answer;}int main() { vector&lt;int&gt; stones = { 2, 4, 5, 3, 2, 1, 4, 2, 5, 1 }; int k = 3; cout &lt;&lt; solution(stones, k); return 0;}질문이나 지적사항은 댓글 부탁드립니다 :)" }, { "title": "[카카오 코딩 테스트] 튜플", "url": "/posts/kakao-2019-winter-intern-2/", "categories": "Algorithm", "tags": "Kakao, algorithm", "date": "2020-05-06 14:07:00 +0800", "snippet": "튜플 문제 보기2번 튜플 문제입니다.원리만 알면 쉽게 풀 수 있는 문제입니다. 튜플들이 순서가 바뀔수 있고 집합마다 원소 순서도 다 바뀔 수 있지만, 걱정할 필요가 없습니다.집합이 4개라면, 결국 제일 첫번째 있는 원소는 4번, 두번째 원소는 3번, 세번째는 2번, 네번째는 1번 나올 수 밖에 없습니다.그래서 string에서 숫자를 추출해내고 각 숫자가 몇번 반복됬는지만 확인해 주어 정렬만 해준다면 쉽게 해결할 수 있는 문제입니다.아래는 풀이한 코드입니다.#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int cnt[100001] = { 0 };vector&lt;int&gt; solution(string s) { vector&lt;int&gt; answer; int num = 0; for (int i = 0; i &lt; s.length(); i++) { if (s[i] != '{' &amp;&amp; s[i] != '}' &amp;&amp; s[i] != ',') { num *= 10; num += s[i] - '0'; } else { if (num &gt; 0) { cnt[num]++; num = 0; } } } vector&lt;pair&lt;int, int&gt;&gt; result; for (int i = 0; i &lt; 100001; i++) { if (cnt[i] &gt; 0) { result.push_back({ cnt[i],i }); } } sort(result.begin(), result.end()); for (int i = result.size() - 1; i &gt;= 0; i--) answer.push_back(result[i].second); return answer;}int main() { // string s = \"{{2},{2,1},{2,1,3},{2,1,3,4}}\"; // string s = \"{ {1, 2, 3}, { 2,1 }, { 1,2,4,3 }, { 2 }}\"; // string s = \"{{20,111},{111}}\"; // string s = \"{{123}}\"; string s = \"{{4,2,3},{3},{2,3,4,1},{2,3}}\"; vector&lt;int&gt; result = solution(s); for (auto x : result) cout &lt;&lt; x &lt;&lt; \" \"; system(\"pause\"); return 0;}질문이나 지적사항은 댓글 부탁드립니다 :)" }, { "title": "[카카오 코딩 테스트] 크레인 인형 뽑기 게임", "url": "/posts/kakao-2019-winter-intern-1/", "categories": "Algorithm", "tags": "Kakao, algorithm", "date": "2020-05-06 13:39:00 +0800", "snippet": "크레인 인형 뽑기 게임 문제 보기1번 크레인 인형 뽑기 게임 문제입니다.1번 문제 답게 stack 활용하면 쉽게 해결할 수 있는 문제입니다.stack의 top과 비교해서 같으면 2씩 더해주기만 하면 끝나는 문제!아래는 풀이한 코드 입니다.#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;using namespace std;int solution(vector&lt;vector&lt;int&gt;&gt; board, vector&lt;int&gt; moves) { int answer = 0; stack&lt;int&gt; s; for (int i = 0; i &lt; moves.size(); i++) { int col = moves[i]-1; for (int j = 0; j &lt; board.size(); j++) { if (board[j][col] != 0) { int cur = board[j][col]; board[j][col] = 0; // 스택이 비었거나 상단의 인형과 뽑은 인형이 다를 경우 if (s.empty() || s.top() != cur) s.push(cur); // 인형이 같을 경우 else { answer += 2; s.pop(); } break; } } } return answer;}int main() { vector&lt;vector&lt;int&gt;&gt; board = { {0, 0, 0, 0, 0}, {0, 0, 1, 0, 3}, {0, 2, 5, 0, 1}, {4, 2, 4, 4, 2}, {3, 5, 1, 3, 1} }; vector&lt;int&gt; moves = { 1,5,3,5,1,2,1,4 }; cout &lt;&lt; solution(board, moves); system(\"pause\"); return 0;}질문이나 지적사항은 댓글 부탁드립니다:)" }, { "title": "[백준] 9251번 LCS", "url": "/posts/algorithm-bj-9251/", "categories": "Algorithm", "tags": "Baekjoon, algorithm", "date": "2020-05-06 12:25:00 +0800", "snippet": "풀이단순히 LIS(Longest Increasing Subsequence) 처럼 풀려고 하다가 엄청 헤멘 문제 입니다..LCS를 해결하는 방식이 있습니다. 우선 표를 통해서 먼저 설명하겠습니다. (문제에서 주어진 것 처럼 ACAYKP, CAPCAK를 활용합니다)     A C A Y K P   0 0 0 0 0 0 0 C 0 0 1 1 1 1 1 A 0 1 1 2 2 2 2 P 0 1 1 2 2 2 3 C 0 1 2 2 2 2 3 A 0 1 2 3 3 3 3 K 0 1 2 3 3 4 4 최종적인 표의 모습입니다. 알면 쉽게 풀리는.. 2가지 규칙만 적용하면 끝나는 문제입니다.1) 같은 문자가 나오면 대각 왼쪽 상단 + 12) 다른 문자가 나오면 max(상, 좌)먼저, 각 문자 배열 + 1만큼 DP(Dynamic programming) 변수를 선언하기! (아래 그림처럼 0으로 초기화 하기 위함)      A C A Y K P   0 0 0 0 0 0 0 C 0             A 0             P 0             C 0             A 0             K 0             다음 첫줄부터 채워보면, C끼리 만난 지점에는 대각 좌상단(CA == 0) + 1 하여 1이 됩니다. 그 옆은 위는 0, 왼쪽은 1 이므로 그 중 큰 값인 1로 채워지게 됩니다.     A C A Y K P   0 0 0 0 0 0 0 C 0 0 1 1 1 1 1 A 0             P 0             C 0             A 0             K 0             마지막으로 A 줄만 한번 더 보면, 첫번째 A가 만나는 부분의 대각선은 0이므로 1,두번째 만나는 부분의 대각선은 1이므로 2가 됩니다. 이 과정을 반복하면 맨 처음 표처럼 나오게되고,제일 마지막의 숫자가 답이 됩니다.     A C A Y K P   0 0 0 0 0 0 0 C 0 0 1 1 1 1 1 A 0 1 1 2 2 2 2 P 0             C 0             A 0             K 0             정확한 원리는 말로 설명하기가 어렵지만.. 이해는 가는 부분입니다. 같은 문자이면 이전까지의 배열 중 최대 값에 + 1을 해주는 것이고 다를 경우는 최대 값을 유지해주는 개념이라고 생각됩니다.아래는 위 과정을 구현한 코드입니다.#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main(void) { string a, b; cin &gt;&gt; a &gt;&gt; b; vector&lt;vector&lt;int&gt;&gt; d(a.length() + 1, vector&lt;int&gt;(b.length() + 1)); for (int i = 1; i &lt;= a.length(); i++) { for (int j = 1; j &lt;= b.length(); j++) { if (a[i - 1] == b[j - 1]) d[i][j] = d[i - 1][j - 1] + 1; else d[i][j] = max(d[i - 1][j], d[i][j - 1]); } } cout &lt;&lt; d[a.length()][b.length()]; return 0;}질문이나 지적사항은 댓글 부탁드립니다 :)" }, { "title": "[백준] 12865번 평범한 배낭", "url": "/posts/algorithm-bj-12865/", "categories": "Algorithm", "tags": "Baekjoon, algorithm", "date": "2020-05-06 12:25:00 +0800", "snippet": "풀이문제 제목처럼 평범한 Knapsack 문제 입니다. 하지만, 너무 간만에 봐서 다 까먹고 쉽게 풀지 못한 문제이기도 합니다…ㅠㅠbacktracking으로 풀어도 봤습니다. dfs로 재귀방식으로 모든 경우를 따져봤지만 역시나 시간초과가 뜹니다.결국 DP로 풀어야 하는 문제입니다!DP 변수의 각 index(물건) 마다 0~k까지의 무게에 대해 최대값을 넣어주면 됩니다.2가지 경우로 나눠서 풀어주기만 하면 간단합니다.1) i 번째 물건을 안넣는 경우2) i 번째 물건을 넣는 경우1번의 경우는 그냥 i-1의 무게를 유지해주면 되는 문제고,2번의 경우는 현재 무게( j ) - 넣고자 하는 물건의 무게에 해당하는 v값을 더해주면 됩니다.대신 넣을 때는 주의해야 할것이, 넣는 것이 오히려 안넣을 때보다 값이 낮을 수 있으니 비교해서 넣어주면 끝입니다.아래는 구현한 코드입니다.#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() { int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;vector&lt;int&gt;&gt; d(n+1, vector&lt;int&gt;(k + 1)); // d[n+1][k+1] vector&lt;pair&lt;int, int&gt;&gt; item(n+1); for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; item[i].first &gt;&gt; item[i].second; } for (int i = 1; i &lt;= n; i++) { for (int j = 0; j &lt;= k; j++) { d[i][j] = d[i - 1][j]; if(j-item[i].first &gt;= 0) d[i][j] = max(d[i][j], d[i - 1][j - item[i].first] + item[i].second); } } cout &lt;&lt; d[n][k]; return 0;}질문이나 지적사항은 댓글 부탁드립니다 :)" }, { "title": "Ionic 인앱결제 (in app purchase 2)", "url": "/posts/ionic-inapp-purchase/", "categories": "Ionic", "tags": "Ionic, InAppPurchase", "date": "2020-04-26 13:43:00 +0800", "snippet": "Ionic으로 인앱결제를 해보면서 native에 비해 자료도 적고 가려운 곳을 긁어주는 정보들이 별로 없었습니다.그래서 이것이 제가 했던 것을 기록하는 의미도 있지만 누군가에게는 도움이 됬으면 합니다. Ionic Code billing.fovea.cc 안드로이드 상품 등록 sandbox IOS 상품 등록 sandbox 계약 들어가기에 앞서, 처음에 저는 코드상으로 상품을 등록하고 결제하는 과정을 전부 할 수 있을 줄 알았습니다.DB만 바꿔주면 상품명과 가격 등의 정보도 바로바로 바꿀 수 있을 줄 알았습니다…ㅠㅠ그래서 관련 부분을 찾느라 삽질을 했어서, 혹시나 저와 같은 분이 계시다면! 각 플랫폼에 상품을 미리 등록해놓은 다음 그 정보를 바탕으로 결제하는 것이니 참고하시기 바랍니다.1. Ionic[Code]Ionic에는 ‘In App Purchase’와 ‘In App Purchase 2’ 이렇게 두 종류의 플러긴을 제공합니다. ‘2’ 버전을 사용하는 이유는 billing.fovea.cc를 활용하기 위해서 입니다. 결제 검증을 알아서 해주는 서비스로, backend에서 할 일을 줄여줍니다. 물론, 굳이 저기를 쓰지 않아도 상관은 없습니다. 먼저 상품을 등록해 줍니다. this.store.register({ id: \"my_consumable1\", type: this.store.CONSUMABLE});...const p = this.store.get(\"my_consumable1\");처음엔 등록한다는게 각 스토어에 등록한다는 얘긴줄 알고 이렇게 하면 되겠다 했지만… 그렇게 쉬울리 없죠이때 id는 스토어에 등록한 product id와 동일해야 합니다.그리고 type은 게임 아이템과 같이 소모품이라면 CONSUMABLE비정기구독의 경우는(apple만 해당) NON_PAID_SUBSCRIPTION정기구독의 경우는 PAID_SUBSCRIPTION이렇게 해주시면 됩니다. 하지만 개발 테스트시에는 그냥 전부 consumable로 통일하는게 낫다고 생각합니다. 그리고 아래의 get은 해당 id의 상품 IAPProduct 객체를 가져오는 것인데, 저는 개인적으로 쓸일이 없었습니다.다음으로는 각 상품의 상태에 따라서 할 일들을 미리 정해놓는 부분입니다. this.store.validator = \"https://billing.fovea.cc/\";this.store.when(\"my stuff\") .approved((p: IAPProduct) =&gt; p.verify()) .verified((p: IAPProduct) =&gt; p.finish());ionic 문서에 다양한 케이스들이 있지만 그 부분들은 문서에서 충분히 알 수 있고,이 부분이 제일 저를 속썩였던 부분이라 한번 짚고 넘어가도록 하겠습니다. 먼저, 저런 문법은 사용이 불가합니다. ts버전이 다른걸까도 싶었지만 plugin 코드를 봐도 approved는 void를 return하기 때문에 성립할 수가 없는 문법입니다. 그냥 표기상의 편의를 위해 저렇게 작성해 놓은 듯 합니다. 그래서 아래처럼 나눠서 사용하면 문제 없습니다.추가적으로, 검증에 실패했을 경우에는 unverified를 사용하면 됩니다.this.store.when('my_product_id').approved(p=&gt;p.verify());this.store.when('my_product_id').verified(p=&gt;p.finish());this.store.when('my_product_id').unverified(p=&gt;p);approved는 결제가 완료됬을 때 입니다. 인앱결제 프로세스가 끝나면 이 부분이 실행되고 validator로 지정해 놓은 url을 통해 검증을 합니다.저의 경우는 billing.fovea.cc에서 이를 알아서 처리하고 검증 결과에 따라 verified 혹은 unverified로 오게 됩니다. 그런데 여기에서 제일 큰 의문이 들었습니다. approved 되었을 땐 이미 금액도 빠져나가고 결제가 된 상태인데 그 후에 검증하면 무슨 소용이 있을까 싶었습니다. 이를 바탕으로 billing fovea측에 문의 해본 결과 이렇게 답변이 왔습니다.  If payment is approved and verification failed, the payment is not acknowledged. The user will get refund (or not get charged) automatically by Google. You don’t have to do anything.결제는 승인 됬지만, acknowledged는 안됬고 그렇기에 자동으로 며칠 안으로 해당 유저는 환불 받게 될 것이라고 합니다. 여기에서 중요한 것이 p.finish() 입니다. 이를 해주면 acknowledged 상태가 되는 것이니 아무데서나 finish 함수를 사용하면 안되겠습니다. 마지막으로 store.when의 세팅이 끝나면 아래와 같이 refresh를 해주고 원하는 곳에서 order 해주면 인앱결제가 완료됩니다.// Refresh the status of in-app productsthis.store.refresh();...// To make a purchasethis.store.order(\"my_product_id\");여기에서 주의해야 할 사항이 하나 있습니다. store.when의 세팅은 맨 처음 시작할때, 즉, app.component.ts에서 platform.ready() 직후에 해주는 것이 좋습니다. 처음에는 결제 부분이 있는 페이지에 코드를 작성했었습니다. 그런데 그 페이지를 나갔다 들어올 때마다 세팅들이 중첩되기 시작했습니다. 예를들면, this.store.when('my_product_id').cancelled(p=&gt;{ alert('결제가 취소되었습니다') });이러한 코드가 있을 때, 결제 도중에 취소해버리면 alert 창이 여러번(해당 페이지에 드나든 횟수만큼…) 뜨게 됩니다. 더욱 중요한 것은 approved도 여러번, 검증도 여러번 하게되어 DB에 중복 데이터들이 쌓이게 됬습니다. 이부분까지 주의해 주신다면 보다 수월하게 개발을 진행할 수 있습니다.. 이것 때문에 괜한 삽질을 너무 많이 했었던 기억이…[billing.fovea.cc]일단, 이 서비스는 유료입니다.한달 100건의 거래까지는 무료지만 5000건은 10달러, 10만건은 50달러 입니다.(작성일 기준). 이 서비스의 문서에 각 플랫폼 별로 세팅하는 부분을 자세하게 설명해주고 있어서 그대로 따라하기만 하면 금방 세팅이 끝납니다. 결제가 완료되면 그 로그들도 직접 확인할 수도 있습니다. 세팅이 완료되면 여기서 제공해주는 Validator URL을 위의 this.store.validator에 적용하면 되겠습니다. 그런데 여기서 제일 삽질했던 부분은 iOS Subscription Status URL을 appstore에 작성하는 부분이었습니다. 사실 제가 하는 개발에서는 구독 상품은 판매하지 않아서 필요 없었는데 혹시 몰라 미리 입력해 놓으려다가 시간을 많이 잡아먹었던 부분입니다. 아래 IOS 파트에서도 언급하겠지만 유료상품 계약이 되야 구독 상품을 생성할 수 있고 구독 상품을 생성해야 iOS Subscription Status URL을 작성할 수 있습니다.2. 안드로이드[상품등록]상품등록 관련은 정보가 많아서 따로 기록하진 않겠습니다. 하지만, 주의(?) 해야 할 부분 하나만 짚고 넘어가겠습니다. 위 사진을 보면, 분명 가격을 KRW 14900이라고 입력했지만, 아래 빨간 부분을 보면 지들 멋대로 1000원 단위로 끊어버립니다. 만원 이하는 900원이 제대로 되는 것 같은데, 그 이상은 안되는 듯 싶습니다.(가물가물..) 그치만 큰 문제는 아니라 그냥 저 부분에도 14900원으로 입력해주시면 끝납니다.[sandbox]안드로이드의 테스트 계정 등록은 간단합니다.  ‘,’로 구분하여 이메일을 입력하면 됩니다. 등록 후, 해당 play store 계정으로 구매버튼을 누르면 테스트 계정이라고 뜨며,결제 성공, 취소, 조금 있다 성공, 조금 있다 취소 이렇게 4가지 종류로 바로 테스트 해볼 수 있도록 제공됩니다.(갓구글…)3. IOS[상품등록]IOS 상품 등록도 그리 어렵진 않지만 애플이 항상 그렇듯 귀찮은 부분이 있습니다. 우선 위 사진의 앱 내 구입 옆에 + 버튼으로 상품을 추가해봅니다. 그러면 아래의 그림처럼 나옵니다.하지만.. 사실 위 그림처럼 나오려면 조건이 필요합니다.. 아무것도 안한했다면 빨간 박스의 자동 갱신 구독이 없습니다. 위에 billing.fovea.cc에서도 설명했듯이 아래 [계약] 부분을 완성해야 위 캡처처럼 보여, 구독 상품을 생성할 수 있고 구독 상품을 생성해야 iOS Subscription Status URL(아래 캡처의 구독 상태 URL)을 작성할 수 있습니다.마지막으로, 상품 내용을 작성하면 되는데, 심사정보-&gt;스크린샷 부분을 넣어주셔야 될 겁니다.(안 넣어도 된다는 말이 있지만 혹시나 해서…)만약 저 부분을 비워놓으면 진행상태가 메타데이터 등록하라고 뜹니다. 스크린샷 까지 넣고 나면, 진행 상태가 제출 준비됐다고 표시되고 여기까지만 진행하면 이제 끝입니다. 제 캡처처럼 “승인됨”으로 뜨려면 앱 제출해서 심사까지 거쳐야 되는 것이고 제출 준비 상태까지만 되도 테스트하는데는 문제 없습니다.[sandbox]사용자 및 액세스에 들어가면 왼쪽 제일 아래에 Sandbox가 있습니다. 이곳에서 테스터 등록하면 되는데, 저기에 들어갈 이메일은 App store에 등록된 계정이 아니어야 됩니다!그리고 실존하는 메일이 아니어도 됩니다. 그냥 아무렇게나 메일 작성하면 끝!! 그리고 후에 테스트 할때는 기존 로그인 되있는 계정은 로그아웃 하신 상태에서 테스트 하시면 됩니다.그러면 결제할 때 이 이메일과 비밀번호를 작성하면 정상적으로 Sandbox 결제가 진행됩니다.[계약]빨간 유료 앱 부분이 보이시나요?! 이 부분을 몰라서 엄청 이상한 곳에서 삽질을 오랫동안 했었습니다.. ㅠㅠ유료 앱에는 주소, 세금 관련(…?) 등 정확한 내용은 기억이 안나지만 여러 정보들 입력하면 애플에서 또 심사를 합니다.. 그놈의 심사.. 쨋든, 유료앱 부분이 활성 상태가 아니라면, 암만 Ionic in app purchase를 고치고 고쳐도 product id를 알 수 없다는 피드백만 올 뿐입니다. 다른 걸 다 했더라도 이 부분이 안되면.. !!이미 IOS 결제 개발 하셨던 분들이라면 당연히 알고 계실테지만, 처음 하시는 분들은 이게 조금이나마 도움이 됬으면 합니다. 길었지만, 여기까지 따라 오셨다면 큰 문제 없이 구현이 될 것이라 생각합니다. 질문이나 지적하실 부분이 있으시면 댓글 부탁드립니다 :)" }, { "title": "[백준] 2206번 벽 부수고 이동하기", "url": "/posts/algorithm-bj-2206/", "categories": "Algorithm", "tags": "Baekjoon, algorithm", "date": "2020-04-25 21:20:00 +0800", "snippet": "풀이벽 부수는 것을 처음에 너무 간단하게만 생각했다가 여러번 틀린 문제입니다.queue에 넣는 조건을 잘 나누지 않으면 메모리 초과가 나오기 십상이니명확하게 구분해야만 해결할 수 있는 문제였습니다.먼저, 현재 좌표의 방문 여부를 벽을 부순적이 있는 경우와 없는 경우로 나눠서 진행해야 합니다.안그러면 아래 예시와 같은 경우에 -1이 나오게 됩니다.4 400000 1 1 100 1 100 10한번 방문해서 실패했다고 무조건 visited를 true로 바꿔주면..! 아래처럼 되버려서 실패하고 맙니다.(0,0)-&gt;(0,1)-&gt;(1,1)-&gt;(2,1)-&gt;(3,1) 경로로 이동해서 한번 실패했다면, 해당 경로는 전부 visited = true가 되버립니다. 그러면,(0,0)-&gt;(1,0)-&gt;(2,0)-&gt;(2,1) 의 경로의 경우 막혀버리게 되고(0,0)-&gt;(1,0)-&gt;(2,0)-&gt;(3,0)-&gt;(3,1)의 경로 또한 막혀버리게 됩니다.그래서 원치않는 -1 값이 나오게 됩니다..그래서 두 경우로 나눠보면, 아래와 같습니다. 벽 부순 횟수가 0이면서 해당 좌표에 방문한적이 없는 경우 1-1) 해당 좌표에 벽이 없고 이전까지 벽 부순 횟수도 0 일경우 벽 부순 횟수가 1이면서 해당 좌표에 방문한적이 없는 경우 2-1) 해당 좌표에 벽이 있고 벽 부순 횟수가 0일 경우 2-2) 해당 좌표에 벽이 없고 벽 부순 횟수가 1일 경우 아래는 이를 토대로 작성한 코드입니다.#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;string&gt;using namespace std;int map[1000][1000];bool visited[1000][1000][2] = { false };int xpos[] = { -1,0,1,0 };int ypos[] = {0, 1, 0, -1};class Point{public: int x; int y; int cnt; int brk; Point(int x, int y, int brk, int cnt) { this-&gt;x = x; this-&gt;y = y; this-&gt;cnt = cnt; this-&gt;brk = brk; }};int bfs(int n, int m) { queue&lt;Point&gt; q; q.push(Point(0,0,0,1)); visited[0][0][0] = true; visited[0][0][1] = true; while (!q.empty()) { Point cur = q.front(); q.pop(); if (cur.x == n-1 &amp;&amp; cur.y == m-1) { return cur.cnt; } for (int i = 0; i &lt; sizeof(xpos) / sizeof(int); i++) { int nx = cur.x + xpos[i]; int ny = cur.y + ypos[i]; if (nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; m) { // 벽 부순 횟수가 0이면서 해당 좌표에 방문한적이 없는 경우 if (!visited[nx][ny][0]) { // 해당 좌표에 벽이 없고 이전까지 벽 부순 횟수도 0 일경우에만 push if (map[nx][ny] == 0 &amp;&amp; cur.brk == 0) { q.push(Point(nx, ny, 0, cur.cnt + 1)); visited[nx][ny][0] = true; } } // 벽 부순 횟수가 1이면서 해당 좌표에 방문한적이 없는 경우 if (!visited[nx][ny][1]) { // 해당 좌표에 벽이 있고 벽 부순 횟수가 0일 경우 // or 해당 좌표에 벽이 없고 벽 부순 횟수가 1일 경우 if ((map[nx][ny] == 1 &amp;&amp; cur.brk == 0) || (map[nx][ny] == 0 &amp;&amp; cur.brk == 1)) { q.push(Point(nx, ny, 1, cur.cnt + 1)); visited[nx][ny][1] = true; } } } } } return -1;}int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) { string tmp; cin &gt;&gt; tmp; for (int j = 0; j &lt; m; j++) map[i][j] = tmp[j] - '0'; } cout &lt;&lt; bfs(n,m); return 0;}코드에 문제가 있거나 더 나은 방법이 있는 경우엔 댓글 부탁드립니다 :)" }, { "title": "[카카오 코딩 테스트] 길 찾기 게임", "url": "/posts/kakao-2019-second-3/", "categories": "Algorithm", "tags": "Kakao, algorithm", "date": "2019-09-29 08:32:00 +0800", "snippet": "길 찾기 게임 문제 보기처음에 엄청 복잡하게 생각해서 여러 시행착오를 겪은 문제입니다.. ㅠㅠtree를 vector double array로 만들수 있다고 생각했던게 문제였네요단순하게 생각하면 오히려 쉽게 해결할 수 있는 문제였습니다. 정렬을 합니다! -&gt; y가 큰 순서, 그다음은 x가 작은 순서 그 순서대로 tree에 넣어줍니다. 2-1. bst처럼 부모노드보다 작으면 left, 크면 right child로 재귀형태로 넣어줍니다. preorder, postorder 수행끝!간만에 포인터를 활용해봤네요.이런 tree문제를 제가 많이 접하지 못해서 해결에 애를 먹었던 것 같습니다.. ㅠㅠㅠㅠ쨋든!아래는 풀이한 코드입니다:)#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt; answer(2);struct NodeInfo{ int x, y, n; // n = 노드번호}; struct Tree { NodeInfo node; Tree *left; Tree *right;}; bool cmp(NodeInfo a, NodeInfo b) { if (a.y &gt; b.y) return true; else { if (a.y == b.y &amp;&amp; a.x &lt; b.x) return true; else return false; }} // 작으면 왼쪽노드, 크면 오른쪽노드에 넣기void add(Tree *&amp;t, Tree *tmp) { if (t == NULL) { t = tmp; return; } if (tmp-&gt;node.x &lt; t-&gt;node.x) add(t-&gt;left, tmp); else add(t-&gt;right, tmp);} void preorder(Tree *t) { if (t != NULL) { answer[0].push_back(t-&gt;node.n); preorder(t-&gt;left); preorder(t-&gt;right); }}void postorder(Tree *t) { if (t != NULL) { postorder(t-&gt;left); postorder(t-&gt;right); answer[1].push_back(t-&gt;node.n); }} vector&lt;vector&lt;int&gt;&gt; solution(vector&lt;vector&lt;int&gt;&gt; nodeinfo) { // 뒤죽박죽인 노드 정보들을 y를 기준으로 내림차순 정렬 vector&lt;NodeInfo&gt; nodes; for (int i = 0; i &lt; nodeinfo.size(); i++) nodes.push_back({nodeinfo[i][0],nodeinfo[i][1],i+1}); sort(nodes.begin(), nodes.end(), cmp); // Tree에 노드 넣기! // 최 상단 노드부터(부모) 차례대로 Tree *t = new Tree; t-&gt;node = nodes[0]; t-&gt;left = NULL; t-&gt;right = NULL; for (auto node : nodes) { if (node.n == nodes[0].n) continue; Tree *tmp = new Tree; tmp-&gt;node = node; tmp-&gt;left = NULL; tmp-&gt;right = NULL; add(t, tmp); } preorder(t); postorder(t); return answer;} int main() { vector&lt;vector&lt;int&gt;&gt; result = solution({ {5, 3},{11, 5},{13, 3},{3, 5},{6, 1},{1, 3},{8, 6},{7, 2},{2, 2} }); for (auto x : result) { for (auto y : x) cout &lt;&lt; y &lt;&lt; ' '; cout &lt;&lt; endl; } return 0;}질문이나 지적사항은 댓글 부탁드립니다:)" }, { "title": "[카카오 코딩 테스트] 무지의 먹방 라이브", "url": "/posts/kakao-2019-second-2/", "categories": "Algorithm", "tags": "Kakao, algorithm", "date": "2019-09-18 13:16:00 +0800", "snippet": "무지의 먹방 라이브 문제 보기4번 무지의 먹방 라이브는 효율성이 중요한 문제였습니다.정확성만 보면 쉽게 풀 수 있는 문제 였지만, 효율성이 정답률이 5.52% 밖에 안됬습니다..ㄷㄷ저도 효율성에서 자꾸 막혀서 결국 정답자 분의 코드를 보며 수정했는데요..코드도 엄청 짧고 복잡하게 생각할 필요가 없는 문제였습니다..처음에는 시간을 기준으로 오름차순으로 정렬— loop — 0번째 배열의 시간 * 배열 크기 를 k에서 빼기 모든 배열에서 0번째 배열의 시간만큼 빼주고 시간이 0이 되는 index는 vector의 erase함수를 활용해서 없애기 — loop end — 남은 배열의 크기 &gt; k 라면 %를 활용해서 index 구하기. 아니라면 -1 !! 이렇게하니 정확성은 다 맞았지만 효율성에서는 한개 빼고 다 시간초과가 뜨더군요..ㅠㅠ후에 정답 코드를 확인하고 보니 3번 과정은 전혀 쓸모가 없는 과정이었습니다..배열의 시간들을 일일이 빼줄 필요도 없었고 erase할 필요도 없었습니다..그저 이전 index의 시간과의 차이를 이용하면 끝이었습니다!코드를 보고나면 엄청 쉬운 문제지만 이렇게 바로 생각해내기가 너무 어려운 것 같습니다..아래는 풀이한 코드입니다.#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;using ll = long long; bool sort_by_idx(pair&lt;ll,int&gt; a, pair&lt;ll,int&gt; b) { return a.second &lt; b.second;}int solution(vector&lt;int&gt; food_times, ll k) { vector&lt;pair&lt;ll, int&gt;&gt; times; for (int i = 0; i &lt; food_times.size(); i++) { times.push_back({ food_times[i], i + 1 }); } sort(times.begin(), times.end()); int n = times.size(); int i = 0; for (; i &lt; n; i++) { ll diff = (i == 0 ? times[0].first : times[i].first - times[i - 1].first); ll total = diff * (n - i); if (k - total &lt; 0) break; else k -= total; } if (i == n) return -1; k %= (n - i); sort(times.begin() + i, times.end(), sort_by_idx); return times[i + k].second;}int main(void) { //vector&lt;int&gt; food_times = { 6,6,6,6,6,6,6 }; //long long k = 40; vector&lt;int&gt; food_times = { 3, 1, 2 }; long long k = 6; cout &lt;&lt; solution(food_times, k); return 0;}질문이나 지적사항은 댓글 부탁드립니다:)" }, { "title": "[카카오 코딩 테스트] 후보키", "url": "/posts/kakao-2019-second-1/", "categories": "Algorithm", "tags": "Kakao, algorithm", "date": "2019-09-18 09:30:00 +0800", "snippet": "호보키 문제보기3번 문제 후보키는 정답률이 16.09%였습니다. 완전 탐색을 어떻게 하는지만 알고 있다면 그래도 풀만한 문제였던것 같습니다.가장 중요한 key point는 bit연산자를 활용하는 것입니다.모든 부분집합을 bit연산으로 구하고,결과 또한 bit연산으로 걸러낼 수 있습니다.제 다른 포스팅 중 ‘Bit 연산으로 집합구하기’를 참고하시면 좋을 듯 합니다 :)그리고 하나 더 주의해야 할 부분은 연산자 우선순위 입니다.33번줄에 (subset[j] &amp; i) == subset[j] 이 부분을 저는 아무 생각 없이 괄호를 안쓰고 했다가쓸데없이 헤매버렸습니다..ㅠㅠ우선순위는 ==가 더 높기 때문에 괄호를 안쓴다면subset[j] &amp; ( i == subset[j] ) 이 순서로 실행이 되니 당연히 안되겠죠?!!아래는 풀이한 코드입니다. main함수에 있는 relation들은 테스트 케이스로 작성한 것입니다.#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;set&gt;using namespace std;int solution(vector&lt;vector&lt;string&gt;&gt; relation) { int rel_size = relation.size(); int col_len = relation[0].size(); int answer = 0; vector&lt;int&gt; subset; for (int i = 0; i &lt; (1 &lt;&lt; col_len); i++) { set&lt;string&gt; check; for (int j = 0; j &lt; rel_size; j++) { string tmp = \"\"; for (int z = 0; z &lt; col_len; z++) { if (i &amp; (1 &lt;&lt; z)) { // 선택된 column들을 비교하기 쉽게 전부 string으로 더해줍니다 // 뒤에 공백을 추가한 것은 // {\"ab\", \"c\"}, {\"a\", \"bc\"}가 같은것으로 보이기때문! tmp += relation[j][z] + ' '; } } // 완성된 string을 set에 넣어서 중복되는 것은 알아서 거르도록 check.insert(tmp); } // 중복이 없다면 relation의 size와 같을것! if (check.size() == rel_size) { bool flag = true; for (int j = 0; j &lt; subset.size();j++) { // 최소값을 걸러주는 것. // 8 &amp; 10은 8이기에 10은 걸러준다. // 여기에서 중요한 것은 괄호! 괄호 없이 &amp;를 쓰면 이상한 결과가 나옵니다 if ((subset[j] &amp; i) == subset[j]) { flag = false; break; } } if (flag) subset.push_back(i); } } return subset.size();}int main(void) { vector&lt;vector&lt;string&gt;&gt; relation; relation = { { \"100\",\"ryan\",\"music\",\"2\" }, { \"200\",\"apeach\",\"math\",\"2\" }, { \"300\",\"tube\",\"computer\",\"3\" }, { \"400\",\"con\",\"computer\",\"4\" }, { \"500\",\"muzi\",\"music\",\"3\" }, { \"600\",\"apeach\",\"music\",\"2\" } }; relation = { { \"100\",\"ryan\",\"music\",\"1\", \"a\" }, { \"100\",\"ryan2\",\"music\",\"2\", \"b\" }, { \"100\",\"ryan\",\"music\",\"3\", \"b\" }, { \"100\",\"ryan3\",\"music\",\"4\", \"b\" }, { \"100\",\"ryan\",\"music\",\"5\", \"c\" }, { \"100\",\"ryan5\",\"music\",\"6\", \"b\" } }; relation = { {\"ab\", \"c\"}, {\"a\", \"bc\"}, {\"a\", \"x\"}, {\"x\", \"c\"} }; cout &lt;&lt; solution(relation); return 0;}질문이나 지적사항은 댓글로 부탁드립니다 :)" }, { "title": "Bit 연산으로 집합구하기", "url": "/posts/algorithm-bit-calc/", "categories": "Algorithm", "tags": "algorithm", "date": "2019-09-17 21:56:00 +0800", "snippet": "완전탐색을 하기 위해서는 여러 방법이 있을 수 있겠지만 만약 int arr[] = { 1, 2, 3, 4 }; 라는 배열이 있다고 할 때,이 부분 집합들을 구해야 한다면 어떻게 해야 될까요?? 부분집합 크기가 1인 경우, 2인 경우 .. 4인경우 다 나눠서 구할 수는 있지만 만약 arr의 크기가 100이라면? 그보다 크다면?!! 딱히 생각나지 않습니다.. 이때! bit 연산으로 쉽게 구할 수 있습니다!000000010010 … 이런식으로 각 결과마다 1인 부분만 출력한다면 쉽게 부분집합을 구할수 있겠죠??먼저 코드를 보여드리고 설명하도록 하겠습니다. #include &lt;iostream&gt;using namespace std;int main() { // 배열 크기 int n = 5; // 11111을 10진수로 환산 했을 때의 값만큼 반복 // (이 경우 0 ~ 31) for (int i = 0; i &lt; (1 &lt;&lt; n); i++) { // 자리수만큼(이 경우 5) 반복하며 // 1인 자리는 1을, 아니면 0을 출력 for (int j = 0; j &lt; n; j++) { if (i &amp; (1 &lt;&lt; j)) cout &lt;&lt; 1 &lt;&lt; ' '; else cout &lt;&lt; 0 &lt;&lt; ' '; } cout &lt;&lt; endl; } system(\"pause\"); return 0;}먼저, 첫 번째 for문을 보면, (1 « n) 부분이 있습니다. 1을 n번만큼 왼쪽으로 옮긴다는 소리로,1은 00001이니, 이를 5번 옮기면 100000가 되겠죠? 10진수로 보면 32! 즉, 2^5입니다. 그냥 pow(2, n) 으로 해도 상관 없겠지만 bit에 익숙해지는게 낫겠죠??다음은 각 자리수 별로 체크하는 부분입니다. 여기에서 &amp;는 둘다 1이어야 1을 반환하는 연산자입니다.i가 5일 경우를 보면 ( 00101 ),j == 0일때, (1 « 0)은 1이 한칸도 안움직였으니 그대로 1입니다.    00101 &amp; 00001 = 00001 = 1 =&gt; true   그래서 1을 출력하겠죠?j == 1일때, (1 « 1)   00101 &amp; 00010 = 00000 = 0 =&gt; falsej == 2 일때, (1 « 2)   00101 &amp; 00100 = 00100 = 4 =&gt; true이후에는 다 0이므로 false 입니다.이렇듯 안에 있는 두번째 for문은 1이 있다면 true 아니면 false로 처리하여 부분집합을 구하는 것입니다.적절한 완전탐색 문제가 있다면 활용하면 좋겠네요!질문이나 지적사항은 댓글로 부탁드립니다 :)참고) https://www.crocus.co.kr/1427" }, { "title": "[백준] 1707번 이분 그래프", "url": "/posts/algorithm-bj-1707/", "categories": "Algorithm", "tags": "Baekjoon, algorithm", "date": "2019-09-17 19:58:00 +0800", "snippet": "풀이백준 사이트의 정답률은 작성 당시 22퍼센트 밖에 안되서 지레 겁먹을수 있으나!이분 그래프의 개념만 알면 bfs 혹은 dfs로 쉽게 풀수 있는 문제 입니다!!문제의 설명만 보면 뭐가 이분그래프인지 잘 모르겠는데요, 그림을 보면 바로 알 수 있습니다!위 그림 처럼 색이 서로 다르게 칠해질 수 있어야 이분 그래프 입니다. 쉽게 말해 니편 내편 가를 수 있어야 한다는 것입니다 ㅎㅎ저는 bfs로 풀이 했는데요, 현재 노드가 1번 팀이라면 다음 노드는 2번 팀 이런식으로 팀을 구분 했고, 만약 팀이 겹치게 된다면 바로 false를 리턴했습니다.아래는 풀이한 코드입니다 :)#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; visited(20001, 0);bool bfs(vector&lt;vector&lt;int&gt;&gt; g, int v) { queue&lt;int&gt; q; visited[v] = 1; q.push(v); while (!q.empty()) { int cur = q.front(); q.pop(); for (auto x : g[cur]) { if (!visited[x]) {// 편가르기!! visited[x] = (visited[cur] == 1 ? 2 : 1); q.push(x); } else if (visited[x] == visited[cur]) return false; } } return true;} int main(void) { int k; cin &gt;&gt; k; while (k-- &gt; 0) { int v, e; cin &gt;&gt; v &gt;&gt; e; vector&lt;vector&lt;int&gt;&gt; g(v + 1); for (int i = 1; i &lt;= v; i++) visited[i] = 0; for (int i = 0; i &lt; e; i++) { int a, b; cin &gt;&gt; a &gt;&gt; b; g[a].push_back(b); g[b].push_back(a); } bool flag = true; for (int i = 1; i &lt;= v; i++) { if (visited[i] == 0) { if (!bfs(g, i)) { flag = false; break; } } } cout &lt;&lt; (flag ? \"YES\" : \"NO\") &lt;&lt; endl; } return 0;}질문이나 지적사항은 댓글 부탁드립니다 :)" }, { "title": "[백준] 13460번 구슬 탈출 2", "url": "/posts/algorithm-bj-13460/", "categories": "Algorithm", "tags": "Baekjoon, algorithm", "date": "2019-09-15 09:46:00 +0800", "snippet": "풀이고려해야될 케이스가 많아서 생각보다 애를 먹었던 문제입니다.. ㅠ 우선 제가 풀이한 방식은 다음과 같습니다.1. 각 지점별로 사방으로 이동을 합니다. 2. 빨강, 파랑 둘다 ‘#’를 만나거나 서로 겹치게 되면 멈추고 그 자리를 기억합니다.   만약 그 중 ‘O’가 있다면 가능한지 불가능한지 구분해줍니다.   가능하다면 바로 그 횟수를 출력하면 되고, 불가능하다면 그 위치에서는 더이상 이동 하지 않습니다.여기에서 주의해야 할 부분은 visited를 빨강과 파랑 둘다 기록해줘야 한다는 것입니다.처음에는 어짜피 빨간색만 구멍에 들어가면 되니까 빨간공만 기록해주면 되지 않을까 하였지만, 빨간색은 같은 위치인데 파란색의 위치가 달라 결과가 달라지는 경우가 생기더군요.. !어떻게 보면 BFS로 간단히 풀 수 있는 문제였지만 생각보다 까다로웠던 문제였습니다.아래는 풀이한 코드입니다.#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;class PosInfo {public: int r_x, r_y, b_x, b_y, move, dir; // way =&gt; 1 = 아래, 2 = 오, 3 = 위, 4 = 왼 PosInfo(int r_x, int r_y, int b_x, int b_y, int move, int dir) { this-&gt;r_x = r_x; this-&gt;r_y = r_y; this-&gt;b_x = b_x; this-&gt;b_y = b_y; this-&gt;move = move; this-&gt;dir = dir; }};char map[10][10];bool visited[10][10][10][10];int move(PosInfo &amp;p) { bool isR_zero = false; bool isB_zero = false; while (true) { int x1 = p.r_x, x2 = p.b_x, y1 = p.r_y, y2 = p.b_y; if (p.dir == 1) { x1--; x2--; } else if (p.dir == 2) { y1++; y2++; } else if (p.dir == 3) { x1++; x2++; } else { y1--; y2--; } // 둘다 벽이면 break; if (map[x1][y1] == '#' &amp;&amp; map[x2][y2] == '#') break; // 지난 자리에 구멍이 있었는지 check if (map[x1][y1] == 'O') isR_zero = true; if (map[x2][y2] == 'O') isB_zero = true; // 만약 벽이면 변화된 좌표 원상복구 if (map[x1][y1] == '#') { x1 = p.r_x; y1 = p.r_y; } if (map[x2][y2] == '#') { x2 = p.b_x; y2 = p.b_y; } // 벽이 아니고 두 구슬이 겹치지 않을 때 좌표 이동 if (map[x1][y1] != '#' &amp;&amp; !(x1 == x2 &amp;&amp; y1 == y2)) { p.r_x = x1; p.r_y = y1; } if (map[x2][y2] != '#' &amp;&amp; !(x1 == x2 &amp;&amp; y1 == y2)) { p.b_x = x2; p.b_y = y2; } // 두 구슬이 겹치면 break; if (x1 == x2 &amp;&amp; y1 == y2) break; } // 빨강만 나가면 1 if (isR_zero &amp;&amp; !isB_zero) return 1; // 둘다 나가거나 파랑이 나가면 -1 else if (isR_zero || isB_zero) return -1; else return 0;}int bfs(PosInfo start, int n, int m) { queue&lt;PosInfo&gt; q; for (int i = 1; i &lt;= 4; i++) { PosInfo pos = start; pos.dir = i; q.push(pos); } visited[start.r_x][start.r_y][start.b_x][start.b_y] = true; while (!q.empty()) { PosInfo pos = q.front(); q.pop(); int result = move(pos); if (result == 1){ return pos.move + 1; } else { // move의 결과가 0일 경우와 빨강, 파란공 위치가 이전에 없었던 위치면 q에 추가 if (!visited[pos.r_x][pos.r_y][pos.b_x][pos.b_y] &amp;&amp; result == 0) { visited[pos.r_x][pos.r_y][pos.b_x][pos.b_y] = true; PosInfo temp = pos; temp.move++; for (int i = 1; i &lt;= 4; i++) { if (pos.dir != i) { temp.dir = i; q.push(temp); } } } } } return -1;}int main(void) { int n, m; cin &gt;&gt; n &gt;&gt; m; pair&lt;int, int&gt; r_pos, b_pos; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { cin &gt;&gt; map[i][j]; if (map[i][j] == 'R') r_pos = { i, j }; if (map[i][j] == 'B') b_pos = { i, j }; } } int result = bfs(PosInfo(r_pos.first, r_pos.second, b_pos.first, b_pos.second, 0, 0), n, m); if (result &lt;= 10) cout &lt;&lt; result; else cout &lt;&lt; -1; return 0;}질문이나 지적사항은 댓글로 남겨주시기 바랍니다 :)" }, { "title": "[백준] 2583번 영역 구하기", "url": "/posts/algorithm-bj-2583/", "categories": "Algorithm", "tags": "Baekjoon, algorithm", "date": "2019-09-11 14:23:00 +0800", "snippet": "풀이쉬운 문제인데 처음에 좀 헷갈렸습니다..  저 색칠된 부분이 좌표라고 생각했는데 그게 아니어서 당황했던거죠..ㅠ 그렇지만 주어진 좌표를 토대로 제 입맛에 맞게 (위 그림처럼) 새로운 2D array를 만들고 해결하면 간단하게 풀리는 문제였습니다!새로운 배열로 비어있는 부분을 BFS 탐색하였습니다.아래는 풀이한 코드입니다.#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int xpos[] = { 0, 1, -1, 0 };int ypos[] = { 1, 0, 0, -1 };int map[100][100]; int bfs(int x, int y, int m, int n) { queue&lt;pair&lt;int, int&gt;&gt; q; map[x][y] = 1; q.push({ x,y }); int area = 1; while (!q.empty()) { pair&lt;int, int&gt; pos = q.front(); q.pop(); for (int i = 0; i &lt; sizeof(xpos) / sizeof(int); i++) { int next_x = pos.first + xpos[i]; int next_y = pos.second + ypos[i]; if (next_x &gt;= 0 &amp;&amp; next_x &lt; m &amp;&amp; next_y &gt;= 0 &amp;&amp; next_y &lt; n) { if (!map[next_x][next_y]) { area++; map[next_x][next_y] = 1; q.push({ next_x,next_y }); } } } } return area;}int main(void) { int m, n, k; cin &gt;&gt; m &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; k; i++) { int y1, x1, y2, x2; cin &gt;&gt; y1 &gt;&gt; x1 &gt;&gt; y2 &gt;&gt; x2; // 직사각형 입력 if (x1 &gt; x2) swap(x1, x2); if (y1 &gt; y2) swap(y1, y2); // x, y를 큰 숫자 쪽에서 1씩 빼주면 // 그림과 같은 2D array를 만들수 있다. for (int i = x1; i &lt;= x2-1; i++) { for (int j = y1; j &lt;= y2-1; j++) { map[i][j] = 1; } } } vector&lt;int&gt; result; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (!map[i][j]) result.push_back(bfs(i, j, m, n)); } } sort(result.begin(), result.end()); cout &lt;&lt; result.size() &lt;&lt; endl; for (auto x : result) cout &lt;&lt; x &lt;&lt; ' '; return 0;}질문이나 지적사항은 댓글로 부탁드립니다 :)" }, { "title": "[백준] 14502번 연구소", "url": "/posts/algorithm-bj-14502/", "categories": "Algorithm", "tags": "Baekjoon, algorithm", "date": "2019-09-10 23:25:00 +0800", "snippet": "풀이처음에는 벽을 어떻게 세울까 엄청 고민을 했는데, 조건을 보니 N, M이 최대 8밖에 안되더군요!전부 0이라고 하더라도 총 가짓수가 64*63*62 = 249984개밖에 안되서 완전탐색을 진행했습니다.풀이 순서는1. 일단 재귀를 활용해서 벽 3개를 세팅2. bfs로 2 채우기3. 0인 개수 구하기아래는 풀이한 코드입니다.#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int xpos[] = { 0, 1, -1, 0 };int ypos[] = { 1, 0, 0, -1 };int map[8][8];int max_e = 0;int n, m;int bfs(int n, int m) { queue&lt;pair&lt;int, int&gt;&gt; q; // 맵이 항시 바뀌니 새로운 변수에 대입 후 bfs를 진행합니다. int temp[8][8]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { temp[i][j] = map[i][j]; if (temp[i][j] == 2) { q.push({ i,j }); } } } while (!q.empty()) { pair&lt;int, int&gt; pos = q.front(); q.pop(); for (int i = 0; i &lt; sizeof(xpos) / sizeof(int); i++) { int next_x = pos.first + xpos[i]; int next_y = pos.second + ypos[i]; if (next_x &gt;= 0 &amp;&amp; next_x &lt; n &amp;&amp; next_y &gt;= 0 &amp;&amp; next_y &lt; m) { if (temp[next_x][next_y] == 0) { q.push({ next_x,next_y }); temp[next_x][next_y] = 2; } } } } int result = 0; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { if (temp[i][j] == 0) result++; } } return result;}// 벽 3개를 설치하는 재귀 함수!void setWall(int cnt, int x, int y) { if (cnt == 3) { int result = bfs(n, m); if (result &gt; max_e) max_e = result; return; } for (int i = x; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { // map[i][j] == 0에서만 끝내면 중복되는 서치를 할 때가 있기 때문에 // 추가적인 조건을 달아줍니다.(i는 x부터 시작) if (map[i][j] == 0 &amp;&amp; ((i == x &amp;&amp; j &gt; y) || i &gt; x)) { map[i][j] = 1; setWall(cnt + 1, i, j); map[i][j] = 0; } } }}int main(void) { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { cin &gt;&gt; map[i][j]; } } setWall(0, 0, -1); cout &lt;&lt; max_e; system(\"pause\"); return 0;}질문이나 지적사항, 더 나은 방법이 있다면 답글 부탁드립니다:)" }, { "title": "[백준] 1260번 DFS와 BFS", "url": "/posts/algorithm-bj-1260/", "categories": "Algorithm", "tags": "Baekjoon, algorithm", "date": "2019-09-07 11:13:00 +0800", "snippet": "풀이가장 기본적인 DFS와 BFS를 구현하는 문제입니다!아래는 구현한 코드입니다. #include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt; gf(1001);bool visited[1001] = { false }; void bfs(int v) { queue&lt;int&gt; q; visited[v] = true; q.push(v); while (!q.empty()) { int cur = q.front(); cout &lt;&lt; cur &lt;&lt; ' '; q.pop(); for (int node : gf[cur]) { if (!visited[node]) { q.push(node); visited[node] = true; } } }} void dfs(int v) { visited[v] = true; cout &lt;&lt; v &lt;&lt; ' '; for (int node : gf[v]) { if (!visited[node]) { dfs(node); } }} int main(void) { int n, m, v; cin &gt;&gt; n &gt;&gt; m &gt;&gt; v; for (int i = 0; i &lt; m; i++) { int a, b; cin &gt;&gt; a &gt;&gt; b; gf[a].push_back(b); gf[b].push_back(a); } for (int i = 0; i &lt; gf.size(); i++) sort(gf[i].begin(), gf[i].end()); dfs(v); cout &lt;&lt; endl; memset(visited, false, sizeof(visited)); bfs(v); return 0;}질문이나 지적사항은 댓글 부탁드립니다 :)" }, { "title": "[백준] 1201번 NMK", "url": "/posts/algorithm-bj-1201/", "categories": "Algorithm", "tags": "Baekjoon, algorithm", "date": "2019-09-07 11:10:00 +0800", "snippet": "풀이이 문제는 N개의 수를 M개의 덩이로 나누어서 그를 역순으로 하는 문제 입니다.우선,M + K - 1 &lt;= N &lt;= M * K이 조건에 해당할 때만 정답이 나올 수 있는데요,먼저 M + K -1 &lt;= N인 경우는 증가와 감소가 최대 정수 하나를 반드시 포함하기에 어떻게 보면 당연한 조건 입니다.위 그림의 경우 M + K - 1 = N 이고 M이나 K구간의 길이가 M,K보다 작을 수 있으니(321 654 의 경우는 M은 2인데 최대정수 전 까지의 길이는 3입니다.) N이 이보다는 크겠죠?그리고 M * K 의 경우는 비둘기집 원리를 통해 증명할 수 있습니다.(비둘기집의 원리 - mathsolver님의 글을 참조. https://steemit.com/kr/@mathsolver/2-1-1)간단하게 이 문제의 경우를 보면, N개의 수를 M개의 덩이로 나누어서 풀어야 하는데, 그렇게 되면N = M * N/M + r(나머지) 이렇게 표현할 수 있습니다.그리고 나머지는 0보다 크거나 같겠죠?그러면 N/M 을 K로 대입해보면N/M &lt;= K (r이 0일 경우는 N/M = K 겠지만 클 경우는 N/M이 K보다 작아야 식이 성립합니다.)-&gt; N &lt;= MK 를 도출해낼 수 있습니다.따라서,1. M + K - 1 &lt;= N &lt;= M * K2. N개의 수를 M개씩 나누어 풀이아래는 위 사항들을 적용하여 풀이한 코드입니다.#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;bool desc(int a, int b) { return a &gt; b;}int find(vector&lt;int&gt; arr, int inc, int dec) { int len = arr.size(); if (inc - 1 &gt; len - dec || len-dec &lt; 0) { return 0; } vector&lt;int&gt; newArr; for (auto x : arr) newArr.push_back(x); sort(newArr.begin() + (len - dec), newArr.end(), desc); if (inc - 1 == len - dec) { for (auto x : newArr) cout &lt;&lt; x &lt;&lt; ' '; return 1; } else { vector&lt;int&gt; nextArr; for (int i = 0; i &lt; len - dec; i++) nextArr.push_back(newArr[i]); int result = 0; for (int i = 2; i &lt;= dec; i++) { result = find(nextArr, inc - 1, i); if (result) break; } if (result) { for (int i = len - dec; i &lt; len; i++) cout &lt;&lt; newArr[i] &lt;&lt; ' '; return 1; } else return 0; }}int main(){ int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; vector&lt;int&gt; arr; for (int i = 1; i &lt;= n; i++) { arr.push_back(i); } if (!find(arr, m, k)) cout &lt;&lt; -1; return 0;}" }, { "title": "[백준] 2816번 디지털 티비", "url": "/posts/algorithm-bj-2816/", "categories": "Algorithm", "tags": "Baekjoon, algorithm", "date": "2019-08-27 15:22:00 +0800", "snippet": "풀이답이 하나만 정해져있는 것이 아닌 문제였는데요, 저는 예제처럼 33이 아닌 1과 4만 사용해서 Greedy하게 해결했습니다.단순하게 KBS1 찾아서 제일 위로 올리고 KBS2 찾아서 그 위로 올려버렸습니다.이렇게 하면 만약 채널 수가 최대값(100) 이더라도 눌러야할 버튼 수가 400번이 안됩니다.(문제 조건은 500개 미만)아래는 해당 코드입니다 :)#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(void) { int n; cin &gt;&gt; n; int kbs1_idx, kbs2_idx; for (int i = 0; i &lt; n; i++) { string chnl; cin &gt;&gt; chnl; if (chnl == \"KBS1\") kbs1_idx = i; if (chnl == \"KBS2\") kbs2_idx = i; } if (kbs1_idx &gt; kbs2_idx) kbs2_idx++; for (int i = 0; i &lt; kbs1_idx; i++) cout &lt;&lt; '1'; for (int i = 0; i &lt; kbs1_idx; i++) cout &lt;&lt; '4'; if (kbs2_idx != 1) { for (int i = 0; i &lt; kbs2_idx; i++) cout &lt;&lt; '1'; for (int i = 1; i &lt; kbs2_idx; i++) cout &lt;&lt; '4'; } return 0;}질문이나 지적사항 답글 부탁드립니다 :)" }, { "title": "[백준] 3109번 빵집", "url": "/posts/algorithm-bj-3109/", "categories": "Algorithm", "tags": "Baekjoon, algorithm", "date": "2019-08-19 15:01:00 +0800", "snippet": "풀이이 문제는 DFS를 활용해서 Greedy 하게 풀 수 있는 문제입니다.DFS를 활용한다는 건 점을 하나하나 이어가면서 x면 되돌아오는 식으로 하는 것으로 쉽게 이해할 수 있는데,여기서 가장 중요한게 Greedy 부분입니다.만약 DFS만 활용했을 경우에는20 20 ………………x.………………x.………………x.  (중략…)………………..이런 입력에 대해서 시간초과가 나오게 됩니다.x가 끝쪽에 있으니 거의 모든 경우의 경로를 다 돌아보게 되기 때문입니다.그렇기 때문에 Greedy를 활용해 주어야 합니다. 이미 실패한 경로는 다시 가더라도 어짜피 결과는 FAIL 입니다.그러므로 성공한 경로든 실패한 경로든 전부 방문한 걸로 치고 다시는 방문하지 않게 하는 것이 Key Point 입니다.아래는 풀이한 코드입니다.#include &lt;iostream&gt;using namespace std;char map[10000][500];int xpos[] = { -1,0,1 };int cnt = 0;bool dfs(int x, int y, int r, int c) { if (y == c - 1) { cnt++; return true; } for (int i = 0; i &lt; sizeof(xpos) / sizeof(int); i++) { int next_x = x + xpos[i]; int next_y = y + 1; if (next_y &lt; c &amp;&amp; next_x &gt;= 0 &amp;&amp; next_x &lt; r) { if (map[next_x][next_y] != 'x') { bool result = dfs(next_x, next_y, r, c); // 결과에 상관없이 방문했다는 의미로 'x'표를 해줍니다. // 실패했든 성공했든 다시는 그 경로로 갈 일이 없기 때문!! map[next_x][next_y] = 'x'; if (result) return true; } } } return false;}int main(void) { int r, c; cin &gt;&gt; r &gt;&gt; c; for (int i = 0; i &lt; r; i++) { for (int j = 0; j &lt; c; j++) { cin &gt;&gt; map[i][j]; } } for(int i=0;i&lt;r;i++) dfs(i, 0, r, c); cout &lt;&lt; cnt; return 0;}질문이나 지적사항은 댓글 부탁드립니다 :)" }, { "title": "[백준] 8980번 택배", "url": "/posts/algorithm-bj-8980/", "categories": "Algorithm", "tags": "Baekjoon, algorithm", "date": "2019-08-09 23:59:00 +0800", "snippet": "풀이처음에 많이 헤맸지만.. 결국 각 마을 마다 실을 수 있는 공간을 체크해나가며 해결할 수 있는 문제였습니다.문제를 해결하기 위해선 우선 도착지를 기준으로 오름차순 정렬 해주어야 합니다. 출발지는 상관 없습니다. 왜 그런지는 이 후에 제가 설명드리는 과정을 보면 이해할 수 있을 겁니다:)1. 출발지부터 도착지 - 1 까지에서 트럭 잔여용량이 가장 적은 곳 찾기2. 실을 박스의 수 정하기 (1에서 찾은 잔여용량보다 박스의 수가 많다면 1에서의 결과값만큼 박수 싣기)3. 출발지부터 도착지 - 1 까지 실을 박수의 수만큼 잔여용량을 줄여주기이렇게 3가지를 차례대로 반복해줍니다.문제상의 예제를 바탕으로 풀이해보겠습니다. 마을 1 2 3 잔여용량 40 40 40 우선, 초기상태 입니다. 마을은 4까지 있지만 4는 어짜피 도착지이니 표기할 필요가 없어서 3까지만 표기하였습니다.그리고 각 마을에서의 트럭 잔여용량을 전부 최대치로 초기화 해놓습니다. 배송할 목록을 도착지를 기준으로 오름차순 정렬하면 다음과 같겠죠??1 2 101 3 202 3 101 4 302 4 203 4 20이를 바탕으로 위에서부터 차례대로 써먹습니다!! ㅎㅎ 마을 1 2 3 잔여용량 40 - 10 = 30 40 40  1 2 10 1. 마을 1 &lt;= x &lt; 2에서 제일 적은 잔여용량은 40.2. 실을 용량(10) &lt; 잔여용량(40) 이므로 전량(10) 싣기.3. 마을 1 &lt;= x &lt; 2 까지 실은 박스 수만큼 빼주기.--&gt; 현재까지 운반한 박스 수 = 10 마을 1 2 3 잔여용량 30 - 20 = 10 40 - 20 = 20 40  1 3 20 1. 마을 1 &lt;= x &lt; 3에서 제일 적은 잔여용량은 30.2. 실을 용량(20) &lt; 잔여용량(30) 이므로 전량(20) 싣기.3. 마을 1 &lt;= x &lt; 3 까지 실은 박스 수만큼 빼주기.--&gt; 현재까지 운반한 박스 수 = 30 마을 1 2 3 잔여용량 10 20 - 10 = 10 40  2 3 10 1. 마을 2 &lt;= x &lt; 3에서 제일 적은 잔여용량은 20.2. 실을 용량(10) &lt; 잔여용량(20) 이므로 전량(10) 싣기.3. 마을 2 &lt;= x &lt; 3 까지 실은 박스 수만큼 빼주기.--&gt; 현재까지 운반한 박스 수 = 40 마을 1 2 3 잔여용량 10 - 10 = 0 10 - 10 = 0 40 - 10 = 30 1 4 301. 마을 1 &lt;= x &lt; 4에서 제일 적은 잔여용량은 10.2. 실을 용량(30) &gt; 잔여용량(10) 이므로 일부분(10) 싣기.3. 마을 1 &lt;= x &lt; 4 까지 실은 박스 수만큼 빼주기.--&gt; 현재까지 운반한 박스 수 = 50 마을 1 2 3 잔여용량 0 0 30 2 4 201. 마을 2 &lt;= x &lt; 4에서 제일 적은 잔여용량은 02. 용량 0이므로 옮길 박스가 없음.--&gt; 현재까지 운반한 박스 수 = 50 마을 1 2 3 잔여용량 0 0 30 - 20 = 10 3 4 201. 마을 3 &lt;= x &lt; 4에서 제일 적은 잔여용량은 20.2. 실을 용량(20) &lt; 잔여용량(30) 이므로 전량(20) 싣기.3. 마을 3 &lt;= x &lt; 4 까지 실은 박스 수만큼 빼주기.--&gt; 현재까지 운반한 박스 수 = 70이러한 프로세스로 정답은 70!! 만약 도착지가 내림차순이거나 뒤죽박죽이라면 절대 이렇게 진행할 수가 없습니다. 만약 총 용량 40,1 5 102 3 403 4 40이런 배송지가 있고 이순서대로 진행한다하면 답은 70이겠지만올바른 답은 마을 2와 3에서 40번씩 옮길 수 있어서 답은 80이 되겠죠? 이처럼 중간에 있는 마을들이 어떨지 알 수 없기 때문에 도착지를 기준으로 오름차순 필수! 아래는 풀이한 코드입니다 :)#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;class Delivery {public: int from; int to; int cnt; Delivery(int from, int to, int cnt) { this-&gt;from = from; this-&gt;to = to; this-&gt;cnt = cnt; }}; // 도착지 기준 오름차순 정렬!bool cmp(Delivery a, Delivery b) { if (a.to &lt; b.to) return true; else return false;} int main(void) { int n, c, m; cin &gt;&gt; n &gt;&gt; c &gt;&gt; m; vector&lt;Delivery&gt; list; vector&lt;int&gt; left(n + 1, c); int box_cnt = 0; for (int i = 0; i &lt; m; i++) { int from, to, cnt; cin &gt;&gt; from &gt;&gt; to &gt;&gt; cnt; list.push_back(Delivery(from, to, cnt)); } sort(list.begin(), list.end(), cmp); for (auto d : list) { // 제일 공간이 적게 남은 개수 찾기 int min = left[d.from]; for (int i = d.from + 1; i &lt; d.to; i++) { if (min &gt; left[i]) min = left[i]; } // 실을 박스의 수(만약 min보다 많다면 min만큼만 싣기) int cnt = d.cnt; if (min &lt; cnt) cnt = min; // 최종 박스 수에 + box_cnt += cnt; // from ~ to - 1 까지 cnt만큼 빈공간 줄이기 for (int i = d.from; i &lt; d.to; i++) { left[i] -= cnt; } } cout &lt;&lt; box_cnt; return 0;}질문이나 지적사항은 댓글 부탁드립니다:)" }, { "title": "[백준] 9576번 책 나눠주기", "url": "/posts/algorithm-bj-9576/", "categories": "Algorithm", "tags": "Baekjoon, algorithm", "date": "2019-07-30 14:42:00 +0800", "snippet": "풀이정답 비율을 보고 쫄아있었는데.. 설마 이게 맞겠어 하며 제출했는데 바로 맞아버려서 생각보다 너무 간단하게 풀려 조금 허무했던 문제입니다.책의 범위 a~b에서 b를 기준으로 우선 오름차순 정렬 하면, 어짜피 최고로 빌릴수 있는 숫자는 b까지 입니다.그래서 a가 무슨 숫자가 오든 상관 없이 순서대로 주면 꼬일 일이 없습니다.하지만 a를 기준으로 정렬한다면 최고로 빌릴 수 있는 숫자가 뒤죽박죽이 되면서 꼬여버리게 됩니다.아래의 예를 봅시다  1 5             2 2  1 5             3 3  1 5      vs    1 5  2 2             1 5  3 3             1 5(a 기준)       (b 기준)a를 기준으로 정렬했다면 1, 2, 3번 책밖에 주지를 못합니다.하지만 반대로 b를 기준으로 했다면 2, 3, 1, 4, 5 순서로 모든 책을 빌려줄수 있겠죠??자, 풀이를 정리해보자면,1. 먼저 ai, bi쌍을 pair로 묶어 입력 받습니다.2. pair의 second를 기준으로 오름차순, 그다음 first를 기준으로 오름차순 정렬을 해줍니다.3. pair 배열을 순차적으로 돌면서 해당 범위 안에 있는 책을 줍니다.(이미 준 책은 제외)예를 들자면 1 4              1 32 3              2 31 3      =&gt;    3 31 5              1 43 3              1 5위처럼 입력받은 pair 쌍들을 second, first 기준으로 오름차순 해줍니다.다음 처음 pair부터 돌면서 boolean 배열을 하나 두어 이미 준책은 true로 기록해둡니다.아래는 풀이한 코드입니다.#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std; // second를 기준으로 우선 정렬하고 같을 경우 first를 기준으로 오름차순!bool cmp(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) { if (a.second &lt; b.second) return true; else { if (a.second == b.second) { if (a.first &lt; b.first) return true; } return false; }} int main(void) { int t; cin &gt;&gt; t; while (t-- &gt; 0) { int n, m; cin &gt;&gt; n &gt;&gt; m; pair&lt;int, int&gt; student[1000]; bool chosen[1000] = { false }; for (int i = 0; i &lt; m; i++) { int a, b; cin &gt;&gt; a &gt;&gt; b; student[i] = make_pair(a, b); } sort(student, student + m, cmp); int max_cnt = 0; // 배열을 순차적으로 돌면서 해당 범위의 책 중 안 빌려준 책을 true로!! for (int i = 0; i &lt; m; i++) { for (int j = student[i].first; j &lt;= student[i].second; j++) { if (!chosen[j]) { chosen[j] = true; max_cnt++; break; } } } cout &lt;&lt; max_cnt &lt;&lt; endl; } return 0;}질문이나 지적사항은 댓글 부탁드립니다 :)" }, { "title": "[백준] 1543번 문서 검색", "url": "/posts/algorithm-bj-1543/", "categories": "Algorithm", "tags": "Baekjoon, algorithm", "date": "2019-07-30 13:48:00 +0800", "snippet": "백준 알고리즘 1543번 문서 검색 문제풀이문제문서와 검색하려는 단어가 주어졌을 때, 그 단어가 최대 몇 번 중복되지 않게 등장하는지 구하는 문제 입니다.예로, 문서가 abababa가 있을때 찾으려는 문장이 ababa 라면 중복되지 않게 1번 등장합니다.풀이이 문제는 KMP 문자열 탐색 알고리즘을 쓰면 간단하게 해결되는 문제 입니다. 제 블로그의 문자열 탐색 알고리즘 KMP에 코드와 함께 설명을 작성해 두었습니다 :)아래는 문제 풀이한 코드입니다.#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std; // 패턴의 중복되는 부분(수치) 찾기vector&lt;int&gt; getPi(string pattern) { // 모두 0으로 세팅(중복되는 거 모두 없다고 우선 세팅) vector&lt;int&gt; p(pattern.length(), 0); int correct_cnt = 0; for (int i = 1; i &lt; pattern.length(); i++) { // 해당 부분이 일치할 시에 일치하는 숫자(correct_cnt)만 증가시키고 p[i]값 set(마지막부분) if (pattern[i] == pattern[correct_cnt]) correct_cnt++; else { // 불일치할 경우 중복되는 만큼(p[correct_cnt-1]의 수치) correct_cnt를 변경 // correct_cnt는 1부터, p[i]는 0부터이므로 -1을 해준다 // 그리고 i-1 하여 다시한번 해당 index를 반복한다. if (correct_cnt &gt; 0) { correct_cnt = p[correct_cnt - 1]; i--; continue; } // 만약 correct_cnt가 0이라면 일치하는게 없는 것이므로 그대로 p[i]에 세팅해준다. } p[i] = correct_cnt; } return p;} // KMP 알고리즘int kmp(vector&lt;int&gt; p, string pattern, string sentence, int start_idx) { int correct_cnt = 0; int pattern_len = pattern.length(); for (int i = start_idx; i &lt; sentence.length(); i++) { if (sentence[i] == pattern[correct_cnt]) correct_cnt++; else { if (correct_cnt &gt; 0) { correct_cnt = p[correct_cnt - 1]; i--; } } if (correct_cnt == pattern_len) return i; } return -1;} int main(void) { string sentence; string pattern; // 띄어쓰기가 있을 경우를 대비해서 getline 사용! getline(cin, sentence); getline(cin, pattern); vector&lt;int&gt; p; p = getPi(pattern); // 총 해당 패턴이 몇개 나왔는지 결과 측정 변수 int result = 0; // 문장에서 문장 검색을 시작할 위치(index) int start_idx = 0; while (true) { int kmp_result = kmp(p, pattern, sentence, start_idx); if (kmp_result &gt;= 0) { result++; start_idx = kmp_result + 1; } else break; } cout &lt;&lt; result; return 0;}질문이나 지적사항은 댓글 부탁드립니다 :)" }, { "title": "[백준] 1202번 보석도둑", "url": "/posts/algorithm-bj-1202/", "categories": "Algorithm", "tags": "Baekjoon, algorithm", "date": "2019-07-26 12:05:00 +0800", "snippet": "백준 알고리즘 1202번 보석도둑 문제풀이문제각 보석은 무게 M와 가격 V를 가지고 있다.가방이 K개 있고, 각 가방에 담을 수 있는 최대 무게는 C이다. 가방에는 최대 한 개의 보석만 넣을 수 있다.훔칠 수 있는 보석의 최대 가격을 구하는 프로그램을 작성하시오.풀이복잡하게 생각할수록 어려워지는 문제인것 같습니다. 풀이 방향은 맞췄지만 너무 복잡하여 예외 처리가 되질 않아 자꾸 틀렸습니다.. ㅠㅠ꾸준함(https://jaimemin.tistory.com/760)님의 블로그를 참조하여 코드를 단순하고 깔끔하게 수정하였습니다.풀이 방식의 핵심은 Max-Heap을 사용하는 것입니다. 해당 가방의 무게만큼 heap에 넣고 최대값만 쏙쏙 빼내는 방식입니다.1. 가방과 보석을 모두 무게를 기준으로 오름차순 정렬합니다.2. i번째 가방의 무게에 맞는 만큼 Priority Queue에 보석 가격들을 넣어줍니다.3. PQ의 top에 있는 것이 가장 높은 가격이기에 결과 값에 top의 값을 넣어주고 pop 합니다.4. 가방의 개수(k) 만큼 반복합니다. 아래는 풀이한 코드입니다 !! #include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std; int main(void) { int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; bag(k); vector&lt;pair&lt;int, int&gt; &gt; jewel(n); long long max_jewel = 0LL; priority_queue&lt;int&gt; pq; for (int i = 0; i &lt; n; i++) { int m, v; cin &gt;&gt; m &gt;&gt; v; jewel[i] = make_pair(m, v); } for (int i = 0; i &lt; k; i++) cin &gt;&gt; bag[i]; // 오름차순 정렬 sort(jewel.begin(), jewel.end()); sort(bag.begin(), bag.end()); for (int i = 0, jewel_idx = 0; i &lt; k; i++) { while (jewel_idx &lt; n &amp;&amp; jewel[jewel_idx].first &lt;= bag[i]) { // 가방의 무게보다 작거나 같은 보석들을 pq에 넣어줍니다. pq.push(jewel[jewel_idx++].second); } if (!pq.empty()) { // 젤 위의 값(최대값)을 넣어주고 pq에서 빼버립니다. max_jewel += (long long)pq.top(); pq.pop(); } } cout &lt;&lt; max_jewel; return 0;}질문이나 지적사항 댓글 부탁드립니다 :)" }, { "title": "문자열 탐색 알고리즘 KMP", "url": "/posts/algorithm-kmp/", "categories": "Algorithm", "tags": "algorithm", "date": "2019-07-25 16:24:00 +0800", "snippet": "특별한 의미는 없고 Knuth, Morris, Pratt 이 세 사람이 만든 알고리즘이라 하여 KMP라고 하네요 ㅎㅎ  A B A C A B A B A B A B         만약 위와 같이 ABACABAB문장에서 ABAB를 찾는다 할때 보통 ABC를 한칸씩 오른쪽으로 옮기면서 비교하는 방법을 생각하기 쉽습니다. 하지만 그렇게하면 loop의 이중 중첩으로 문장이 매우 길어졌을 때 시간 복잡도가 (On2)이 되어 시간초과가 나곤 합니다.그래서 나온것이 이 알고리즘! 간단히 말하면, 찾고자하는 패턴의 반복되는 부분만큼(A)은 건너뛰어서 불필요한 검색(B)을 줄이는 것입니다. 위의 예를 보면 앞의 AB와 뒤 AB가 겹치고 2자리까지 일치했습니다. 이때 겹치는 2칸만큼 건너띄워서 검색을 합니다. A B A C A B A B A B A B             A B A B           A B A B           A B A B 2번째에서 2칸이 건너띄워졌는데 왜 그런지 잘 이해가 가지 않을 수 있습니다. 하지만 아래 흐름을 따라오시면 자연스레 이해가 되실 겁니다 :)먼저 빨간 A부분을 구해야겠죠?? 여러 블로그에서 구하는 것에 대한 설명을 봤는데 정확한 설명이 많이 없고 그냥 앞뒤로 같은 것의 개수를 헤아리는 식의 설명이 많았습니다. 하지만 이렇게 하니 안되는 경우가 발생하더군요.  0 A 0 1 AB 0 2 ABA 1 3 ABAB 2 위 같은 경우는 상관 없지만, 아래처럼 AAAA인 경우는 헷갈립니다. 0 A 0 1 AA 1 2 AAA 1?? 3 AAAA 2?? 물론.. 이렇게 얘기하는건 정답이 아니라는 거겠죠??정확한 방법은 각 index의 prefix와 postfix를 비교하여 자신을 제외한 것 중 길이 최대인 것을 세는 것입니다.ABAB에서, index prefix postfix p[i] 0 A A 0 1 A, AB B, AB 0 2 A, AB, ABA A, BA, ABA 1 3 A, AB, ABA, ABAB B, AB, BAB, ABAB 2 초록색은 자기 자신이라 제외합니다. 빨간색이 겹치는 것이고 그 길이가 답이 됩니다!AAAA를 보면,  index prefix postfix p[i] 0 A A 0 1 A, AA A, AA 1 2 A, AA, AAA A, AA, AAA 2 3 A, AA, AAA, AAAA A, AA, AAA, AAAA 3 겹치는(빨간색) 것 중 제일 긴 것으로 작성하면 오른쪽과 같은 결과가 나옵니다.이를 통해서 얼마나 건너뛸지를 알 수 있습니다.저 숫자만큼의 prefix와 postfix가 같다는 것이기에 그만큼 움직일 수 있는 것입니다.제일 처음의 예를 다시 보면,| A | B | A | C | A | B | A | B || — | — | — | — | — | — | — | — | A B A B             A B A B     index 2까지가 일치했으니 p[2] = 1인것을 활용하면 됩니다.이 말은 즉, 접두사와 접미사가 1개만 일치한다는 것이므로 2칸 이동하여빨간 부분처럼 접두사와 접미사 겹치는 부분이 1개가 되게끔 해주는 것입니다.그러면 이를 바탕으로 다른 문장에서 패턴 찾는 연습을 해보겠습니다. 문장  :  ABABCABABA패턴  :  ABABA우선, p[i]값을 찾아야겠죠??위에처럼 시각적으로 찾는 방법 말고 프로그래밍적으로 하면, 패턴을 옆으로 옮기며 prefix와 postfix를 비교하면 됩니다.index == 0 일때, 자기자신뿐이기에 p[0] = 0,index == 1 일때,  0 1 2 3 4       A B A B A         A B A B A     AB  AB이렇게 보면 접두, 접미사가 일치하지 않으니 p[1] = 0index == 2 일때, 0 1 2 3 4       A B A B A           A B A B A   하나가 일치하죠? 고로 p[2] = 1 0 1 2 3 4       A B A B A           A B A B A   두개 일치! p[3] = 2 0 1 2 3 4       A B A B A           A B A B A   마지막으로 p[4] = 3 정리하면 p[i] = { 0, 0, 1, 2, 3 } 입니다. 여기서는 index가 1일때만 불일치가 나왔고 나머지는 다 일치가 나왔지만, 만약 뒤에서 불일치가 나왔다 한다면,이전의 p[i] 정보를 이용해서 건너뛸 수도 있습니다. 만약 ABABABC          ABABABC이런 상황이라면 p[3]을 활용하여 두칸 뒤로 옮겨서 불필요한 비교를 피할 수 있다는 것입니다.아래에서 보일, 패턴 찾는 것을 p[i]값 찾는데서도 활용할 수 있다는 얘기입니다 :)그러면 이제 패턴을 찾아보겠습니다. 0 1 2 3 4 5 6 7 8 9 A B A B C A B A B A A B A B A               A B A B A               A B A B A             A B A B A 첫번째는 3번째까지 겹치니 p[3] = 2 를 통해 2칸 이동,두번째는 p[1] = 0 이기에 다음 index쪽으로 바로 이동,세번째는 0번째부터 일치하지 않으니 바로 다음칸으로 이동합니다.위 과정을 코드로 작성해 봤습니다.#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std; // 패턴의 중복되는 부분(수치) 찾기vector&lt;int&gt; getPi(string pattern) { // 모두 0으로 세팅(중복되는 거 모두 없다고 우선 세팅) vector&lt;int&gt; p(pattern.length(), 0); int correct_cnt = 0; for (int i = 1; i &lt; pattern.length(); i++) { // 해당 부분이 일치할 시에 일치하는 숫자(correct_cnt)만 증가시키고 p[i]값 set(마지막부분) if (pattern[i] == pattern[correct_cnt]) correct_cnt++; else { // 불일치할 경우 중복되는 만큼(p[correct_cnt-1]의 수치) correct_cnt를 변경 // correct_cnt는 1부터, p[i]는 0부터이므로 -1을 해준다 // 그리고 i-1 하여 다시한번 해당 index를 반복한다. if (correct_cnt &gt; 0) { correct_cnt = p[correct_cnt - 1]; i--; continue; } // 만약 correct_cnt가 0이라면 일치하는게 없는 것이므로 그대로 p[i]에 세팅해준다. } p[i] = correct_cnt; } return p;} // KMP 알고리즘int kmp(vector&lt;int&gt; p, string pattern, string sentence) { int correct_cnt = 0; int pattern_len = pattern.length(); for (int i = 0; i &lt; sentence.length(); i++) { if (sentence[i] == pattern[correct_cnt]) correct_cnt++; else { if (correct_cnt &gt; 0) { correct_cnt = p[correct_cnt - 1]; i--; } } // if (correct_cnt == pattern_len) return i; } return -1;} int main(void) { string sentence; string pattern; // 띄어쓰기가 있을 경우를 대비해서 getline 사용! getline(cin, sentence); getline(cin, pattern); vector&lt;int&gt; p; p = getPi(pattern); cout &lt;&lt; kmp(p, pattern, sentence); return 0;}질문이나 오류 지적 사항등은 댓글 부탁드립니다 :)참고) 왜모르는가?(https://vvshinevv.tistory.com/2)" }, { "title": "[백준] 1969번 DNA", "url": "/posts/algorithm-bj-1969/", "categories": "Algorithm", "tags": "Baekjoon, algorithm", "date": "2019-07-18 15:12:00 +0800", "snippet": "백준 알고리즘 1969번 DNA 문제풀이문제Hamming Distance(이하 HD)란 길이가 같은 두 DNA가 있을 때, 각 위치의 문자가 다른 것의 개수입니다. 예로, AGCAT와 GGAAT의 HD는 0, 3번째가 다르므로 2입니다.DNA들이 주어져 있을 때 HD의 합이 가장 작은 새로운 DNA s를, 그리고 이 s는 사전순서로 가장 앞에 오는 것 구하기! DNA가 a, b, c, d 이렇게 4개 주어졌다 하면, s와 a의 HD, s와 b의 HD, … , s와 d의 HD 를 합한게 최소가 되는 s를 구하라는 의미입니다.풀이생각보다 단순하게 Greedy하게 풀 수 있는 문제입니다.문제상의 예시를 바탕으로 보면TATGATACTAAGCTACAAAGATCCTGAGATACTAAGATGT우선 0번째 index를 보면 T가 4개로 제일 많으니 s에 T를 추가해줍니다. 그런식으로 7번째 index까지 진행하면 답을 도출할 수 있는 간단한 문제입니다. 주의할 것은 만약 A가 2개 T도 2개라 하면 사전순이기에 A를 추가해 줘야 합니다.저는 알파벳 ascii code를 활용해서 했습니다사실 문자는 4종류뿐인데 26개의 알파벳 배열을 사용하다보니 메모리 측면에서 비효율적이긴 하지만문제 해결에 있어서 큰 차이는 아니다보니 편의상 그렇게 진행하였습니다.아래는 해당 코드 입니다!#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(void) {\tint n, m;\tcin &gt;&gt; n &gt;&gt; m;\tstring dna[1000];\tint alphabet[26];\tstring s = \"\";\tint cnt = 0;\tfor (int i = 0; i &lt; n; i++) cin &gt;&gt; dna[i];\tfor (int i = 0; i &lt; m; i++) {\t\tint max = 0;\t\tfill_n(alphabet, 26, 0);\t\t// 알파벳 중복되는 개수 구하기\t\tfor (int j = 0; j &lt; n; j++) {\t\t\tint idx = dna[j][i] - 65;\t\t\talphabet[idx]++;\t\t\tif (max &lt; alphabet[idx]) max = alphabet[idx];\t\t}\t\t// 알파벳 중 중복되는 개수가 제일 많으면서 \t\t// 사전상 제일 앞에 오는 문자 찾기\t\tfor (int j = 0; j &lt; 26; j++) {\t\t\tif (alphabet[j] == max) {\t\t\t\ts += (char)(j + 65);\t\t\t\tbreak;\t\t\t}\t\t}\t\t// DNA의 i번째 문자들 중 s의 i번째 문자와 다른 것들의 수 ++\t\tfor (int j = 0; j &lt; n; j++)\t\t\tif (s[i] != dna[j][i]) cnt++;\t}\tcout &lt;&lt; s &lt;&lt; '\\n' &lt;&lt; cnt;\treturn 0;}질문이나 지적사항은 댓글 부탁드립니다 :)" }, { "title": "[백준] 1449번 수리공 항승", "url": "/posts/algorithm-bj-1449/", "categories": "Algorithm", "tags": "Baekjoon, algorithm", "date": "2019-07-15 23:30:00 +0800", "snippet": "백준 알고리즘 1449번 수리공 환승 문제풀이문제파이프의 가장 왼쪽에서 정수만큼 떨어진 거리만 물이 샌다. 각 새는 포인트를 길이가 L인 테이프를 붙여 막는다.막을때 앞뒤 각 0.5의 간격을 두어야 하고 테이프를 자르거나 겹쳐붙일 수 없다. 사용되는 테이프의 개수는?풀이간단한 문제인데 생각보다 너무 복잡하게 풀어서 재정리 후 코드를 간소화 시켜보았습니다.테이프의 시작점을 잡고 start(시작점) + L(테이프길이)로 비교하며 두가지 케이스로 나누었습니다.1. 현재 구멍난 곳이 start + L 보다 크거나 같을 때2. 현재 구멍난 곳이 start + L 보다 작을 때1번의 경우는 마지막 구멍일 경우에 tape 개수를 한번 더 + 해주었고2번의 경우는 마지막 구멍이 아닐 경우에는 continue, 마지막일 경우에만 + 해주어 마무리 했습니다.아래는 풀이한 코드입니다.#include &lt;iostream&gt;using namespace std;int main(void) { int n, l; cin &gt;&gt; n &gt;&gt; l; int leak[1000]; int tape_cnt = 0; for (int i = 0; i &lt; n; i++) cin &gt;&gt; leak[i]; sort(leak, leak + n); int start = leak[0]; for (int i = 0; i &lt; n; i++) { if (i - 1 &gt;= 0 &amp;&amp; start+l &lt;= leak[i]) { tape_cnt++; if (i == n - 1) tape_cnt++; start = leak[i]; } else if (start+l &gt; leak[i] &amp;&amp; i == n-1) { tape_cnt++; } } cout &lt;&lt; tape_cnt; return 0;}질문이나 지적하실 부분은 댓글로 부탁드립니다:)" }, { "title": "[백준] 2352번 반도체 설계", "url": "/posts/algorithm-bj-2352/", "categories": "Algorithm", "tags": "Baekjoon, algorithm", "date": "2019-07-13 10:52:00 +0800", "snippet": "백준 알고리즘 2352번 반도체 설계 문제풀이문제위 사진처럼 반도체 설계를 하는데 선들이 겹치지 않으면서 최대 몇개까지 연결할 수 있는지 구하는 문제입니다.풀이복잡하게 생각이 들지만 Greedy 방식으로 생각보다 단순하게 풀 수 있는 문제였습니다.우선 안겹치는 선들을 cache라는 변수에 저장을 해나가는 방식입니다. 크게 아래 두가지 경우로 나누면 되는데, 1. 다음 포트와 연결된 선이 현재 최신 cache와 연결된 선과 겹칠 경우2. 다음 포트와 연결된 선이 현재 최신 cache와 연결된 선과 겹치지 않을 경우1번의 경우에는 겹치지 않으니 그냥 cache에 추가해주면 되고,2번의 경우에는 STL의 lower_bound를 활용해서 다음 포트와 연결된 선을 기준으로 그것보다 큰 가장 작은 정수 값을 찾아 교체합니다.* lower_bound는 찾으려는 값이 없으면 그 값보다 큰 가장 작은 정수 값을 찾습니다.   그리고 함수 반환형이 ForwardIterator로, 아래 코드처럼 cache를 빼주면 순수 index를 도출해 낼 수 있습니다.사실 위 예시 기준으로 cache를 마지막에 찍어보면 위 그림과 같은 답은 도출되지 않습니다. 2-2가 연결되야 하는데 5-1이 연결되있는 등 겹치게 됩니다.하지만 답에서 요구하는 것은 최대 몇개까지냐 이므로 굳이 고려하지 않았습니다. 어짜피 뒤에 더 큰 숫자의 포트와 연결되어 있기에 아래 연결된 포트들은 개수를 측정하는데 별 의미가 없었습니다.아래 코드의 결과 cache안에는 2-2, 4-3, 6-5가 아닌 5-1, 4-3, 6-5가 들어있습니다.여기서 5-1이냐 2-2냐는 답을 도출하는데 있어 중요치 않습니다.아래는 풀이한 코드 입니다.#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(void){ int n; cin &gt;&gt; n; int port[40001]; int cache[40001]; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; port[i]; } cache[1] = port[1]; int length = 1; for (int i = 2; i &lt;= n; i++) { if (cache[length] &lt; port[i]) cache[++length] = port[i]; else { cache[lower_bound(cache + 1, cache + length + 1, port[i]) - cache] = port[i]; } } cout &lt;&lt; length; return 0;}질문, 지적사항 댓글 부탁드립니다:)" }, { "title": "[백준] 1700번 멀티탭 스케줄링", "url": "/posts/algorithm-bj-1700/", "categories": "Algorithm", "tags": "Baekjoon, algorithm", "date": "2019-07-12 14:03:00 +0800", "snippet": "백준 알고리즘 1700번 멀티탭 스케줄링 문제풀이문제사용할 전자 기기의 순번이 정해져있고 멀티탭에서 가장 적게 콘센트를 뽑으면서 모든 전자기기를 사용하고 싶을 때, 콘센트 뽑는 횟수의 최소값은?풀이크게 3가지 정도로 나눠서 풀이할 수 있습니다.1. 멀티탭이 비어있을 경우2. 다음 순번의 기기가 이미 멀티탭에 꽂혀있는 경우3. 다음 순번의 기기가 멀티탭에 없을 경우 -&gt; 제일 마지막에 다시 사용되거나 사용될 일 없는 기기 찾기처음에는 너무 복잡하게 생각해서 정답은 맞췄지만 코드가 100줄이 넘어갔는데풀이를 정리해서 큰 틀부터 정리해 나가니 코드가 반토막이 났습니다…이미 멀티탭에 꽂혀있는 전자기기의 경우는 따로 boolean array를 통해 구분하여추가적인 서치가 필요 없도록 했습니다.아래는 해당 코드입니다!#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int tab[100] = { 0 };bool in_use[101] = { false };int main(void){ int n, k; int schedule[100]; int cnt = 0; int full_check_cnt = 0; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; k; i++) cin &gt;&gt; schedule[i]; for (int i = 0; i &lt; k; i++) { // 1. 멀티탭이 비어있을 경우 if (full_check_cnt &lt; n) { if (!in_use[schedule[i]]) { tab[full_check_cnt++] = schedule[i]; in_use[schedule[i]] = true; } } else { // 2. 다음 순번의 기기가 이미 멀티탭에 꽂혀있을 경우는 무시 // 3. 다음 순번의 기기가 멀티탭에 없을 경우 if (!in_use[schedule[i]]) { // 제일 마지막에 다시 사용되거나 사용될 일 없는 기기 찾기 int last_idx = 0; int change_idx = 0; // 현재 탭에 꽂혀있는 기기 loop for (int j = 0; j &lt; n; j++) { int tmp_idx = -1; // i 이후의 스케쥴에 있는 기기 loop for (int z = i + 1; z &lt; k; z++) { if (tab[j] == schedule[z]) { tmp_idx = z; break; } } // 이후에 쓰이지 않을 기기일 경우 바로 뽑아버리 if (tmp_idx &lt; 0) { change_idx = j; break; } else { if (last_idx &lt; tmp_idx) { last_idx = tmp_idx; change_idx = j; } } } // 사용중 여부(멀티탭 꽂힘 여부) 변경 in_use[tab[change_idx]] = false; cnt++; tab[change_idx] = schedule[i]; in_use[tab[change_idx]] = true; } } } cout &lt;&lt; cnt; return 0;}질문, 지적사항 댓글 남겨주세요 :)" }, { "title": "[백준] 1946번 신입사원", "url": "/posts/algorithm-bj-1946/", "categories": "Algorithm", "tags": "Baekjoon, algorithm", "date": "2019-07-12 00:22:00 +0800", "snippet": "백준 알고리즘 1946번 신입사원 문제풀이문제신입 사원을 뽑는데, 다른 모든 지원자와 비교했을 때서류심사 성적과 면접시험 성적 중 적어도 하나가 다른 지원자보다 떨어지지 않는 자만 선발한다.이 조건을 만족시키면서 선발할 수 있는 최대 인원수는??풀이우선, 서류 성적을 기준으로 정렬을 하면, 어짜피 서류성적은 이미 정렬해놔서 고려할 필요가 없고 본인보다 서류 성적이 높은 사람들의 최고 면접 점수보다 본인의 면접 점수가 높으면 합격할 수 있습니다.153 2  -&gt; 1 41 4      2 34 1      3 22 3      4 15 5      5 5예제를 바탕으로 위의 값(왼쪽)을 입력했다고 했을 경우,1등은 다른 지원자보다 떨어질 수가 없기에 기준점으로 잡고자 우선 오름차순 정렬(오른쪽)을 해줍니다.그 후, 면접성적이 본인보다 서류 성적이 높은 사람의 면접 성적(최대값)보다 높은 등수인지 확인합니다.(면접 성적을 위에서부터 비교하며 max값을 갱신하고 그 값과 면접 성적을 비교합니다.)아래는 풀이한 코드입니다.#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int t; cin &gt;&gt; t; while (t-- &gt; 0) { int n; cin &gt;&gt; n; int cnt = 1; pair&lt;int, int&gt; p[100000]; int a_idx, b_idx; for (int i = 0; i &lt; n; i++) { int a, b; cin &gt;&gt; a &gt;&gt; b; p[i] = make_pair(a, b); } sort(p, p + n); int pivot = p[0].second; for (int i = 1; i &lt; n; i++) { if (p[i].second &lt; pivot) { cnt++; pivot = p[i].second; } } cout &lt;&lt; cnt &lt;&lt; endl; } return 0;}궁금한점, 지적할점 댓글 환영합니다:)" }, { "title": "[백준] 2437번 저울", "url": "/posts/algorithm-bj-2437/", "categories": "Algorithm", "tags": "Baekjoon, algorithm", "date": "2019-07-10 14:51:00 +0800", "snippet": "백준 알고리즘 2437번 저울 문제 풀이문제무게가 양의 정수인 N개의 저울 추가 주어졌을 때, 이 추들을 사용하여 측정할 수 없는 양의 정수 무게 중 최솟값 구하기.풀이Greedy 방식으로 해결할 수 있는 문제로, 각 추를 정렬 후 누적합을 구하면서 해결해 나갈 수 있습니다.우선, 추의 배열을 w, 누적합의 배열을 acc라고 정의하겠습니다.무게가 1인 추가 있을 때, acc[i-1] + 1 &gt;= w[i] 일 경우 acc[i-1] ~ acc[i] 사이의 모든 수를 만들 수 있습니다. 만약 저 조건에 해당하지 않는다면 acc[i-1] + 1이 만들수 없는 수 입니다.그리고 무게가 1인 추가 없다면 당연히 답은 1이겠죠?문제에 제시된 예제를 통해 설명하도록 하겠습니다.  i 0 1 2 3 4 5 6 추(w) 1 1 2 3 6 7 30 누적합(acc) 1 2 4 7 13 20 50 acc[5]을 보시면 w[6] - 1보다 작아, 해당 예시의 정답은 21 입니다.처음 풀이를 알게 되었을 때는 이게 어떻게 성립하는 것인지 이해가 되지 않아서 반례를 찾아보려 했는데요..부질없는 짓이었고 오히려 명확하게는 아니지만 어느정도 이해하게 되었습니다.. 위 예제에서 답이 왜 21인지는 알겠지만 19, 18 뭐 이런 숫자들이 왜 다 만들 수 있는건지는 잘 이해는 안되네요 ㅎㅎ(ps. 혹시나 원리를 설명해주실 수 있으신 분은 댓글로 설명 나눠주시면 감사하겠습니다 ^^)아래는 풀이한 코드입니다.#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(void){ int n; int num[1000]; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; num[i]; sort(num, num + n); int result = 1; if (num[0] == 1) { int acc = num[0]; for (int i = 1; i &lt; n &amp;&amp; acc &gt;= num[i] - 1; i++) acc += num[i]; result = acc + 1; } cout &lt;&lt; result; return 0;}질문이나 지적하실 부분이 있다면 댓글 남겨주세요 :)" } ]
